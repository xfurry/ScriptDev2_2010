diff --git a/Makefile.am b/Makefile.am
index 9828fd4..bbb3905 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -402,6 +402,21 @@ scripts/northrend/ulduar/halls_of_stone/boss_sjonnir.cpp \
 scripts/northrend/ulduar/halls_of_stone/halls_of_stone.cpp \
 scripts/northrend/ulduar/halls_of_stone/halls_of_stone.h \
 scripts/northrend/ulduar/halls_of_stone/instance_halls_of_stone.cpp \
+scripts/northrend/ulduar/ulduar/boss_algalon.cpp \
+scripts/northrend/ulduar/ulduar/boss_auriaya.cpp \
+scripts/northrend/ulduar/ulduar/boss_freya.cpp \
+scripts/northrend/ulduar/ulduar/boss_hodir.cpp \
+scripts/northrend/ulduar/ulduar/boss_ignis.cpp \
+scripts/northrend/ulduar/ulduar/boss_iron_council.cpp \
+scripts/northrend/ulduar/ulduar/boss_kologarn.cpp \
+scripts/northrend/ulduar/ulduar/boss_leviathan.cpp \
+scripts/northrend/ulduar/ulduar/boss_mimiron.cpp \
+scripts/northrend/ulduar/ulduar/boss_razorscale.cpp \
+scripts/northrend/ulduar/ulduar/boss_thorim.cpp \
+scripts/northrend/ulduar/ulduar/boss_vezax.cpp \
+scripts/northrend/ulduar/ulduar/boss_xt002.cpp \
+scripts/northrend/ulduar/ulduar/boss_yogg_saron.cpp \
+scripts/northrend/ulduar/ulduar/ulduar.cpp \
 scripts/northrend/ulduar/ulduar/instance_ulduar.cpp \
 scripts/northrend/ulduar/ulduar/ulduar.h \
 scripts/northrend/utgarde_keep/utgarde_keep/boss_ingvar.cpp \
diff --git a/VC90/90ScriptDev2.vcproj b/VC90/90ScriptDev2.vcproj
index 46de99e..16c9812 100644
--- a/VC90/90ScriptDev2.vcproj
+++ b/VC90/90ScriptDev2.vcproj
@@ -1930,10 +1930,70 @@
 						Name="ulduar"
 						>
 						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_algalon.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_auriaya.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_freya.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_hodir.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_ignis.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_iron_council.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_kologarn.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_leviathan.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_mimiron.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_razorscale.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_thorim.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_vezax.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_xt002.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\boss_yogg_saron.cpp"
+							>
+						</File>
+						<File
 							RelativePath="..\scripts\northrend\ulduar\ulduar\instance_ulduar.cpp"
 							>
 						</File>
 						<File
+							RelativePath="..\scripts\northrend\ulduar\ulduar\ulduar.cpp"
+							>
+						</File>
+						<File
 							RelativePath="..\scripts\northrend\ulduar\ulduar\ulduar.h"
 							>
 						</File>
diff --git a/scripts/northrend/ulduar/ulduar/boss_algalon.cpp b/scripts/northrend/ulduar/ulduar/boss_algalon.cpp
new file mode 100644
index 0000000..bb2c67c
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_algalon.cpp
@@ -0,0 +1,763 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_algalon
+SD%Complete: 
+SDComment:
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    SAY_INTRO1                      = -1603270,
+    SAY_INTRO2                      = -1603271,
+    SAY_INTRO3                      = -1603272,
+    SAY_ENGAGE                      = -1603141,
+    SAY_AGGRO                       = -1603140,
+    SAY_SLAY1                       = -1603145,
+    SAY_SLAY2                       = -1603146,
+    SAY_SUMMON_STAR                 = -1603148,
+    SAY_BIGBANG1                    = -1603142,
+    SAY_BIGBANG2                    = -1603143,
+    SAY_PHASE2                      = -1603144, 
+    SAY_BERSERK                     = -1603147,
+    SAY_DESPAWN1                    = -1603273,
+    SAY_DESPAWN2                    = -1603274,
+    SAY_DESPAWN3                    = -1603275,
+    SAY_OUTRO1                      = -1603276,
+    SAY_OUTRO2                      = -1603277,
+    SAY_OUTRO3                      = -1603278,
+    SAY_OUTRO4                      = -1603149,
+    SAY_OUTRO5                      = -1603279,
+
+    /* not needed
+    SAY_BLACK_HOLE                   = -15391,
+    SAY_DEATH1                       = -15393,
+    SAY_TIMER1                       = -15398,
+    SAY_TIMER2                       = -15399,
+    SAY_TIMER3                       = -15400,
+    SAY_DEATH2                       = -15401,
+    SAY_DEATH3                       = -15402,
+    SAY_ADDS2                        = -15403,
+    SAY_SUMMON1                      = -15405,
+    SAY_SUMMON2                      = -15406,
+    SAY_SUMMON3                      = -15407,
+    */
+
+    //spells to be casted
+    SPELL_QUANTUM_STRIKE            = 64395, //Normal Quantum Strike
+    SPELL_QUANTUM_STRIKE_H          = 64592, //Heroic Quantum Strike
+    SPELL_PHASE_PUNCH               = 64412, //Phase punch 
+    SPELL_PHASE_PUNCH_SHIFT         = 64417,
+    SPELL_PHASE_PUNCH_TRIGGER       = 65508, 
+    SPELL_COSMIC_SMASH              = 62311, //62301, //Normal Cosmic Smash
+    SPELL_COSMIC_SMASH_H            = 64569, //64598, //Heroic Cosmic Smash
+    SPELL_BIG_BANG                  = 64443, //Normal Big Bang
+    SPELL_BIG_BANG_H                = 64584, //Heroic Big Bang
+    SPELL_ASCEND                    = 70063, //64487, //Ascend to the Heavens -> changed to "the fury of frostmourne" because is's broken
+    SPELL_BERSERK                   = 47008, //Berserk
+
+    // mobs
+    CREATURE_COLLAPSING_STAR        = 32955,    // they lose 1%hp per sec & cast black hole explosion when they die -> leave a black hole
+    SPELL_BLACK_HOLE_EXPLOSION      = 64122,
+    SPELL_BLACK_HOLE_EXPLOSION_H    = 65108,
+
+    CREATURE_BLACK_HOLE             = 32953,    // players must stay inside to avoid big bang
+
+    CREATURE_LIVING_CONSTELLATION   = 33052,    // if one enters a black hole they are despawned
+    SPELL_ARCANE_BARRAGE            = 64599, //Arcane Barage
+    SPELL_ARCANE_BARRAGE_H          = 64607, //Heroic Arcane Barage?
+
+    CREATURE_DARK_MATTER            = 33089,    // populates the black holes = 7
+
+};
+
+//Positional defines
+#define LOC_Z                       417.32f  
+struct LocationsXY
+{
+    float x, y;
+    uint32 id;
+};
+static LocationsXY SummonLoc[]=
+{
+    {1659.420f, -317.325f},
+    {1641.782f, -329.481f},
+    {1625.716f, -325.142f},
+    {1610.169f, -312.011f},
+    {1617.442f, -286.099f},
+    {1640.035f, -279.357f},
+};
+
+//Algalon
+struct MANGOS_DLL_DECL boss_algalonAI : public ScriptedAI
+{
+    boss_algalonAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        DespawnTimer = 6000000;  // 1h;
+        pCreature->setFaction(35);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    std::list<uint64> m_lCollapsingStarGUIDList;
+    std::list<uint64> m_lLivingConstelationGUIDList;
+
+    bool m_bIsRegularMode;
+
+    uint64 BlackHoleGUID;
+
+    uint32 Ascend_Timer;
+    uint32 Berserk_Timer;
+    uint32 BigBang_Timer;
+    uint32 CosmicSmash_Timer;
+    uint32 PhasePunch_Timer;
+    uint32 QuantumStrike_Timer;
+    uint32 CollapsingStar_Timer;
+    uint32 LivingConstellationTimer;
+    uint32 PhasePunchCheckTimer;
+    uint32 DarkMaterTimer;
+    uint32 DespawnTimer;
+
+    // intro & outro
+    bool isOutro;
+    uint32 OutroTimer;
+    uint32 Step;
+    bool isIntro;
+    uint32 IntroTimer;
+    uint32 IntroStep;
+
+    Creature *Algalon;
+
+    bool hasYoggChecked;
+
+    uint8 phase;
+    bool isPhase2;
+
+    bool isDespawned;
+    bool isFirstTime;
+
+    void Reset()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ALGALON, NOT_STARTED);
+
+        BlackHoleGUID = 0;
+
+        m_lCollapsingStarGUIDList.clear();
+        m_lLivingConstelationGUIDList.clear();
+
+        Ascend_Timer        = 480000; //8 minutes
+        QuantumStrike_Timer = 4000 + rand()%10000;
+        Berserk_Timer       = 360000; //6 minutes
+        CollapsingStar_Timer = urand(15000, 20000); //Spawns between 15 to 20 seconds
+        LivingConstellationTimer = 60000;
+        BigBang_Timer       = 90000;
+        DarkMaterTimer      = 90000;
+        PhasePunch_Timer    = 8000;
+        CosmicSmash_Timer   = urand(30000, 60000);
+        PhasePunchCheckTimer = 40000;
+
+        phase = 10;
+        isPhase2 = false;
+
+        OutroTimer          = 10000;
+        Step                = 1;
+        isIntro             = true;
+        IntroTimer          = 10000;
+        IntroStep           = 1;
+        isOutro             = false;  
+
+        isDespawned         = false;
+        hasYoggChecked      = false;
+        isFirstTime         = false;
+
+        if(!isFirstTime)
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        DespawnCollapsingStar();
+    }
+
+    void KilledUnit(Unit *victim)
+    {
+        switch(urand(0, 1))
+        {
+        case 0: DoScriptText(SAY_SLAY1, m_creature); break;
+        case 1: DoScriptText(SAY_SLAY2, m_creature); break;
+        }
+    }
+
+    void DoOutro()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ALGALON, DONE);
+
+        m_creature->ForcedDespawn();
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        if (!pWho)
+            return;
+
+        if (pWho->isTargetableForAttack() && pWho->isInAccessablePlaceFor(m_creature) && m_creature->IsHostileTo(pWho) &&
+            pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 40) && phase > 2)
+        {
+            SetCombatMovement(false);
+            phase = 0;
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > m_creature->GetHealth())
+        {
+            uiDamage = 0;
+            isOutro = true;
+        }
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        phase = 1;
+        if(isFirstTime)
+            DoScriptText(SAY_ENGAGE, m_creature);
+        else
+            DoScriptText(SAY_AGGRO, m_creature);
+
+        m_creature->SetInCombatWithZone();
+        SetCombatMovement(true);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ALGALON, IN_PROGRESS);
+    }
+
+    void DespawnCollapsingStar()
+    {
+        if (m_lCollapsingStarGUIDList.empty())
+            return;
+
+        for(std::list<uint64>::iterator itr = m_lCollapsingStarGUIDList.begin(); itr != m_lCollapsingStarGUIDList.end(); ++itr)
+        {
+            if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+            {
+                if (pTemp->isAlive())
+                    pTemp->ForcedDespawn();
+            }
+        }
+        m_lCollapsingStarGUIDList.clear();
+
+        if (m_lLivingConstelationGUIDList.empty())
+            return;
+
+        for(std::list<uint64>::iterator itr = m_lLivingConstelationGUIDList.begin(); itr != m_lLivingConstelationGUIDList.end(); ++itr)
+        {
+            if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+            {
+                if (pTemp->isAlive())
+                    pTemp->ForcedDespawn();
+            }
+        }
+        m_lLivingConstelationGUIDList.clear();
+    }
+
+    void JustSummoned(Creature* pSummoned)
+    {
+        if (pSummoned->GetEntry() == CREATURE_COLLAPSING_STAR)
+            m_lCollapsingStarGUIDList.push_back(pSummoned->GetGUID());
+
+        if (pSummoned->GetEntry() == CREATURE_LIVING_CONSTELLATION)
+            m_lLivingConstelationGUIDList.push_back(pSummoned->GetGUID());
+    }
+
+    void SummonCollapsingStar()
+    {
+        uint8 i = urand(0, 2);
+        for(uint8 j = i; j < i + urand(3, 4); j++)
+            m_creature->SummonCreature(CREATURE_COLLAPSING_STAR, SummonLoc[j].x, SummonLoc[j].y, LOC_Z, 0, TEMPSUMMON_CORPSE_DESPAWN, 10000);  
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        // check for first time
+        if(m_pInstance && m_pInstance->GetData(TYPE_YOGGSARON) == DONE && !hasYoggChecked)
+        {
+            // update world state
+            m_creature->setFaction(14);
+            isFirstTime = true;
+            hasYoggChecked = true;
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+            if (m_pInstance)
+                m_pInstance->SetData(TYPE_YOGGSARON, SPECIAL);
+        }
+
+        // despawn timer
+        if(DespawnTimer < uiDiff && !isDespawned)
+        {
+            isDespawned = true;
+            isOutro = true;
+        }
+        else DespawnTimer -= uiDiff;
+
+        if(!isOutro)
+        {
+            // intro
+            if(phase == 0)
+            {
+                if(isIntro  && isFirstTime)
+                {
+                    switch(IntroStep)
+                    {
+                    case 1:
+                        DoScriptText(SAY_INTRO1, m_creature);
+                        ++IntroStep;
+                        IntroTimer = 7000;
+                        break;
+                    case 3:
+                        DoScriptText(SAY_INTRO2, m_creature);
+                        ++IntroStep;
+                        IntroTimer = 7000;
+                        break;
+                    case 5:
+                        DoScriptText(SAY_INTRO3, m_creature);
+                        ++IntroStep;
+                        IntroTimer = 10000;
+                        break;
+                    case 7:
+                        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                        isIntro = false;
+                        ++IntroStep;
+                        IntroTimer = 10000;
+                        break;
+                    }
+                }
+                else return;
+
+                if (IntroTimer <= uiDiff)
+                {
+                    ++IntroStep;
+                    IntroTimer = 330000;
+                } IntroTimer -= uiDiff;
+            }
+
+            if(phase == 1)
+            {
+                if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                    return;
+
+                // spells
+                if(QuantumStrike_Timer < uiDiff)
+                {
+                    DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_QUANTUM_STRIKE : SPELL_QUANTUM_STRIKE_H);
+                    QuantumStrike_Timer = 4000 + rand()%10000;
+                }else QuantumStrike_Timer -= uiDiff;
+
+                if(BigBang_Timer < uiDiff)
+                {
+                    DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_BIG_BANG : SPELL_BIG_BANG_H, true);
+                    BigBang_Timer = 90000;
+                    DarkMaterTimer = 10000;
+                }else BigBang_Timer -= uiDiff;
+
+                if(CosmicSmash_Timer < uiDiff)
+                {
+                    DoCast(SelectUnit(SELECT_TARGET_RANDOM, 0), m_bIsRegularMode ? SPELL_COSMIC_SMASH : SPELL_COSMIC_SMASH_H, true);
+                    CosmicSmash_Timer = urand(30000, 60000);
+                }else CosmicSmash_Timer -= uiDiff;
+
+                if(PhasePunch_Timer < uiDiff)
+                {
+                    DoCast(m_creature->getVictim(),SPELL_PHASE_PUNCH);
+                    PhasePunch_Timer = 8000;
+                }else PhasePunch_Timer -= uiDiff;
+
+                if(PhasePunchCheckTimer < uiDiff)
+                {
+                    Map *map = m_creature->GetMap();
+                    if (map->IsDungeon())
+                    {
+                        Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                        if (PlayerList.isEmpty())
+                            return;
+
+                        for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                        {
+                            if (i->getSource()->isAlive() && i->getSource()->HasAura(SPELL_PHASE_PUNCH, EFFECT_INDEX_0))
+                            {
+                                Aura *phasePunch = i->getSource()->GetAura(SPELL_PHASE_PUNCH, EFFECT_INDEX_0);
+                                if(phasePunch->GetStackAmount() > 4)
+                                {
+                                    i->getSource()->RemoveAurasDueToSpell(SPELL_PHASE_PUNCH);
+                                    DoCast(i->getSource(), SPELL_PHASE_PUNCH_SHIFT);
+                                }
+                            }
+                        }
+                    }
+                    PhasePunchCheckTimer = 1000;
+                }else PhasePunchCheckTimer -= uiDiff;
+
+                // ascent
+                if(Ascend_Timer < uiDiff)
+                {
+                    DoCast(m_creature->getVictim(),SPELL_ASCEND, true);
+                    Ascend_Timer = 480000;
+                }else Ascend_Timer -= uiDiff;
+
+                // berserk
+                if(Berserk_Timer < uiDiff)
+                {
+                    DoScriptText(SAY_BERSERK, m_creature);	
+                    //DoCast(m_creature->getVictim(),SPELL_BERSERK, true);
+                    DoCast(m_creature ,SPELL_ASCEND);
+                    Berserk_Timer = 360000;
+                }else Berserk_Timer -= uiDiff;
+
+                // summons
+                if(CollapsingStar_Timer < uiDiff && !isPhase2)
+                {
+                    DoScriptText(SAY_SUMMON_STAR, m_creature);
+                    SummonCollapsingStar();
+                    CollapsingStar_Timer = 90000;
+                }else CollapsingStar_Timer -= uiDiff;
+
+                if(LivingConstellationTimer < uiDiff && !isPhase2)
+                {
+                    for(uint8 i = 0; i < urand (1, 3); i++)
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            m_creature->SummonCreature(CREATURE_LIVING_CONSTELLATION, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000);
+                    }
+                    LivingConstellationTimer = 30000;
+                }else LivingConstellationTimer -= uiDiff;
+
+                if(DarkMaterTimer < uiDiff && !isPhase2)
+                {
+                    for(uint8 i = 0; i < 7; i++)
+                    {
+                        Creature *darkMatter = m_creature->SummonCreature(CREATURE_DARK_MATTER, SummonLoc[i].x, SummonLoc[i].y, LOC_Z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);  
+                        if(m_bIsRegularMode)
+                            darkMatter->SetMaxHealth(19550);
+                    }
+                    DarkMaterTimer = 90000;
+                }else DarkMaterTimer -= uiDiff;
+
+                // hp check
+                if(!isPhase2 && m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= 20)
+                {
+                    DoScriptText(SAY_PHASE2, m_creature);
+                    isPhase2 = true;
+                }
+
+                DoMeleeAttackIfReady();
+
+                EnterEvadeIfOutOfCombatArea(uiDiff);
+            }
+        }
+        // outro
+        if(isOutro)
+        {
+            switch(Step)
+            {
+            case 1:
+                Algalon = m_creature;
+                Algalon->setFaction(35);
+                Algalon->RemoveAllAuras();
+                Algalon->DeleteThreatList();
+                Algalon->CombatStop(true);
+                Algalon->InterruptNonMeleeSpells(false);
+                Algalon->SetHealth(m_creature->GetMaxHealth());
+                Algalon->GetMotionMaster()->MovePoint(0, 1631.970f, -302.635f, 417.321f);
+                Algalon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                ++Step;
+                OutroTimer = 5000;
+                break;
+            case 3:
+                // make boss kneel
+                Algalon->SetSplineFlags(SPLINEFLAG_UNKNOWN12);
+                if(isDespawned)
+                {
+                    DoScriptText(SAY_DESPAWN1, Algalon);
+                    ++Step;
+                    OutroTimer = 15000;
+                }
+                else
+                {
+                    DoScriptText(SAY_OUTRO1, Algalon);
+                    ++Step;
+                    OutroTimer = 37000;
+                }
+                break;
+            case 5:
+                if(isDespawned)
+                {
+                    DoScriptText(SAY_DESPAWN2, Algalon);
+                    ++Step;
+                    OutroTimer = 8000;
+                }
+                else
+                {
+                    DoScriptText(SAY_OUTRO2, Algalon);
+                    ++Step;
+                    OutroTimer = 17000;
+                }
+                break;
+            case 7:
+                if(isDespawned)
+                {
+                    DoScriptText(SAY_DESPAWN3, Algalon);
+                    ++Step;
+                    OutroTimer = 7000;
+                }
+                else
+                {
+                    DoScriptText(SAY_OUTRO3, Algalon);
+                    ++Step;
+                    OutroTimer = 12000;
+                }
+                break;
+            case 9:
+                if(isDespawned)
+                {
+                    DoCast(Algalon, SPELL_ASCEND);
+                    ++Step;
+                    OutroTimer = 5000;
+                }
+                else
+                {
+                    DoScriptText(SAY_OUTRO4, Algalon);
+                    ++Step;
+                    OutroTimer = 11000;
+                }
+                break;
+            case 11:
+                if(isDespawned)
+                {
+                    if (m_pInstance)
+                        m_pInstance->SetData(TYPE_YOGGSARON, DONE);
+                    Algalon->ForcedDespawn();
+                }
+                else
+                {
+                    DoScriptText(SAY_OUTRO5, Algalon);
+                    if (m_pInstance)
+                        m_pInstance->SetData(TYPE_YOGGSARON, DONE);
+                    ++Step;
+                    OutroTimer = 13000;
+                }
+                break;
+            case 13:
+                DoOutro();
+                ++Step;
+                OutroTimer = 10000;
+                break;
+            }
+        }
+        else 
+            return;
+
+        if (OutroTimer <= uiDiff)
+        {
+            ++Step;
+            OutroTimer = 330000;
+        } OutroTimer -= uiDiff;
+    }	
+};	
+
+//Collapsing Star
+struct MANGOS_DLL_DECL mob_collapsing_starAI : public ScriptedAI
+{
+    mob_collapsing_starAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        pCreature->SetSpeedRate(MOVE_RUN, 0.5f);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 healthTimer;
+
+    void Reset()
+    {
+        healthTimer = 1000;
+    }
+
+    void JustDied(Unit *victim)
+    {
+        DoCast(m_creature, m_bIsRegularMode ? SPELL_BLACK_HOLE_EXPLOSION : SPELL_BLACK_HOLE_EXPLOSION_H);
+        m_creature->SummonCreature(CREATURE_BLACK_HOLE, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(healthTimer < uiDiff)
+        {
+            m_creature->DeleteThreatList();
+            m_creature->GetMotionMaster()->MoveConfused();
+            m_creature->DealDamage(m_creature, (m_creature->GetMaxHealth() * 0.1), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            healthTimer = 1000;
+        }else healthTimer -= uiDiff;
+    }	
+};
+
+//Living constellation
+struct MANGOS_DLL_DECL mob_living_constellationAI : public ScriptedAI
+{
+    mob_living_constellationAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        pCreature->SetSpeedRate(MOVE_RUN, 0.5f);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 ArcaneBarrageTimer;
+
+    void Reset()
+    {
+        ArcaneBarrageTimer = 15000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (ArcaneBarrageTimer < uiDiff)
+        {
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0)){
+                DoCast(target, m_bIsRegularMode ? SPELL_ARCANE_BARRAGE : SPELL_ARCANE_BARRAGE_H);
+            }
+            ArcaneBarrageTimer = 15000;
+        }else ArcaneBarrageTimer -= uiDiff;
+    }	
+};
+
+//Black hole
+struct MANGOS_DLL_DECL mob_black_holeAI : public ScriptedAI
+{
+    mob_black_holeAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 playersCheckTimer;
+
+    void Reset()
+    {
+        playersCheckTimer = 1000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (playersCheckTimer < uiDiff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                        DoCast(i->getSource(), SPELL_PHASE_PUNCH_SHIFT);
+                }
+            } 
+
+            if(Creature *pConstellation = GetClosestCreatureWithEntry(m_creature, CREATURE_LIVING_CONSTELLATION, 2))
+            {
+                m_creature->DealDamage(pConstellation, pConstellation->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                m_creature->ForcedDespawn();
+            }
+            playersCheckTimer = 1000;
+        }
+        else playersCheckTimer -= uiDiff;
+    }	
+};
+
+CreatureAI* GetAI_boss_algalon(Creature* pCreature)
+{
+    return new boss_algalonAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_collapsing_star(Creature* pCreature)
+{
+    return new mob_collapsing_starAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_living_constellation(Creature* pCreature)
+{
+    return new mob_living_constellationAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_black_hole(Creature* pCreature)
+{
+    return new mob_black_holeAI(pCreature);
+}
+
+void AddSC_boss_algalon()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_algalon";
+    newscript->GetAI = &GetAI_boss_algalon;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_collapsing_star";
+    newscript->GetAI = &GetAI_mob_collapsing_star;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_living_constellation";
+    newscript->GetAI = &GetAI_mob_living_constellation;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_black_hole";
+    newscript->GetAI = &GetAI_mob_black_hole;
+    newscript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_auriaya.cpp b/scripts/northrend/ulduar/ulduar/boss_auriaya.cpp
new file mode 100644
index 0000000..3d0694b
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_auriaya.cpp
@@ -0,0 +1,615 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_auriaya
+SD%Complete: 95%
+SDComment: missing yells. need correct setstack for feral defender buff
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    //yells
+    SAY_AGGRO       = -1603070,
+    SAY_SLAY1       = -1603071,
+    SAY_SLAY2       = -1603072,
+    SAY_BERSERK     = -1603073,
+    SAY_DEATH       = -1603074,
+
+    //auriaya
+    SPELL_BERSERK				= 47008,
+    SPELL_GUARDIAN_SWARM		= 64396,    // broken
+    SPELL_SENTINEL_BLAST		= 64389,
+    SPELL_SENTINEL_BLAST_H		= 64678,
+    SPELL_SONIC_SCREECH			= 64422,
+    SPELL_SONIC_SCREECH_H		= 64688,
+    SPELL_FEAR					= 64386,
+    //feral defender
+    SPELL_FEIGN_DEATH			= 57685,
+    SPELL_FERAL_ESSENCE			= 64455,
+    SPELL_FERAL_POUNCE			= 64478,
+    SPELL_FERAL_POUNCE_H		= 64669,
+    SPELL_FERAL_RUSH			= 64496,
+    SPELL_FERAL_RUSH_H			= 64674,
+    //sanctum sentry
+    SPELL_RIP_FLESH				= 64375,
+    SPELL_RIP_FLESH_H			= 64667,
+    SPELL_SAVAGE_POUNCE			= 64666,
+    SPELL_SAVAGE_POUNCE_H		= 64374,
+    SPELL_STRENGHT_OF_PACK		= 64381,
+    //seeping feral essence
+    AURA_VOID_ZONE				= 64458,
+    AURA_VOID_ZONE_H			= 64676,
+    //NPC ids
+    MOB_VOID_ZONE				= 34098,
+    MOB_FERAL_DEFENDER			= 34035,
+    MOB_GUARDIAN_SWARN          = 34034,
+
+    ACHIEV_CRAZY_CAT_LADY       = 3006,
+    ACHIEV_CRAZY_CAT_LADY_H     = 3007,
+
+    ACHIEV_NINE_LIVES           = 3076,
+    ACHIEV_NINE_LIVES_H         = 3077,
+};
+
+bool m_bCrazyCatLady;
+bool m_bNineLives;
+// Seeping Feral Essence
+struct MANGOS_DLL_DECL mob_seeping_feral_essenceAI : public ScriptedAI
+{
+    mob_seeping_feral_essenceAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        SetCombatMovement(false);
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 Check_Timer;
+    uint32 Spell_Timer;
+
+    void Reset()
+    {
+        Spell_Timer = 1000;
+        Check_Timer = 5000;
+        m_creature->SetDisplayId(11686);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        DoCast(m_creature, m_bIsRegularMode ? AURA_VOID_ZONE : AURA_VOID_ZONE_H);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->getVictim())
+        {
+            if (Check_Timer < diff)
+            {
+                if(m_pInstance->GetData(TYPE_AURIAYA) == FAIL || m_pInstance->GetData(TYPE_AURIAYA) == DONE)
+                    m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                Check_Timer = 5000;
+            }else Check_Timer -= diff;
+        }
+
+        if (Check_Timer < diff)
+        {
+            if(m_pInstance->GetData(TYPE_AURIAYA) == FAIL || m_pInstance->GetData(TYPE_AURIAYA) == DONE)
+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            Check_Timer = 5000;
+        }else Check_Timer -= diff;
+
+        if (Spell_Timer < diff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                        i->getSource()->DealDamage(i->getSource(), m_bIsRegularMode ? 4500 : 6500, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_SHADOW, NULL, false);
+                }
+            } 
+            Spell_Timer = 1000;
+        }else Spell_Timer -= diff; 
+    }
+};
+
+CreatureAI* GetAI_mob_seeping_feral_essence(Creature* pCreature)
+{
+    return new mob_seeping_feral_essenceAI(pCreature);
+}
+
+// Sanctum Sentry
+struct MANGOS_DLL_DECL mob_sanctum_sentryAI : public ScriptedAI
+{
+    mob_sanctum_sentryAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 Rip_Flesh_Timer;
+    uint32 Jump_Timer;
+    uint32 Check_Timer;
+
+    void Reset()
+    {
+        Rip_Flesh_Timer = 13000;
+        Jump_Timer = 0;
+        Check_Timer = 500;
+
+        m_bCrazyCatLady = true;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+        {
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_1))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_2))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_3))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_4))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_AURIAYA))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+        }
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        m_bCrazyCatLady = false;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_AURIAYA))))
+                if (pTemp->isAlive())
+                {
+                    m_creature->GetMotionMaster()->MoveFollow(pTemp,0.0f,0.0f);
+                    m_creature->GetMap()->CreatureRelocation(m_creature, pTemp->GetPositionX(), pTemp->GetPositionY(), pTemp->GetPositionZ(), 0.0f);
+                }
+
+                if (Rip_Flesh_Timer < diff)
+                {
+                    DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_RIP_FLESH : SPELL_RIP_FLESH_H);
+                    Rip_Flesh_Timer = 13000;
+                }else Rip_Flesh_Timer -= diff;
+
+                if (Jump_Timer < diff)
+                {
+                    if (!m_creature->IsWithinDistInMap(m_creature->getVictim(), 8) && m_creature->IsWithinDistInMap(m_creature->getVictim(), 25))
+                        DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_SAVAGE_POUNCE : SPELL_SAVAGE_POUNCE_H);
+                    Jump_Timer = 1000;
+                }else Jump_Timer -= diff;
+
+                if (Check_Timer < diff)
+                {
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_1))))
+                        if (pTemp->isAlive())
+                            if (pTemp->IsWithinDistInMap(m_creature->getVictim(), 10))
+                                if (pTemp->HasAura(SPELL_STRENGHT_OF_PACK))
+                                    pTemp->GetAura(SPELL_STRENGHT_OF_PACK, EFFECT_INDEX_0)->modStackAmount(+1);
+                                else
+                                    DoCast(m_creature->getVictim(), SPELL_STRENGHT_OF_PACK);
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_2))))
+                        if (pTemp->isAlive())
+                            if (pTemp->IsWithinDistInMap(m_creature->getVictim(), 10))
+                                if (pTemp->HasAura(SPELL_STRENGHT_OF_PACK))
+                                    pTemp->GetAura(SPELL_STRENGHT_OF_PACK, EFFECT_INDEX_0)->modStackAmount(+1);
+                                else
+                                    DoCast(m_creature->getVictim(), SPELL_STRENGHT_OF_PACK);
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_3))))
+                        if (pTemp->isAlive())
+                            if (pTemp->IsWithinDistInMap(m_creature->getVictim(), 10))
+                                if (pTemp->HasAura(SPELL_STRENGHT_OF_PACK))
+                                    pTemp->GetAura(SPELL_STRENGHT_OF_PACK, EFFECT_INDEX_0)->modStackAmount(+1);
+                                else
+                                    DoCast(m_creature->getVictim(), SPELL_STRENGHT_OF_PACK);
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_4))))
+                        if (pTemp->isAlive())
+                            if (pTemp->IsWithinDistInMap(m_creature->getVictim(), 10))
+                                if (pTemp->HasAura(SPELL_STRENGHT_OF_PACK))
+                                    pTemp->GetAura(SPELL_STRENGHT_OF_PACK, EFFECT_INDEX_0)->modStackAmount(+1);
+                                else
+                                    DoCast(m_creature->getVictim(), SPELL_STRENGHT_OF_PACK);
+                    if (m_creature->HasAura(SPELL_STRENGHT_OF_PACK))
+                    {
+                        if (m_creature->GetAura(SPELL_STRENGHT_OF_PACK, EFFECT_INDEX_0)->GetStackAmount() == 1)
+                            m_creature->RemoveAurasDueToSpell(SPELL_STRENGHT_OF_PACK);
+                        else
+                            m_creature->GetAura(SPELL_STRENGHT_OF_PACK, EFFECT_INDEX_0)->modStackAmount(-1);
+                    }
+                    Check_Timer = 2100;
+                }else Check_Timer -= diff;
+
+                DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_sanctum_sentry(Creature* pCreature)
+{
+    return new mob_sanctum_sentryAI(pCreature);
+}
+
+// Feral Defender
+struct MANGOS_DLL_DECL mob_feral_defenderAI : public ScriptedAI
+{
+    mob_feral_defenderAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 revive_delay;
+    uint32 Pounce_Timer;
+    uint32 Rush_Start_Timer;
+    uint32 Rush_Finish_Timer;
+    uint32 Rush_Delay;
+    uint32 Revive_Delay;
+    uint32 stack_delay;
+
+    bool rush;
+    bool dead;
+    bool rdy;
+
+    void Reset()
+    {
+        stack_delay = 500;
+        Pounce_Timer = 5000;
+        Rush_Start_Timer = 9000;
+        rdy = false;
+        rush = false;
+        dead = false;
+        DoCast(m_creature, SPELL_FERAL_ESSENCE);
+
+        m_bNineLives = false;
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        m_bNineLives = true;
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+        if (uiDamage > m_creature->GetHealth())
+        {
+            uiDamage = 0;
+            m_creature->CastStop();
+            m_creature->RemoveArenaAuras(true);
+            m_creature->SummonCreature(MOB_VOID_ZONE, 0.0f, 0.0f, 0.0f, 0, TEMPSUMMON_DEAD_DESPAWN, 0);
+            DoCast(m_creature, SPELL_FEIGN_DEATH);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            if (m_creature->HasAura(SPELL_FERAL_ESSENCE))
+            {
+                if (m_creature->GetAura(SPELL_FERAL_ESSENCE, EFFECT_INDEX_0)->GetStackAmount() == 1)
+                    m_creature->RemoveAurasDueToSpell(SPELL_FERAL_ESSENCE);
+                else
+                    m_creature->GetAura(SPELL_FERAL_ESSENCE, EFFECT_INDEX_0)->modStackAmount(-1);
+
+                Revive_Delay = urand(30000, 45000);
+                dead = true;
+            }
+            else
+                m_bNineLives = true;
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Pounce_Timer < diff)
+        {
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0)){
+                DoCast(target, m_bIsRegularMode ? SPELL_FERAL_POUNCE : SPELL_FERAL_POUNCE_H);
+                m_creature->AddThreat(target,0.0f);
+                m_creature->AI()->AttackStart(target);
+            }
+            Pounce_Timer = 5000;
+        }else Pounce_Timer -= diff;
+
+        if (Rush_Start_Timer < diff)
+        {
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0)){
+                DoCast(target, m_bIsRegularMode ? SPELL_FERAL_RUSH : SPELL_FERAL_RUSH_H);
+                m_creature->AddThreat(target,0.0f);
+                m_creature->AI()->AttackStart(target);
+            }
+            Rush_Start_Timer = 35000;
+            Rush_Finish_Timer = 5000;
+            Rush_Delay = 500;
+        }else Rush_Start_Timer -= diff;
+
+        if (Rush_Delay < diff && rush)
+        {
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0)){
+                DoCast(target, m_bIsRegularMode ? SPELL_FERAL_RUSH : SPELL_FERAL_RUSH_H);
+                m_creature->AddThreat(target,0.0f);
+                m_creature->AI()->AttackStart(target);
+            }
+            Rush_Delay = 500;
+        }else Rush_Delay -= diff;
+
+        if (Rush_Finish_Timer < diff)
+            rush = false;
+        else Rush_Finish_Timer -= diff;
+
+        if (Revive_Delay < diff && dead)
+        {
+            m_creature->SetHealth(m_creature->GetMaxHealth());
+            m_creature->RemoveAurasDueToSpell(SPELL_FEIGN_DEATH);
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            dead = false;
+        }else Revive_Delay -= diff;
+
+        if (stack_delay < diff && !rdy)
+        {
+            DoCast(m_creature, SPELL_FERAL_ESSENCE);
+            if (m_creature->GetAura(SPELL_FERAL_ESSENCE, EFFECT_INDEX_0)->GetStackAmount() == 8)
+                rdy = true;
+            stack_delay = 500;
+        }else stack_delay -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_feral_defender(Creature* pCreature)
+{
+    return new mob_feral_defenderAI(pCreature);
+}
+
+// Auriaya
+struct MANGOS_DLL_DECL boss_auriayaAI : public ScriptedAI
+{
+    boss_auriayaAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 Enrage_Timer;
+    uint32 Swarm_Timer;
+    uint32 Sonic_Screech_Timer;
+    uint32 Sentinel_Blast_Timer;
+    uint32 Fear_Timer;
+    uint32 Summon_Timer;
+    uint8 Swarmcount;
+
+    bool enrage;
+    bool summoned;
+
+    void Reset()
+    {
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+        Enrage_Timer = 600000;
+        Swarm_Timer = 130000;
+        Sonic_Screech_Timer = 120000;
+        Sentinel_Blast_Timer = 62000;
+        Fear_Timer = 60000;
+        Summon_Timer = 90000;
+        Swarmcount = 10;
+        enrage= false;
+        summoned = false;
+
+        m_bCrazyCatLady = true;
+        m_bNineLives = false;
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        //death yell
+        DoScriptText(SAY_DEATH, m_creature);
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_AURIAYA, DONE);
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_FERAL_DEFENDER))))
+                if (pTemp->isAlive())
+                    pTemp->ForcedDespawn();
+        }
+
+        if (m_bCrazyCatLady)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_CRAZY_CAT_LADY : ACHIEV_CRAZY_CAT_LADY_H);
+        }
+
+        if (m_bNineLives)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_NINE_LIVES : ACHIEV_NINE_LIVES_H);
+        }
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_AURIAYA, IN_PROGRESS);
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_1))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_2))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_3))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_4))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+        }
+        //aggro yell
+        DoScriptText(SAY_AGGRO, m_creature);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_AURIAYA, FAIL);
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_1))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_2))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_3))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_SENTRY_4))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Fear_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_FEAR);
+            Fear_Timer = urand(35000, 45000);
+            Sentinel_Blast_Timer = 2500;
+        }else Fear_Timer -= diff;
+
+        if (Sentinel_Blast_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_SENTINEL_BLAST : SPELL_SENTINEL_BLAST_H);
+            Sentinel_Blast_Timer = urand(30000, 40000);
+        }else Sentinel_Blast_Timer -= diff;
+
+        if (Summon_Timer < diff && !summoned)
+        {
+            if (Creature* pTemp = m_creature->SummonCreature(MOB_FERAL_DEFENDER, 0.0f, 0.0f, 0.0f, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+                summoned = true;
+        }else Summon_Timer -= diff;
+
+        if (Sonic_Screech_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_SONIC_SCREECH : SPELL_SONIC_SCREECH_H);
+            Sonic_Screech_Timer = 45000;
+        }else Sonic_Screech_Timer -= diff;
+
+        if (Swarm_Timer < diff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+            {
+                DoCast(pTarget, SPELL_GUARDIAN_SWARM);
+                for (uint8 i = 0; i < Swarmcount; i++)
+                    if (Creature* pTemp = m_creature->SummonCreature(MOB_GUARDIAN_SWARN, pTarget->GetPositionX() + urand(-5, 5), pTarget->GetPositionY() + urand(-5, 5), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                    {
+                        pTemp->AddThreat(pTarget,0.0f);
+                        pTemp->AI()->AttackStart(pTarget);
+                    }
+            }
+            Swarmcount = 0;
+            Swarm_Timer = 45000;
+        }else Swarm_Timer -= diff;
+
+        if (Enrage_Timer < diff && !enrage)
+        {
+            //enrage yell
+            DoScriptText(SAY_BERSERK, m_creature);
+            m_creature->CastStop();
+            DoCast(m_creature, SPELL_BERSERK);
+            enrage = true;
+        }else Enrage_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_auriaya(Creature* pCreature)
+{
+    return new boss_auriayaAI(pCreature);
+}
+
+void AddSC_boss_auriaya()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_auriaya";
+    NewScript->GetAI = GetAI_boss_auriaya;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_seeping_feral_essence";
+    NewScript->GetAI = &GetAI_mob_seeping_feral_essence;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_sanctum_sentry";
+    NewScript->GetAI = &GetAI_mob_sanctum_sentry;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_feral_defender";
+    NewScript->GetAI = &GetAI_mob_feral_defender;
+    NewScript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_freya.cpp b/scripts/northrend/ulduar/ulduar/boss_freya.cpp
new file mode 100644
index 0000000..d394d72
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_freya.cpp
@@ -0,0 +1,976 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_freya
+SD%Complete: 80%
+SDComment: fix outro, makes server crash :|
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    /* YELLS */
+    // freya
+    SAY_AGGRO               = -1603000,
+    SAY_AGGRO_HARD          = -1603001,
+    SAY_SUMMON1             = -1603002,
+    SAY_SUMMON2             = -1603003,
+    SAY_SUMMON3             = -1603004,
+    SAY_SLAY1               = -1603005,
+    SAY_SLAY2               = -1603006,
+    SAY_DEATH               = -1603007,
+    SAY_BERSERK             = -1603008,
+    //brightleaf
+    SAY_BRIGHTLEAF_AGGRO    = -1603160,
+    SAY_BRIGHTLEAF_SLAY1    = -1603161,
+    SAY_BRIGHTLEAF_SLAY2    = -1603162,
+    SAY_BRIGHTLEAF_DEATH    = -1603163,
+    //Ironbranch
+    SAY_IRONBRANCH_AGGRO    = -1603170,
+    SAY_IRONBRANCH_SLAY1    = -1603171,
+    SAY_IRONBRANCH_SLAY2    = -1603172,
+    SAY_IRONBRANCH_DEATH    = -1603173,
+    //Stonebark
+    SAY_STONEBARK_AGGRO     = -1603180,
+    SAY_STONEBARK_SLAY1     = -1603181,
+    SAY_STONEBARK_SLAY2     = -1603182,
+    SAY_STONEBARK_DEATH     = -1603183,
+
+    /* BOSS SPELLS */
+    SPELL_ATTUNED_TO_NATURE        = 62519, //increases healing, start at 150 stacks
+    SPELL_TOUCH_OF_EONAR           = 62528, //heals Freya, 6k per second
+    SPELL_TOUCH_OF_EONAR_H         = 62892, //heals Freya, 24k per second
+    SPELL_SUNBEAM                  = 62623,
+    SPELL_SUNBEAM_H                = 62872,
+    SPELL_BERSERK                  = 47008, // 10 min
+
+    /* HARD MODE SPELLS */
+    SPELL_DRAINED_OF_POWER      = 62467,
+    // brightleaf
+    SPELL_UNSTABLE_ENERGY_FREYA = 62451,
+    SPELL_UNSTABLE_ENERGY_FREYA_H=62865,
+    SPELL_BRIGHTLEAFS_ESSENCE   = 62968, //62385,
+    // ironbrach
+    SPELL_STRENGHTEN_IRON_ROOTS = 63601,
+    MOB_STRENGHTEN_IRON_ROOTS   = 33168,
+    SPELL_IRON_ROOTS_FREYA      = 62283,
+    SPELL_IRON_ROOTS_FREYA_H    = 62930,
+    SPELL_IRONBRACHS_ESSENCE    = 62713, //62387,
+    // stonebark
+    SPELL_GROUND_TREMOR_FREYA   = 62437,
+    SPELL_GROUND_TREMOR_FREYA_H = 62859,
+    SPELL_STONEBARKS_ESSENCE    = 65590, //62386,
+
+
+    // sanctuary adds 
+    MOB_EONARS_GIFT             = 33228,
+    SPELL_LIFEBINDERS_GIFT      = 62584,    // after 12 secs, heals Freya & her allies for 30%
+    SPELL_LIFEBINDERS_GIFT_H    = 64185,    // the same but for 60%
+    SPELL_PHEROMONES            = 62619,    // protects from conservators grip
+    MOB_HEALTHY_SPORE           = 33215,
+
+    /* ADDS */
+    // 6 waves of adds. 1 of the 3 each min 
+    MOB_DETONATING_LASHER       = 32918,    // recude 2 stacks
+    // spells
+    SPELL_FLAME_LASH            = 62608,
+    SPELL_DETONATE              = 62598,
+    SPELL_DETONATE_H            = 62937, 
+
+    MOB_ANCIENT_CONSERVATOR     = 33203,    // reduce 30 stacks
+    //spells
+    SPELL_CONSERVATORS_GRIP     = 62532,
+    SPELL_NATURES_FURRY         = 62589,
+    SPELL_NATURES_FURRY_H       = 63571,
+
+    /* elemental adds */                    // each one reduces 10 stacks
+    MOB_WATER_SPIRIT            = 33202,
+    // spells
+    SPELL_TIDAL_WAVE            = 62653,
+
+    MOB_STORM_LASHER            = 32919,
+    // spells
+    SPELL_STORMBOLT             = 62649,
+    SPELL_STORMBOLT_H           = 62938,
+    SPELL_LIGHTNING_LASH        = 62648,    // 3 targets
+    SPELL_LIGHTNING_LASH_H      = 62939,    // 5 targets
+
+    MOB_SNAPLASHER              = 32916,
+    // spells
+    SPELL_HARDEND_BARK          = 62663,
+    SPELL_HARDEND_BARK_H        = 64190,
+
+    // nature bomb
+    MOB_NATURE_BOMB             = 34129,
+    SPELL_NATURE_BOMB           = 64587,
+    SPELL_NATURE_BOMB_H         = 64650,
+
+    /* ELDERS */                            // used in phase 1
+    ELDER_BRIGHTLEAF            = 32915,
+    ELDER_IRONBRANCH             = 32913,
+    ELDER_STONEBARK             = 32914,
+
+    // brightleaf spells
+    SPELL_BRIGHTLEAF_FLUX       = 62262,
+    SPELL_SOLAR_FLARE           = 62240,
+    SPELL_SOLAR_FLARE_H         = 62920,
+    SPELL_UNSTABLE_SUN_BEAN     = 62243,
+    SPELL_UNSTABLE_ENERGY       = 62217,
+    SPELL_UNSTABLE_ENERGY_H     = 62922,
+    SPELL_PHOTOSYNTESIS         = 62209,
+
+    // ironbrach spells
+    SPELL_IMPALE                = 62310,
+    SPELL_IMPALE_H              = 62928,
+    SPELL_IRON_ROOTS            = 62438,
+    SPELL_IRON_ROOTS_H          = 62861,
+    MOB_IRON_ROOTS              = 33088,
+    SPELL_THORM_SWARM           = 62285,
+    SPELL_THORM_SWARM_H         = 62931,
+    SPELL_STUN				    = 56,
+
+    // stonebark spells
+    SPELL_FIST_OF_STONE         = 62344,
+    SPELL_BROKEN_BONES          = 62356,
+    SPELL_GROUND_TREMOR         = 62325,
+    SPELL_GROUND_TREMOR_H       = 62932,
+    SPELL_PETRIFIED_BARK        = 62337,
+    SPELL_PETRIFIED_BARK_H      = 62933,
+};
+
+class MANGOS_DLL_DECL AttunedToNatureAura : public Aura
+{
+public:
+    AttunedToNatureAura(const SpellEntry *spell, SpellEffectIndex eff, int32 *bp, Unit *target, Unit *caster) : Aura(spell, eff, bp, target, caster, NULL)
+    {}
+};
+
+// Brightleaf
+struct MANGOS_DLL_DECL boss_elder_brightleafAI : public ScriptedAI
+{
+    boss_elder_brightleafAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 BrightleafFluxTimer;
+    uint32 SolarFlareTimer;
+    uint32 UnstableSunBeanTimer;
+    uint32 UnstabelEnergyTimer;
+    uint32 PhotosyntesisTimer;
+    uint32 PhotosyntesisEndTimer;
+
+    void Reset()
+    {
+        BrightleafFluxTimer     = 5000;
+        SolarFlareTimer         = 10000 + urand(1000, 5000);
+        UnstableSunBeanTimer    = 15000;
+        UnstabelEnergyTimer     = 20000;
+        PhotosyntesisTimer      = 30000;
+        PhotosyntesisEndTimer   = 5000;
+    }
+
+    void Aggro(Unit* pWho)
+    {    
+        DoScriptText(SAY_BRIGHTLEAF_AGGRO, m_creature);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_BRIGHTLEAF_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_BRIGHTLEAF_SLAY2, m_creature);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        DoScriptText(SAY_BRIGHTLEAF_DEATH, m_creature);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(BrightleafFluxTimer < diff)
+        {
+            DoCast(m_creature, SPELL_BRIGHTLEAF_FLUX);
+            BrightleafFluxTimer = 5000;
+        }
+        else BrightleafFluxTimer -= diff;
+
+        if(SolarFlareTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_SOLAR_FLARE : SPELL_SOLAR_FLARE_H);
+            SolarFlareTimer = 10000 + urand(1000, 5000);
+        }
+        else SolarFlareTimer -= diff;
+
+        if(UnstableSunBeanTimer < diff)
+        {
+            DoCast(m_creature, SPELL_UNSTABLE_SUN_BEAN);
+            UnstableSunBeanTimer = urand(15000, 20000);
+        }
+        else UnstableSunBeanTimer -= diff;
+
+        if(UnstabelEnergyTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_UNSTABLE_ENERGY: SPELL_UNSTABLE_ENERGY_H);
+            UnstabelEnergyTimer = urand(17000, 23000);
+        }
+        else UnstabelEnergyTimer -= diff;
+
+        if(PhotosyntesisTimer < diff)
+        {
+            DoCast(m_creature, SPELL_PHOTOSYNTESIS);
+            PhotosyntesisTimer = 30000;
+            PhotosyntesisEndTimer = 5000;
+        }
+        else PhotosyntesisTimer -= diff;
+
+        if(PhotosyntesisEndTimer < diff)
+        {
+            m_creature->RemoveAurasDueToSpell(SPELL_PHOTOSYNTESIS);
+            PhotosyntesisEndTimer = 35000;
+        }
+        else PhotosyntesisEndTimer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_elder_brightleaf(Creature* pCreature)
+{
+    return new boss_elder_brightleafAI(pCreature);
+}
+
+// Ironbranch
+struct MANGOS_DLL_DECL boss_elder_ironbranchAI : public ScriptedAI
+{
+    boss_elder_ironbranchAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 ImpaleTimer;
+    uint32 IronrootsTimer;
+    uint32 ThornSwarmTimer;
+
+    void Reset()
+    {
+        ImpaleTimer         = 10000 + urand (1000, 5000);
+        IronrootsTimer      = 20000 + urand (1000, 7000);
+        ThornSwarmTimer     = 30000;
+    }
+
+    void Aggro(Unit* pWho)
+    {    
+        DoScriptText(SAY_IRONBRANCH_AGGRO, m_creature);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        DoScriptText(SAY_IRONBRANCH_DEATH, m_creature);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_IRONBRANCH_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_IRONBRANCH_SLAY2, m_creature);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(ImpaleTimer < diff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_IMPALE : SPELL_IMPALE_H);
+            ImpaleTimer = 10000 + urand (1000, 5000);
+        }
+        else ImpaleTimer -= diff;
+
+        if(IronrootsTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_IRON_ROOTS : SPELL_IRON_ROOTS_H);
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                m_creature->SummonCreature(MOB_IRON_ROOTS, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000);
+            IronrootsTimer = 20000 + urand (1000, 7000);
+        }
+        else IronrootsTimer -= diff;
+
+        if(ThornSwarmTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_THORM_SWARM : SPELL_THORM_SWARM_H);
+            ThornSwarmTimer = 30000;
+        }
+        else ThornSwarmTimer -= diff;
+
+        DoMeleeAttackIfReady(); 
+    }
+};
+
+CreatureAI* GetAI_boss_elder_ironbranch(Creature* pCreature)
+{
+    return new boss_elder_ironbranchAI(pCreature);
+}
+
+// Stonebark
+struct MANGOS_DLL_DECL boss_elder_stonebarkAI : public ScriptedAI
+{
+    boss_elder_stonebarkAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 FistsOfStoneTimer;
+    uint32 GroundTremorTimer;
+    uint32 PetrifiedBarkTimer;
+
+    void Reset()
+    {
+        FistsOfStoneTimer   = 20000;
+        GroundTremorTimer   = 15000;
+        PetrifiedBarkTimer  = 25000;
+    }
+
+    void Aggro(Unit* pWho)
+    {    
+        DoScriptText(SAY_STONEBARK_AGGRO, m_creature);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        DoScriptText(SAY_STONEBARK_DEATH, m_creature);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_STONEBARK_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_STONEBARK_SLAY2, m_creature);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(FistsOfStoneTimer < diff)
+        {
+            DoCast(m_creature, SPELL_FIST_OF_STONE);
+            FistsOfStoneTimer = 30000;
+        }
+        else FistsOfStoneTimer -= diff;
+
+        if(GroundTremorTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_GROUND_TREMOR : SPELL_GROUND_TREMOR_H);
+            GroundTremorTimer = 15000 + urand (1000, 5000);
+        }
+        else GroundTremorTimer -= diff;
+
+        if(PetrifiedBarkTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_PETRIFIED_BARK : SPELL_PETRIFIED_BARK_H);
+            PetrifiedBarkTimer = 20000 + urand (1000, 5000);
+        }
+        else PetrifiedBarkTimer -= diff;
+
+        DoMeleeAttackIfReady(); 
+    }
+};
+
+CreatureAI* GetAI_boss_elder_stonebark(Creature* pCreature)
+{
+    return new boss_elder_stonebarkAI(pCreature);
+}
+
+// Freya
+struct MANGOS_DLL_DECL boss_freyaAI : public ScriptedAI
+{
+    boss_freyaAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Regular = pCreature->GetMap()->IsRegularDifficulty();
+        if(pCreature->isAlive())
+        {
+            sp = (SpellEntry *)GetSpellStore()->LookupEntry(SPELL_ATTUNED_TO_NATURE);
+            bp = 8;
+            if(!pCreature->HasAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0))
+                pCreature->AddAura(new AttunedToNatureAura(sp, EFFECT_INDEX_0, &bp, pCreature, pCreature));
+            pCreature->GetAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0)->SetStackAmount(150);
+        }
+        Reset();
+    }
+
+    uint32 SummonTimer;
+    uint32 WaveNumber;
+    uint32 WaveType;
+    uint32 WaveTypeInc;
+    uint32 SunbeamTimer;
+    uint32 EnrageTimer;
+
+    bool Regular;
+    bool isHardMode;
+    ScriptedInstance *pInstance;
+    SpellEntry const *sp;
+    int32 bp;
+
+    uint32 NatureBombTimer;
+    uint32 LifebindersGiftTimer;
+
+    Creature* Freya;
+
+    bool isOutro;
+    uint32 OutroTimer;
+    uint32 Step;
+
+    uint32 UnstableEnergyTimer;
+    uint32 StrenghtenIronRootsTimer;
+    uint32 GroundTremorTimer;
+
+    uint32 AuraCheckTimer;
+
+    bool isBrightleafAlive;
+    bool isIronbranchAlive;
+    bool isStonebarkAlive;
+
+    void Reset()
+    {
+        SummonTimer = 15000;
+        WaveNumber = 0;
+        WaveType = irand(0,2);
+        WaveTypeInc = irand(1,2);
+        SunbeamTimer = rand()%10000;
+        EnrageTimer = 600000; //10 minutes
+        isHardMode = false;
+        LifebindersGiftTimer = 30000;
+        UnstableEnergyTimer = 25000;
+        StrenghtenIronRootsTimer = 25000 + urand(1000, 5000);
+        GroundTremorTimer = 20000;
+
+        NatureBombTimer = 7000;
+
+        AuraCheckTimer = 5000;
+
+        OutroTimer = 10000;
+        Step = 1;
+
+        isOutro = false;
+
+        if(m_creature->isAlive())
+        {
+            if(!m_creature->HasAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0))
+                m_creature->AddAura(new AttunedToNatureAura(sp, EFFECT_INDEX_0, &bp, m_creature, m_creature));
+            m_creature->GetAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0)->SetStackAmount(150);
+        }
+
+        if(pInstance) pInstance->SetData(TYPE_FREYA, NOT_STARTED);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(!m_creature->HasAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0))
+            m_creature->AddAura(new AttunedToNatureAura(sp, EFFECT_INDEX_0, &bp, m_creature, m_creature));
+        m_creature->GetAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0)->SetStackAmount(150);
+
+        DoCast(m_creature, Regular ? SPELL_TOUCH_OF_EONAR : SPELL_TOUCH_OF_EONAR_H);
+
+        if(pInstance) 
+        {
+            pInstance->SetData(TYPE_FREYA, IN_PROGRESS);
+
+            // check brightleaf
+            if (Creature* pBrightleaf = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_BRIGHTLEAF))))
+            {
+                if (pBrightleaf->isAlive())
+                {
+                    pBrightleaf->CastSpell(pBrightleaf, SPELL_DRAINED_OF_POWER, false);
+                    isBrightleafAlive = true;
+                }
+                else
+                    isBrightleafAlive = false;
+            }
+
+            // check ironbranch
+            if (Creature* pIronbranch = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_IRONBRACH))))
+            {
+                if (pIronbranch->isAlive())
+                {
+                    pIronbranch->CastSpell(pIronbranch, SPELL_DRAINED_OF_POWER, false);
+                    isIronbranchAlive = true;
+                }
+                else
+                    isIronbranchAlive = false;
+            }
+
+            // check stonebark
+            if (Creature* pStonebark = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_STONEBARK))))
+            {
+                if (pStonebark->isAlive())
+                {
+                    pStonebark->CastSpell(pStonebark, SPELL_DRAINED_OF_POWER, false);
+                    isStonebarkAlive = true;
+                }
+                else
+                    isStonebarkAlive = false;
+            }
+        }
+
+
+        isHardMode = checkHardMode();
+
+        if(!isHardMode)
+            DoScriptText(SAY_AGGRO, m_creature);
+        else
+            DoScriptText(SAY_AGGRO_HARD, m_creature);
+    }
+
+    void DoOutro()
+    {
+        if(pInstance) 
+        {
+            pInstance->SetData(TYPE_FREYA, DONE);
+            if(isHardMode)
+                pInstance->SetData(TYPE_FREYA_HARD, DONE);
+        }
+
+        m_creature->ForcedDespawn();
+    }
+
+    // for debug only
+    void JustDied(Unit* pKiller)
+    {
+       if(pInstance) 
+        {
+            pInstance->SetData(TYPE_FREYA, DONE);
+            if(isHardMode)
+                pInstance->SetData(TYPE_FREYA_HARD, DONE);
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > m_creature->GetHealth())
+        {
+            uiDamage = 0;
+            isOutro = true;
+        }
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+
+    void SummonLashers()
+    {
+        DoScriptText(SAY_SUMMON3, m_creature);
+        int i;
+        float x,y;
+        for(i=0; i<10; ++i)
+        {
+            x = (rand_norm() * 30.0f) - 15.0f;
+            y = (rand_norm() * 30.0f) - 15.0f;
+            Creature *lasher = DoSpawnCreature(MOB_DETONATING_LASHER, x, y, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 2000);
+            Unit *target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+            if(lasher && target)
+                lasher->AddThreat(target, 1.0f);
+        }
+    }
+
+    void SummonConservator()
+    {
+        DoScriptText(SAY_SUMMON1, m_creature);
+        float x = (rand_norm() * 30.0f) - 15.0f;
+        float y = (rand_norm() * 30.0f) - 15.0f;
+        Creature *add = DoSpawnCreature(MOB_ANCIENT_CONSERVATOR, x, y, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 2000);
+        Unit *target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+        if(add && target)
+            add->AddThreat(target, 1.0f);
+    }
+
+    void SummonElementals()
+    {
+        DoScriptText(SAY_SUMMON2, m_creature);
+        Creature *add;
+        Unit *target;
+        add = DoSpawnCreature(MOB_WATER_SPIRIT, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 2000);
+        target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+        if(add && target)
+            add->AddThreat(target, 1.0f);
+
+        add = DoSpawnCreature(MOB_STORM_LASHER, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 2000);
+        target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+        if(add && target)
+            add->AddThreat(target, 1.0f);
+
+        add = DoSpawnCreature(MOB_SNAPLASHER, 0, 0, 0, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 2000);
+        target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+        if(add && target)
+            add->AddThreat(target, 1.0f);
+    }
+
+    void SummonedCreatureDespawn(Creature* mob)
+    {
+        if(!m_creature->HasAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0)) return;
+
+        switch(mob->GetEntry())
+        {
+        case MOB_DETONATING_LASHER:
+            if(m_creature->GetAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0)->modStackAmount(-2))
+                m_creature->RemoveAurasDueToSpell(SPELL_ATTUNED_TO_NATURE);
+            break;
+        case MOB_ANCIENT_CONSERVATOR:
+            if(m_creature->GetAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0)->modStackAmount(-25))
+                m_creature->RemoveAurasDueToSpell(SPELL_ATTUNED_TO_NATURE);
+            break;
+        case MOB_SNAPLASHER:
+        case MOB_STORM_LASHER:
+        case MOB_WATER_SPIRIT:
+            if(m_creature->GetAura(SPELL_ATTUNED_TO_NATURE, EFFECT_INDEX_0)->modStackAmount(-10))
+                m_creature->RemoveAurasDueToSpell(SPELL_ATTUNED_TO_NATURE);
+
+        }
+    }
+
+    bool checkHardMode()
+    {
+        if(isBrightleafAlive && isIronbranchAlive && isStonebarkAlive)
+            return true;
+        return false;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!isOutro)
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+
+            // Hardmode
+            if(isBrightleafAlive)
+            {
+                if(AuraCheckTimer < diff)
+                {
+                    DoCast(m_creature, SPELL_BRIGHTLEAFS_ESSENCE);
+                    AuraCheckTimer = 5000;
+                }
+                else AuraCheckTimer -= diff;
+
+                if(UnstableEnergyTimer < diff)
+                {
+                    DoCast(m_creature, Regular ? SPELL_UNSTABLE_ENERGY_FREYA : SPELL_UNSTABLE_ENERGY_FREYA_H);
+                    UnstableEnergyTimer = 25000;
+                }
+                else UnstableEnergyTimer -= diff;
+            }
+
+            if(isIronbranchAlive)
+            {
+                if(AuraCheckTimer < diff)
+                {
+                    DoCast(m_creature, SPELL_IRONBRACHS_ESSENCE);
+                    AuraCheckTimer = 5000;
+                }
+                else AuraCheckTimer -= diff;
+
+                if(StrenghtenIronRootsTimer < diff)
+                {
+                    if( Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                        m_creature->SummonCreature(MOB_STRENGHTEN_IRON_ROOTS, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000);
+                    StrenghtenIronRootsTimer = 25000 + urand(1000, 5000);
+                }
+                else StrenghtenIronRootsTimer -= diff;
+
+            }
+
+            if(isStonebarkAlive)
+            {
+                if(AuraCheckTimer < diff)
+                {
+                    DoCast(m_creature, SPELL_STONEBARKS_ESSENCE);
+                    AuraCheckTimer = 5000;
+                }
+                else AuraCheckTimer -= diff;
+
+                if(GroundTremorTimer < diff)
+                {
+                    DoCast(m_creature, Regular ? SPELL_GROUND_TREMOR_FREYA : SPELL_GROUND_TREMOR_FREYA_H);
+                    GroundTremorTimer = 20000;
+                }
+                else GroundTremorTimer -= diff;
+            }
+
+            //Phase 1, waves of adds
+            if(WaveNumber < 6)
+            {
+                if(SummonTimer < diff)
+                {
+                    switch(WaveType)
+                    {
+                    case 0: SummonLashers(); break;
+                    case 1: SummonConservator(); break;
+                    case 2: SummonElementals(); break;
+                    }
+                    WaveType = (WaveType + WaveTypeInc) % 3;
+                    ++WaveNumber;
+                    SummonTimer = 60000;
+                }
+                else SummonTimer -= diff;
+            }
+            // Phase 2
+            else
+            {
+                // nature bomb
+                if(NatureBombTimer < diff)
+                {
+                    for(uint8 i = 0; i < 7; i++)
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            m_creature->SummonCreature(MOB_NATURE_BOMB, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 6000);
+                    }
+                    NatureBombTimer = 7000;
+                }
+                else NatureBombTimer -= diff;
+            }
+
+            //All phases
+            if(SunbeamTimer < diff)
+            {
+                if( Unit *target = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                    DoCast(target, Regular ? SPELL_SUNBEAM : SPELL_SUNBEAM_H);
+                SunbeamTimer = 6000 + rand()%10000;
+            }
+            else SunbeamTimer -= diff;
+
+            if(LifebindersGiftTimer < diff)
+            {
+                if( Unit *pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                    m_creature->SummonCreature(MOB_EONARS_GIFT, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000);
+                LifebindersGiftTimer = 30000;
+            }
+            else LifebindersGiftTimer -= diff;
+
+            if(EnrageTimer < diff)
+            {
+                DoScriptText(SAY_BERSERK, m_creature);
+                DoCast(m_creature, SPELL_BERSERK);
+                EnrageTimer = 30000;
+            }
+            else EnrageTimer -= diff;
+
+            // Hp check
+            //if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= 1)
+                //isOutro = true;
+
+            DoMeleeAttackIfReady();
+        }
+
+        // outro
+        if(isOutro)
+        {
+            switch(Step)
+            {
+            case 1:
+                Freya = m_creature;
+                Freya->setFaction(35);
+                Freya->RemoveAllAuras();
+                Freya->DeleteThreatList();
+                Freya->CombatStop(true);
+                Freya->InterruptNonMeleeSpells(false);
+                Freya->SetHealth(Freya->GetMaxHealth());
+                Freya->GetMotionMaster()->MovePoint(0, 2359.40f, -52.39f, 425.64f);
+                Freya->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                ++Step;
+                OutroTimer = 7000;
+                break;
+            case 3:
+                Freya->SetOrientation(4.99f);
+                DoScriptText(SAY_DEATH, Freya);
+                ++Step;
+                OutroTimer = 10000;
+                break;
+            case 5:
+                DoOutro();
+                ++Step;
+                OutroTimer = 10000;
+                break;
+            }
+        }
+        else return;
+
+        if (OutroTimer <= diff)
+        {
+            ++Step;
+            OutroTimer = 330000;
+        } OutroTimer -= diff;
+    }
+};
+
+CreatureAI* GetAI_boss_freya(Creature* pCreature)
+{
+    return new boss_freyaAI(pCreature);
+}
+
+// Nature bomb
+struct MANGOS_DLL_DECL mob_nature_bombAI : public ScriptedAI
+{
+    mob_nature_bombAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        SetCombatMovement(false);
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 ExplodeTimer;
+    uint32 dieTimer;
+
+    void Reset()
+    {
+        ExplodeTimer = 5000;
+        dieTimer = 5500;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(ExplodeTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_NATURE_BOMB : SPELL_NATURE_BOMB_H);
+        }
+        else ExplodeTimer -= diff;
+
+        if(dieTimer < diff)
+        {
+            m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+        else dieTimer -= diff;
+    }
+};
+
+CreatureAI* GetAI_mob_nature_bomb(Creature* pCreature)
+{
+    return new mob_nature_bombAI(pCreature);
+}
+
+// Iron roots
+struct MANGOS_DLL_DECL mob_iron_rootsAI : public ScriptedAI
+{
+    mob_iron_rootsAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        SetCombatMovement(false);
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 rootTimer;
+
+    void Reset()
+    {
+        rootTimer = 1000;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(rootTimer < diff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+            {
+                DoCast(pTarget, SPELL_STUN);
+                m_creature->DealDamage(pTarget, m_bIsRegularMode ? urand(6013, 6987) : urand(7863, 9137), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NATURE, NULL, false);
+            }
+            rootTimer = 1000;
+        }
+        else rootTimer -= diff;
+    }
+};
+
+CreatureAI* GetAI_mob_iron_roots(Creature* pCreature)
+{
+    return new mob_iron_rootsAI(pCreature);
+}
+
+void AddSC_boss_freya()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_freya";
+    newscript->GetAI = &GetAI_boss_freya;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_elder_brightleaf";
+    newscript->GetAI = &GetAI_boss_elder_brightleaf;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_elder_ironbranch";
+    newscript->GetAI = &GetAI_boss_elder_ironbranch;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_elder_stonebark";
+    newscript->GetAI = &GetAI_boss_elder_stonebark;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_nature_bomb";
+    newscript->GetAI = &GetAI_mob_nature_bomb;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_iron_roots";
+    newscript->GetAI = &GetAI_mob_iron_roots;
+    newscript->RegisterSelf();
+
+}
diff --git a/scripts/northrend/ulduar/ulduar/boss_hodir.cpp b/scripts/northrend/ulduar/ulduar/boss_hodir.cpp
new file mode 100644
index 0000000..32d1454
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_hodir.cpp
@@ -0,0 +1,892 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_hodir
+SD%Complete: 60%
+SDComment:Auras needs core fix, implement flash freeze and icicles, snowdrift
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    SPELL_ENRAGE            = 26662,
+
+    SPELL_FROZEN_BLOWS      = 62478,
+    SPELL_FROZEN_BLOWS_H    = 63512,
+    SPELL_FREEZE            = 62469,
+    SPELL_BITTER_COLD_AURA  = 48094,//62039  // or maybe 62038? -> broken needs more core support -> changed to Intense cold from Keristrasza
+    SPELL_ICICLE            = 62460,
+    SPELL_ICE_SHARDS        = 65370,
+    SPELL_SNOWDRIFT         = 62463,
+    SPELL_FLASH_FREEZE      = 61968,
+    SPELL_ROOT              = 43956,
+    SPELL_ROOT_AURA         = 40885,
+
+    SPELL_FROZEN_BLOWS_HIT  = 62867,
+    SPELL_FROZEN_BLOWS_AURA = 64544,
+    SPELL_FROZEN_BLOWS_HIT_H    = 63511,
+    SPELL_FROZEN_BLOWS_AURA_H   = 64545,
+
+    NPC_SNOWDRIFT           = 33174,
+    GO_SNOWDRIFT            = 194173,
+    NPC_FLASH_FREEZE        = 32938,        //32926
+
+    SAY_AGGRO           = -1603085,
+    SAY_DEATH           = -1603084,
+    SAY_SLAY01          = -1603083,
+    SAY_SLAY02          = -1603082,
+    SAY_FLASH_FREEZE    = -1603081,
+    SAY_FROZEN_BLOWS    = -1603080,
+    SAY_BERSERK         = -1603087,
+    SOUND_FROZEN_BLOWS  = 15556,
+
+    // helper npcs
+    // druid
+    SPELL_WRATH         = 62793,
+    SPELL_STARLIGHT     = 62807, // friendly
+
+    // shaman
+    SPELL_LAVA_BURST    = 61924,
+    SPELL_STORM_CLOUD   = 65123, // friendly
+    SPELL_STORM_CLOUD_H = 65133,
+    SPELL_STORM_POWER   = 65134, // friendly
+
+    // mage
+    SPELL_FIREBALL      = 61909,
+    SPELL_CONJURE_TOASTY_FIRE   = 62823, // friendly
+    SPELL_MELT_ICE      = 64528,
+    SPELL_SIGNED        = 65280,
+
+    // priest
+    SPELL_SMITE         = 61923,
+    SPELL_GREAT_HEAL    = 62809,    //friendly
+    SPELL_DISPEL_MAGIC  = 63499,    //friendly
+
+};
+
+struct MANGOS_DLL_DECL mob_snowdriftAI : public ScriptedAI
+{
+    mob_snowdriftAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    uint64 m_uiVictimGUID;
+
+    void Reset()
+    {
+        m_uiVictimGUID = 0;
+        m_creature->SetVisibility(VISIBILITY_OFF);
+    }
+
+    void SetVictim(Unit* pVictim)
+    {
+        if (pVictim)
+        {
+            m_uiVictimGUID = pVictim->GetGUID();
+            pVictim->CastSpell(pVictim, SPELL_SNOWDRIFT, true);
+        }
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32 &uiDamage)
+    {
+        if (uiDamage > m_creature->GetHealth())
+        {
+            if (m_uiVictimGUID)
+            {
+                if (Unit* pVictim = Unit::GetUnit((*m_creature), m_uiVictimGUID))
+                    pVictim->RemoveAurasDueToSpell(SPELL_SNOWDRIFT);
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff) {}
+};
+
+struct MANGOS_DLL_DECL mob_flashFreezeAI : public ScriptedAI
+{
+    mob_flashFreezeAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    uint64 m_uiVictimGUID;
+
+    void Reset()
+    {
+        m_uiVictimGUID = 0;
+        m_creature->SetVisibility(VISIBILITY_OFF);
+    }
+
+    void SetVictim(Unit* pVictim)
+    {
+        if (pVictim)
+        {
+            m_uiVictimGUID = pVictim->GetGUID();
+            pVictim->CastSpell(pVictim, SPELL_ROOT_AURA, true);
+        }
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32 &uiDamage)
+    {
+        if (uiDamage > m_creature->GetHealth())
+        {
+            if (m_uiVictimGUID)
+            {
+                if (Unit* pVictim = Unit::GetUnit((*m_creature), m_uiVictimGUID))
+                    pVictim->RemoveAurasDueToSpell(SPELL_ROOT_AURA);
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff) {}
+};
+
+struct MANGOS_DLL_DECL boss_hodirAI : public ScriptedAI
+{
+    boss_hodirAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Regular = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool Regular;
+    ScriptedInstance *pInstance;
+
+    // hard mode timer
+    uint64 SpeedKillTimer;
+
+    uint64 EnrageTimer;
+    uint64 FlashFreezeTimer;
+    uint64 FrozenBlowsTimer;
+    uint32 FlashFreezeVisualTimer;
+    uint64 FreezeTimer;
+    uint32 IcicleTimer;
+    uint8 IcicleCount;
+    uint32 AuraCheckTimer;
+
+    Creature* Hodir;
+
+    bool isOutro;
+    uint32 OutroTimer;
+    uint32 Step;
+    std::vector<Unit*> frozenTargets;
+    std::vector<Unit*> snowdriftTargets;
+    std::vector<Unit*> flashFreezeTargets;
+
+
+    void Reset()
+    {
+        SpeedKillTimer = 180000;
+
+        EnrageTimer = 480000;
+        FlashFreezeTimer = 70000;
+        FrozenBlowsTimer = 60000;
+        FlashFreezeVisualTimer = 60000;
+        FreezeTimer = urand(15000, 20000);
+        IcicleTimer = 10000;
+        IcicleCount = 0;
+        frozenTargets.clear();
+        snowdriftTargets.clear();
+        flashFreezeTargets.clear();
+
+        AuraCheckTimer = 10000;
+        OutroTimer = 10000;
+        Step = 1;
+
+        isOutro = false;
+
+        if(pInstance) pInstance->SetData(TYPE_HODIR, NOT_STARTED);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(pInstance) pInstance->SetData(TYPE_HODIR, IN_PROGRESS);
+
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        m_creature->CastSpell(who, SPELL_BITTER_COLD_AURA, true);
+    }
+
+    void DoOutro()
+    {
+        if(pInstance) 
+        {
+            if(SpeedKillTimer > 0)
+            {
+                pInstance->SetData(TYPE_HODIR_HARD, DONE);
+                pInstance->SetData(TYPE_HODIR, DONE);
+            }
+            else
+                pInstance->SetData(TYPE_HODIR, DONE);
+        }
+        m_creature->ForcedDespawn();
+    }
+
+    // for debug only
+    void JustDied(Unit* pKiller)
+    {
+       if(pInstance) 
+        {
+            pInstance->SetData(TYPE_HODIR, DONE);
+            if(SpeedKillTimer > 0)
+                pInstance->SetData(TYPE_HODIR_HARD, DONE);
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > m_creature->GetHealth())
+        {
+            uiDamage = 0;
+            isOutro = true;
+        }
+    }
+
+    void KilledUnit(Unit *who)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY01, m_creature);
+        else
+            DoScriptText(SAY_SLAY02, m_creature);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!isOutro)
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+
+            // hard mode check
+            if(pInstance && pInstance->GetData(TYPE_HODIR) == IN_PROGRESS)
+                SpeedKillTimer -= diff;
+
+            // Flash freeze visual
+            if(FlashFreezeVisualTimer < diff)
+            {
+                DoScriptText(SAY_FLASH_FREEZE, m_creature);
+                DoCast(m_creature->getVictim(), SPELL_FLASH_FREEZE);
+                FlashFreezeVisualTimer = 40000;
+                FlashFreezeTimer = 5000;
+            }
+            else FlashFreezeVisualTimer -= diff;
+
+            // flash freeze -> workaround
+            if(FlashFreezeTimer < diff)
+            {    
+                /*
+                // kill targets which are frozen
+                ThreatList const& tList = m_creature->getThreatManager().getThreatList();
+                for (ThreatList::const_iterator iter = tList.begin();iter != tList.end(); ++iter)
+                {
+                    Unit* pUnit = Unit::GetUnit((*m_creature), (*iter)->getUnitGuid());
+                    if (pUnit && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                    {
+                        if (pUnit->HasAura(SPELL_FREEZE))
+                        {
+                            for(std::vector<Unit*>::iterator itr = frozenTargets.begin(); itr!= frozenTargets.end(); ++itr)
+                            {
+                                if (*itr)
+                                {
+                                    if (pUnit->GetDistance2d(*itr) <= 7 && (*itr)->HasAura(SPELL_FREEZE))
+                                        m_creature->DealDamage(pUnit, pUnit->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_FROST, NULL, false);
+                                }
+                            }
+                        }
+                    }
+                }
+
+                // apply imune to snowdrifted targets
+                for (ThreatList::const_iterator iter = tList.begin();iter != tList.end(); ++iter)
+                {
+                    Unit* pUnit = Unit::GetUnit((*m_creature), (*iter)->getUnitGuid());
+                    if (pUnit && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                    {
+                        if (pUnit->HasAura(SPELL_SNOWDRIFT))
+                        {
+                            for(std::vector<Unit*>::iterator itr = frozenTargets.begin(); itr!= frozenTargets.end(); ++itr)
+                            {
+                                if (*itr)
+                                {
+                                    if (pUnit->GetDistance2d(*itr) <= 7 && (*itr)->HasAura(SPELL_SNOWDRIFT))
+                                        pUnit->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, true);
+                                }
+                            }
+                        }
+                    }
+                }
+
+                // cast flash freeze
+                for (ThreatList::const_iterator iter = tList.begin();iter != tList.end(); ++iter)
+                {
+                    Unit* pUnit = Unit::GetUnit((*m_creature), (*iter)->getUnitGuid());
+                    if (pUnit && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                    {
+                        if (!pUnit->HasAura(SPELL_SNOWDRIFT) && !pUnit->HasAura(SPELL_FREEZE))
+                        {
+                            for(std::vector<Unit*>::iterator itr = flashFreezeTargets.begin(); itr!= flashFreezeTargets.end(); ++itr)
+                            {
+                                if (*itr)
+                                {
+                                    float fPosX, fPosY, fPosZ;
+                                    pUnit->GetPosition(fPosX, fPosY, fPosZ);
+
+                                    if (Creature* pFlashFreeze = m_creature->SummonCreature(NPC_FLASH_FREEZE, fPosX, fPosY, fPosZ, 0, TEMPSUMMON_TIMED_DESPAWN, 20000))
+                                    {
+                                        pFlashFreeze->AddThreat(pUnit);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+                FlashFreezeTimer = 40000;
+                frozenTargets.clear();
+                snowdriftTargets.clear();
+                flashFreezeTargets.clear();
+                */
+            }
+            else FlashFreezeTimer -= diff;
+
+            // icicles
+            if(IcicleTimer < diff)
+            {
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    DoCast(pTarget, SPELL_ICICLE);
+                    DoCast(pTarget, SPELL_ICE_SHARDS); // not working
+                    //DoCast(pTarget, SPELL_SNOWDRIFT);   //not working -> workaround
+                    m_creature->SummonCreature(NPC_SNOWDRIFT, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 15000);
+
+                    // two icicles at 5 secs -> blizzlike
+                    if(IcicleCount < 1)
+                    {
+                        IcicleTimer = 3000;
+                        IcicleCount ++;
+                    }
+                    else
+                    {
+                        IcicleTimer = 10000;
+                        IcicleCount = 0;
+                    }
+                }
+            }
+            else IcicleTimer -= diff;
+
+            // frozen blows
+            if(FrozenBlowsTimer < diff)
+            {
+                //DoPlaySoundToSet(m_creature, SOUND_FROZEN_BLOWS);
+                DoScriptText(SAY_FROZEN_BLOWS, m_creature);
+                // visual
+                DoCast(m_creature, Regular ? SPELL_FROZEN_BLOWS : SPELL_FROZEN_BLOWS_H);
+                // hit
+                DoCast(m_creature, Regular ? SPELL_FROZEN_BLOWS_HIT : SPELL_FROZEN_BLOWS_HIT_H);
+                // aura
+                m_creature->CastSpell(m_creature->getVictim(), Regular ? SPELL_FROZEN_BLOWS_AURA : SPELL_FROZEN_BLOWS_AURA_H, true);
+                FrozenBlowsTimer = 60000;
+            }
+            else FrozenBlowsTimer -= diff;
+
+            // freeze
+            if(FreezeTimer < diff)
+            {
+                Unit *target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+                if(target) 
+                {
+                    DoCast(target, SPELL_FREEZE);
+                    frozenTargets.push_back(target);
+                }
+                FreezeTimer = urand(5000, 10000);
+            }
+            else FreezeTimer -= diff;
+
+            // enrage
+            if(EnrageTimer < diff)
+            {
+                DoScriptText(SAY_BERSERK, m_creature);
+                DoCast(m_creature, SPELL_ENRAGE);
+                EnrageTimer = 30000;
+            }
+            else EnrageTimer -= diff;
+
+            // Hp check
+            //if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= 1)
+                //isOutro = true;
+
+            DoMeleeAttackIfReady();
+
+        }
+        // outro
+        if(isOutro)
+        {
+            switch(Step)
+            {
+            case 1:
+                Hodir = m_creature;
+                Hodir->setFaction(35);
+                Hodir->RemoveAllAuras();
+                Hodir->DeleteThreatList();
+                Hodir->CombatStop(true);
+                Hodir->InterruptNonMeleeSpells(false);
+                Hodir->SetHealth(Hodir->GetMaxHealth());
+                Hodir->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                Hodir->GetMotionMaster()->MovePoint(0, 1984.64f, -206.37f, 432.68f);
+                ++Step;
+                OutroTimer = 10000;
+                break;
+            case 3:
+                Hodir->SetOrientation(4.99f);
+                DoScriptText(SAY_DEATH, Hodir);
+                ++Step;
+                OutroTimer = 5000;
+                break;
+            case 5:
+                DoOutro();
+                ++Step;
+                OutroTimer = 10000;
+                break;
+            }
+        }
+        else return;
+
+        if (OutroTimer <= diff)
+        {
+            ++Step;
+            OutroTimer = 330000;
+        } OutroTimer -= diff;
+
+
+    }
+};
+
+struct MANGOS_DLL_DECL npc_hodir_druidAI : public ScriptedAI
+{
+    npc_hodir_druidAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    uint32 spellTimer;
+    std::list<uint64> FriendlyList;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+        FriendlyList.clear();
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        // friendly list
+        if (!m_creature->IsHostileTo(pWho) && !ListContains(FriendlyList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 100, true))
+            FriendlyList.push_back(pWho->GetGUID());
+    }
+
+    uint64 SelectRandomPlayer()
+    {
+        //This should not appear!
+        if (FriendlyList.empty()){
+            spellTimer = 10000;
+            return NULL;
+        }
+
+        std::list<uint64>::iterator iter = FriendlyList.begin();
+        advance(iter, urand(0, FriendlyList.size()-1));
+
+        return *iter;
+    }
+
+    bool ListContains(std::list<uint64> &plist, uint64 element)
+    {
+        if (plist.empty())
+            return false;
+
+        std::list<uint64>::iterator i;
+        for (i = plist.begin(); i!=plist.end(); ++i)
+        {
+            if ((*i) == element)
+                return true;
+        }
+        return false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 1))
+            {
+            case 0:
+                if(Creature *pHodir = GetClosestCreatureWithEntry(m_creature, NPC_HODIR, 50.0f))
+                    DoCast(pHodir, SPELL_WRATH);
+                break;
+            case 1:
+                Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer()));
+                if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 40)
+                    DoCast(pTemp, SPELL_STARLIGHT);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_npc_hodir_druid(Creature* pCreature)
+{
+    return new npc_hodir_druidAI(pCreature);
+}
+
+struct MANGOS_DLL_DECL npc_hodir_shamanAI : public ScriptedAI
+{
+    npc_hodir_shamanAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *pInstance;
+
+    uint32 spellTimer;
+    std::list<uint64> FriendlyList;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+        FriendlyList.clear();
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        // friendly list
+        if (!m_creature->IsHostileTo(pWho) && !ListContains(FriendlyList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 100, true))
+            FriendlyList.push_back(pWho->GetGUID());
+    }
+
+    uint64 SelectRandomPlayer()
+    {
+        //This should not appear!
+        if (FriendlyList.empty()){
+            spellTimer = 10000;
+            return NULL;
+        }
+
+        std::list<uint64>::iterator iter = FriendlyList.begin();
+        advance(iter, urand(0, FriendlyList.size()-1));
+
+        return *iter;
+    }
+
+    bool ListContains(std::list<uint64> &plist, uint64 element)
+    {
+        if (plist.empty())
+            return false;
+
+        std::list<uint64>::iterator i;
+        for (i = plist.begin(); i!=plist.end(); ++i)
+        {
+            if ((*i) == element)
+                return true;
+        }
+        return false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 1))
+            {
+            case 0:
+                if(Creature *pHodir = GetClosestCreatureWithEntry(m_creature, NPC_HODIR, 50.0f))
+                    DoCast(pHodir, SPELL_LAVA_BURST);
+                break;
+            case 1:
+                Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer()));
+                if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 40)
+                    DoCast(pTemp, m_bIsRegularMode ? SPELL_STORM_CLOUD : SPELL_STORM_CLOUD_H);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_npc_hodir_shaman(Creature* pCreature)
+{
+    return new npc_hodir_shamanAI(pCreature);
+}
+
+struct MANGOS_DLL_DECL npc_hodir_mageAI : public ScriptedAI
+{
+    npc_hodir_mageAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    uint32 spellTimer;
+    std::list<uint64> FriendlyList;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+        FriendlyList.clear();
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        // friendly list
+        if (!m_creature->IsHostileTo(pWho) && !ListContains(FriendlyList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 100, true))
+            FriendlyList.push_back(pWho->GetGUID());
+    }
+
+    uint64 SelectRandomPlayer()
+    {
+        //This should not appear!
+        if (FriendlyList.empty()){
+            spellTimer = 10000;
+            return NULL;
+        }
+
+        std::list<uint64>::iterator iter = FriendlyList.begin();
+        advance(iter, urand(0, FriendlyList.size()-1));
+
+        return *iter;
+    }
+
+    bool ListContains(std::list<uint64> &plist, uint64 element)
+    {
+        if (plist.empty())
+            return false;
+
+        std::list<uint64>::iterator i;
+        for (i = plist.begin(); i!=plist.end(); ++i)
+        {
+            if ((*i) == element)
+                return true;
+        }
+        return false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 3))
+            {
+            case 0:
+                if(Creature *pHodir = GetClosestCreatureWithEntry(m_creature, NPC_HODIR, 50.0f))
+                    DoCast(pHodir, SPELL_FIREBALL);
+                break;
+            case 1:
+                if(Creature *pHodir = GetClosestCreatureWithEntry(m_creature, NPC_HODIR, 50.0f))
+                    DoCast(pHodir, SPELL_SIGNED);
+                break;
+            case 2:
+                if(Creature *pTemp = GetClosestCreatureWithEntry(m_creature, NPC_FLASH_FREEZE, 50.0f))
+                    DoCast(pTemp, SPELL_MELT_ICE);
+                break;
+            case 3:
+                Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer()));
+                if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 40)
+                    DoCast(pTemp, SPELL_CONJURE_TOASTY_FIRE);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_npc_hodir_mage(Creature* pCreature)
+{
+    return new npc_hodir_mageAI(pCreature);
+}
+
+struct MANGOS_DLL_DECL npc_hodir_priestAI : public ScriptedAI
+{
+    npc_hodir_priestAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    uint32 spellTimer;
+    std::list<uint64> FriendlyList;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+        FriendlyList.clear();
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        // friendly list
+        if (!m_creature->IsHostileTo(pWho) && !ListContains(FriendlyList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 100, true))
+            FriendlyList.push_back(pWho->GetGUID());
+    }
+
+    uint64 SelectRandomPlayer()
+    {
+        //This should not appear!
+        if (FriendlyList.empty()){
+            spellTimer = 10000;
+            return NULL;
+        }
+
+        std::list<uint64>::iterator iter = FriendlyList.begin();
+        advance(iter, urand(0, FriendlyList.size()-1));
+
+        return *iter;
+    }
+
+    bool ListContains(std::list<uint64> &plist, uint64 element)
+    {
+        if (plist.empty())
+            return false;
+
+        std::list<uint64>::iterator i;
+        for (i = plist.begin(); i!=plist.end(); ++i)
+        {
+            if ((*i) == element)
+                return true;
+        }
+        return false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer()));
+
+            switch(urand(0, 2))
+            {
+            case 0:
+                if(Creature *pHodir = GetClosestCreatureWithEntry(m_creature, NPC_HODIR, 50.0f))
+                    DoCast(pHodir, SPELL_SMITE);
+                break;
+            case 1:
+                if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 40)
+                    DoCast(pTemp, SPELL_GREAT_HEAL);
+                break;
+            case 2:
+                if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 40 && pTemp->HasAura(SPELL_FREEZE, EFFECT_INDEX_0))
+                    DoCast(pTemp, SPELL_DISPEL_MAGIC);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_npc_hodir_priest(Creature* pCreature)
+{
+    return new npc_hodir_priestAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_hodir(Creature* pCreature)
+{
+    return new boss_hodirAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_snowdrift(Creature* pCreature)
+{
+    return new mob_snowdriftAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_flashFreeze(Creature* pCreature)
+{
+    return new mob_flashFreezeAI(pCreature);
+}
+
+void AddSC_boss_hodir()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_hodir";
+    newscript->GetAI = &GetAI_boss_hodir;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_snowdrift";
+    newscript->GetAI = &GetAI_mob_snowdrift;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_flashFreeze";
+    newscript->GetAI = &GetAI_mob_flashFreeze;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_hodir_priest";
+    newscript->GetAI = &GetAI_npc_hodir_priest;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_hodir_mage";
+    newscript->GetAI = &GetAI_npc_hodir_mage;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_hodir_druid";
+    newscript->GetAI = &GetAI_npc_hodir_druid;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_hodir_shaman";
+    newscript->GetAI = &GetAI_npc_hodir_shaman;
+    newscript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_ignis.cpp b/scripts/northrend/ulduar/ulduar/boss_ignis.cpp
new file mode 100644
index 0000000..01f1a82
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_ignis.cpp
@@ -0,0 +1,520 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_ignis
+SD%Complete: 85%
+SDComment: slag pot damage missing. missing bringing adds to water part
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    //yells
+    SAY_AGGRO       = -1603010,
+    SAY_SCORCH1     = -1603011,
+    SAY_SCORCH2     = -1603012,
+    SAY_SLAGPOT     = -1603013,
+    SAY_FLAMEJETS   = -1603014,
+    SAY_SUMMON      = -1603015,
+    SAY_SLAY1       = -1603016,
+    SAY_SLAY2       = -1603017,
+    SAY_BERSERK     = -1603018,
+    SAY_DEATH       = -1603019,
+
+    //ignis the furnace master
+    SPELL_FLAME_JETS			= 62680,
+    SPELL_FLAME_JETS_H			= 63472,
+    SPELL_SLAG_POT				= 62717,
+    SPELL_SLAG_POT_H			= 63477,
+    SPELL_SLAG_POT_DMG			= 65722,
+    SPELL_SLAG_POT_DMG_H		= 65723,
+    SPELL_SCORCH				= 62546,
+    SPELL_SCORCH_H				= 63474,
+    BUFF_STRENGHT_OF_CREATOR	= 64473,
+    SPELL_HASTE					= 66045,
+    SPELL_ENRAGE                = 26662,
+    //iron construct
+    SPELL_HEAT					= 65667,
+    SPELL_MOLTEN				= 62373,
+    SPELL_BRITTLE				= 62382,
+    SPELL_SHATTER				= 62383,
+    //scorch target
+    AURA_SCORCH					= 62548,
+    AURA_SCORCH_H				= 63476,
+    AURA_HEAT                   = 65667,
+    //NPC ids
+    MOB_IRON_CONSTRUCT			= 33121,
+    MOB_SCORCH_TARGET			= 33221,
+
+    ACHIEV_STOKIN_THE_FURNACE   = 2930,
+    ACHIEV_STOKIN_THE_FURNACE_H = 2929,
+};
+
+#define HOME_X                      586.747009f
+#define HOME_Y                      381.997986f
+
+// scorch target
+struct MANGOS_DLL_DECL mob_scorch_targetAI : public ScriptedAI
+{
+    mob_scorch_targetAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        SetCombatMovement(false);
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 Death_Timer;
+    uint32 Range_Check_Timer;
+
+    void Reset()
+    {
+        Death_Timer = 55000;
+        Range_Check_Timer = 1000;
+        m_creature->SetDisplayId(11686);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        DoCast(m_creature,  m_bIsRegularMode ? AURA_SCORCH : AURA_SCORCH_H);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+
+        if (Death_Timer < diff)
+        {
+            m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Death_Timer -= diff;
+    }
+};
+
+CreatureAI* GetAI_mob_scorch_target(Creature* pCreature)
+{
+    return new mob_scorch_targetAI(pCreature);
+}
+
+// iron construct
+struct MANGOS_DLL_DECL mob_iron_constructAI : public ScriptedAI
+{
+    mob_iron_constructAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 Death_Timer;
+    uint32 Aura_Check_Timer;
+    uint32 ScorchTimer;
+    uint32 MoltenTimer;
+    uint32 BrittleTimer;
+    bool brittle;
+    bool shatter;
+    bool molten;
+
+    uint32 WaterCheckTimer;
+
+    void Reset()
+    {
+        shatter = false;
+        brittle = false;
+        molten = false;
+        WaterCheckTimer = 2000;
+        ScorchTimer = 5000;
+        Aura_Check_Timer = 1000;
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->setFaction(35);
+        m_creature->GetMotionMaster()->Clear();
+        SetCombatMovement(true);
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (!m_pInstance)
+            return;
+        if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_IGNIS))))
+            if (pTemp->isAlive())
+                if (pTemp->HasAura(BUFF_STRENGHT_OF_CREATOR))
+                {
+                    if (pTemp->GetAura(BUFF_STRENGHT_OF_CREATOR, EFFECT_INDEX_0)->GetStackAmount() == 1)
+                        pTemp->RemoveAurasDueToSpell(BUFF_STRENGHT_OF_CREATOR);
+                    else
+                        pTemp->GetAura(BUFF_STRENGHT_OF_CREATOR, EFFECT_INDEX_0)->modStackAmount(-1);
+                }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &damage)
+    {
+        if (brittle)
+            if (damage>5000){
+                DoCast(m_creature, SPELL_SHATTER);
+                shatter = true;
+                brittle = false;
+                Death_Timer = 1000;
+            }
+    }
+
+    void GetInCombat()
+    { 
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_IGNIS))))
+        {
+            if (pTemp->isAlive())
+            {
+                m_creature->setFaction(14);
+                m_creature->RemoveSplineFlag(SPLINEFLAG_WALKMODE);
+                m_creature->GetMotionMaster()->MovePoint(0, pTemp->GetPositionX(), pTemp->GetPositionY(), pTemp->GetPositionZ());
+
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    m_creature->AddThreat(pTarget,0.0f);
+                    m_creature->AI()->AttackStart(pTarget);
+                    m_creature->SetInCombatWithZone();
+                }
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Death_Timer < diff && shatter)
+        {
+            m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Death_Timer -= diff;   
+
+        if (m_creature->HasAura(SPELL_BRITTLE,EFFECT_INDEX_0))
+            brittle = true;
+        else
+            brittle = false;
+
+        if (Aura_Check_Timer < diff && !molten)
+        {
+            if(Aura* aura = m_creature->GetAura(SPELL_HEAT,EFFECT_INDEX_0))
+                if(aura->GetStackAmount() > 19)
+                {
+                    DoCast(m_creature, SPELL_MOLTEN);
+                    MoltenTimer = 30000;
+                    molten = true;
+                }
+                Aura_Check_Timer = 1000;
+        }else Aura_Check_Timer -= diff;
+
+        //Water checks
+        if(molten)
+        {
+            //timed molten
+            if (MoltenTimer <= diff)
+            {
+                DoCast(m_creature, SPELL_BRITTLE);
+                SetCombatMovement(false);
+                m_creature->StopMoving();
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->GetMotionMaster()->MoveIdle();
+                MoltenTimer = 30000;
+                BrittleTimer = 20000;
+                brittle = true;
+                molten = false;
+            }else MoltenTimer -= diff;
+
+            //TODO: implement water event!
+            /*
+            if (WaterCheckTimer <= diff)
+            {
+                if(m_creature->IsInWater())
+                {
+                    DoCast(m_creature, SPELL_BRITTLE);
+                    brittle = true;
+                    molten = false;
+                }
+                WaterCheckTimer = 2000;
+            }else WaterCheckTimer -= diff;
+            */
+        } 
+
+        if (BrittleTimer < diff && brittle)
+        {
+            SetCombatMovement(true);
+            m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+            brittle = false;
+            
+            BrittleTimer = 20000;
+        }else BrittleTimer -= diff;
+
+        if (!shatter && !brittle)
+            DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_iron_construct(Creature* pCreature)
+{
+    return new mob_iron_constructAI(pCreature);
+}
+
+//ignis the furnace master
+struct MANGOS_DLL_DECL boss_ignisAI : public ScriptedAI
+{
+    boss_ignisAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    std::list<uint64> m_lIronConstructGUIDList;
+
+    uint32 Flame_Jets_Timer;
+    uint32 Slag_Pot_Timer;
+    uint32 Slag_Pot_Dmg_Timer;
+    uint32 Scorch_Timer;
+    uint32 Summon_Timer;
+    uint32 PotDmgCount;
+    uint32 EnrageTimer;
+
+    uint64 m_uiPotTarget;
+    std::list<Creature*> lConstructs;
+    Creature *pConstruct;
+
+    uint32 uiEncounterTimer;
+
+    void Reset()
+    {
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+        Flame_Jets_Timer = 20000;
+        Slag_Pot_Timer = 25000;
+        Slag_Pot_Dmg_Timer = 26000;
+        Scorch_Timer = 14000;
+        Summon_Timer = 10000;
+        EnrageTimer = 600000;   // 10 MIN
+        PotDmgCount = 0;
+        m_uiPotTarget = 0;
+        m_lIronConstructGUIDList.clear();
+
+        uiEncounterTimer = 0;
+
+        GetCreatureListWithEntryInGrid(lConstructs, m_creature, MOB_IRON_CONSTRUCT, DEFAULT_VISIBILITY_INSTANCE);
+
+        if (!lConstructs.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lConstructs.begin(); iter != lConstructs.end(); ++iter)
+            {
+                if ((*iter) && !(*iter)->isAlive())
+                    (*iter)->Respawn();
+            }
+        }
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        //death yell
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_IGNIS, DONE);
+
+        if (!m_lIronConstructGUIDList.empty())
+        {
+            for(std::list<uint64>::iterator itr = m_lIronConstructGUIDList.begin(); itr != m_lIronConstructGUIDList.end(); ++itr)
+                if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                    pTemp->ForcedDespawn();
+        }
+
+        DoScriptText(SAY_DEATH, m_creature);
+
+        if (uiEncounterTimer < 240000)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_STOKIN_THE_FURNACE : ACHIEV_STOKIN_THE_FURNACE_H);
+        }
+    }
+
+    Creature* SelectRandomConstruct(float fRange)
+    {
+        std::list<Creature* > lConstructList;
+        GetCreatureListWithEntryInGrid(lConstructList, m_creature, MOB_IRON_CONSTRUCT, fRange);
+
+        //This should not appear!
+        if (lConstructList.empty()){
+            EnterEvadeMode();
+            debug_log("SD2: AhnKahet: No volunteer to sacriface!");
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lConstructList.begin();
+        advance(iter, urand(0, lConstructList.size()-1));
+
+        return *iter;
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_IGNIS, IN_PROGRESS);
+
+        DoScriptText(SAY_AGGRO, m_creature);
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_IGNIS, FAIL);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        uiEncounterTimer += diff;
+
+        // enrage
+        if(EnrageTimer < diff)
+        {
+            DoScriptText(SAY_BERSERK, m_creature);
+            DoCast(m_creature, SPELL_ENRAGE);
+            EnrageTimer = 30000;
+        }
+        else EnrageTimer -= diff;
+
+        if (Flame_Jets_Timer < diff)
+        {
+            //flame jets yell
+            DoScriptText(SAY_FLAMEJETS, m_creature);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_FLAME_JETS : SPELL_FLAME_JETS_H);
+            Flame_Jets_Timer = 30000;
+        }else Flame_Jets_Timer -= diff;   
+
+        if (Slag_Pot_Timer < diff)
+        {
+            //slag pot yell
+            DoScriptText(SAY_SLAGPOT, m_creature);
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,1)){
+                DoCast(target, m_bIsRegularMode ? SPELL_SLAG_POT : SPELL_SLAG_POT_H);
+                m_uiPotTarget = target->GetGUID();
+            }
+            Slag_Pot_Timer = 30000;
+            Slag_Pot_Dmg_Timer = 1000;
+            PotDmgCount = 0;
+        }else Slag_Pot_Timer -= diff;  
+
+        if (Slag_Pot_Dmg_Timer < diff)
+        {
+            if (Unit* pPotTarget = Unit::GetUnit(*m_creature, m_uiPotTarget)){
+                if (PotDmgCount < 10)
+                    DoCast(pPotTarget, m_bIsRegularMode ? SPELL_SLAG_POT_DMG : SPELL_SLAG_POT_DMG_H);
+                else
+                    if (PotDmgCount == 10)
+                        DoCast(pPotTarget, SPELL_HASTE);
+            }
+            ++PotDmgCount;
+            Slag_Pot_Dmg_Timer = 1000;
+        }else Slag_Pot_Dmg_Timer -= diff;
+
+        if (Summon_Timer < diff)
+        {
+            //summon yell
+            DoScriptText(SAY_SUMMON, m_creature);
+
+            /*
+            if (Creature* pTemp = m_creature->SummonCreature(MOB_IRON_CONSTRUCT, 0.0f, 0.0f, 0.0f, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                    m_lIronConstructGUIDList.push_back(pTemp->GetGUID());
+                }
+            */
+
+            pConstruct = SelectRandomConstruct(200.0f);
+            if(pConstruct)
+            {
+                ((mob_iron_constructAI*)pConstruct->AI())->GetInCombat();
+            }
+
+            Summon_Timer = 40000;
+            if (m_creature->HasAura(BUFF_STRENGHT_OF_CREATOR))
+                m_creature->GetAura(BUFF_STRENGHT_OF_CREATOR, EFFECT_INDEX_0)->modStackAmount(+1);
+            else
+                DoCast(m_creature, BUFF_STRENGHT_OF_CREATOR);
+        }else Summon_Timer -= diff;
+
+        if (Scorch_Timer < diff)
+        {
+            if(irand(0,1))
+                DoScriptText(SAY_SCORCH1, m_creature);
+            else
+                DoScriptText(SAY_SCORCH2, m_creature);
+
+            DoCast(m_creature->getVictim(), SPELL_SCORCH);
+            if (Creature* pTemp = m_creature->SummonCreature(MOB_SCORCH_TARGET, m_creature->getVictim()->GetPositionX(), m_creature->getVictim()->GetPositionY(), m_creature->getVictim()->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+            {
+                pTemp->AddThreat(m_creature->getVictim(),0.0f);
+                pTemp->AI()->AttackStart(m_creature->getVictim());
+            }
+            Scorch_Timer = 28000;
+        }else Scorch_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+
+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 200)
+            EnterEvadeMode();
+    }
+};
+
+CreatureAI* GetAI_boss_ignis(Creature* pCreature)
+{
+    return new boss_ignisAI(pCreature);
+}
+
+void AddSC_boss_ignis()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_ignis";
+    NewScript->GetAI = GetAI_boss_ignis;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_scorch_target";
+    NewScript->GetAI = &GetAI_mob_scorch_target;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_iron_construct";
+    NewScript->GetAI = &GetAI_mob_iron_construct;
+    NewScript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_iron_council.cpp b/scripts/northrend/ulduar/ulduar/boss_iron_council.cpp
new file mode 100644
index 0000000..183a859
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_iron_council.cpp
@@ -0,0 +1,1156 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_iron_council
+SD%Complete: 90%
+SDComment: missing yells and rune of power
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+	//yells
+    SAY_MOLGEIM_AGGRO       = -1603040,
+    SAY_MOLGEIM_DEATH1      = -1603041,
+    SAY_MOLGEIM_DEATH2      = -1603042,
+    SAY_MOLGEIM_DEATH_RUNE  = -1603043,
+    SAY_MOLGEIM_SUMMON      = -1603044,
+    SAY_MOLGEIM_SLAY1       = -1603045,
+    SAY_MOLGEIM_SLAY2       = -1603046,
+    SAY_MOLGEIM_BERSERK     = -1603047,
+    
+    SAY_STEEL_AGGRO         = -1603050,
+    SAY_STEEL_DEATH1        = -1603051,
+    SAY_STEEL_DEATH2        = -1603052,
+    SAY_STEEL_SLAY1         = -1603053,
+    SAY_STEEL_SLAY2         = -1603054,
+    SAY_STEEL_OVERWHELMING  = -1603055,
+    SAY_STEEL_BERSERK       = -1603056,
+
+    SAY_BRUNDIR_AGGR0       = -1603060,
+    SAY_BRUNDIR_OVERLOAD    = -1603061,
+    SAY_BRUNDIR_WHIRL       = -1603062,
+    SAY_BRUNDIR_DEATH1      = -1603063,
+    SAY_BRUNDIR_DEATH2      = -1603064,
+    SAY_BRUNDIR_SLAY1       = -1603065,
+    SAY_BRUNDIR_SLAY2       = -1603066,
+    SAY_BRUNDIR_BERSERK     = -1603067,
+    SAY_BRUNDIR_FLY         = -1603068,
+
+	//all
+	SPELL_BERSERK				= 47008,
+	SPELL_SUPERCHARGE			= 61920,
+	//steelbreaker
+	SPELL_HIGH_VOLTAGE			= 61890,
+	SPELL_HIGH_VOLTAGE_H		= 63498,
+	SPELL_FUSION_PUNCH			= 61903,
+	SPELL_FUSION_PUNCH_H		= 63493,
+	SPELL_STATIC_DISRUPTION		= 44008,
+	SPELL_STATIC_DISRUPTION_H	= 63494,
+	SPELL_POWER					= 64637,
+	SPELL_POWER_H				= 61888,
+	SPELL_ELECTRICAL_CHARGE		= 61902,
+	//runemaster molgeim
+	SPELL_SHIELD				= 62274,
+	SPELL_SHIELD_H				= 63489,
+	SPELL_RUNE_OF_POWER			= 63513,
+	SPELL_RUNE_OF_DEATH			= 62269,
+	SPELL_RUNE_OF_DEATH_H		= 63490,
+	SPELL_RUNE_OF_SUMMONING		= 62273,
+	//rune of power
+	AURA_RUNE_OF_POWER			= 61974,
+	//rune of summoning
+	AURA_RUNE_OF_SUMMONING		= 62019,
+	//lightning elemental
+	SPELL_LIGHTNING_BLAST		= 62054,
+	SPELL_LIGHTNING_BLAST_H		= 63491,
+	//stormcaller brundir
+	SPELL_CHAIN_LIGHTNING		= 61879,
+	SPELL_CHAIN_LIGHTNING_H		= 63479,
+	SPELL_OVERLOAD				= 61869,
+	SPELL_LIGHTNING_WHIRL		= 61915,
+	SPELL_LIGHTNING_WHIRL_H		= 63483,
+	SPELL_STORMSHIELD			= 64187,
+	SPELL_LIGHTNING_TENDRILS	= 61887,
+	SPELL_LIGHTNING_TENDRILS_H	= 63486,
+	LIGHTNING_TENDRILS_VISUAL	= 61883,
+	//NPC ids
+	MOB_LIGHTNING_ELEMENTAL		= 32958, 
+
+    ACHIEV_ON_YOUR_SIDE         = 2945,
+    ACHIEV_ON_YOUR_SIDE_H       = 2946,
+    SPELL_IRON_BOOT_AURA        = 58501,
+
+    ACHIEV_CHOOSE_BRUNDIR       = 2940,
+    ACHIEV_CHOOSE_BRUNDIR_H     = 2943,
+    ACHIEV_CHOOSE_MOLGEIM       = 2939,
+    ACHIEV_CHOOSE_MOLGEIM_H     = 2942,
+    ACHIEV_CHOOSE_STEELBREAKER  = 2941,
+    ACHIEV_CHOOSE_STEELBREAKER_H= 2944,
+};
+
+// Rune of Power
+struct MANGOS_DLL_DECL mob_rune_of_powerAI : public ScriptedAI
+{
+    mob_rune_of_powerAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		Reset();
+		SetCombatMovement(false);
+	}
+
+	uint32 Death_Timer;
+
+    void Reset()
+    {
+		Death_Timer = 60000;
+		m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+		m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+		DoCast(m_creature,  AURA_RUNE_OF_POWER);
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+		if (Death_Timer < diff)
+        {
+			m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Death_Timer -= diff;
+	}
+};
+
+CreatureAI* GetAI_mob_rune_of_power(Creature* pCreature)
+{
+    return new mob_rune_of_powerAI(pCreature);
+}
+
+// Lightning Elemental
+struct MANGOS_DLL_DECL mob_ulduar_lightning_elementalAI : public ScriptedAI
+{
+    mob_ulduar_lightning_elementalAI(Creature* pCreature) : ScriptedAI(pCreature)
+	{
+		Reset();
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Death_Timer;
+	uint32 Check_Timer;
+	bool explode;
+
+    void Reset()
+    {
+		explode = false;
+		Check_Timer = 1000;
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Death_Timer < diff && explode)
+        {
+			m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Death_Timer -= diff;
+
+		if (Check_Timer < diff)
+		{
+			if (m_creature->IsWithinDistInMap(m_creature->getVictim(), 15))
+			{
+				DoCast(m_creature, m_bIsRegularMode ? SPELL_LIGHTNING_BLAST : SPELL_LIGHTNING_BLAST_H);
+				explode = true;
+				Death_Timer = 1000;
+			}
+			Check_Timer = 1000;
+		}else Check_Timer -= diff;
+	}
+};
+
+CreatureAI* GetAI_mob_ulduar_lightning_elemental(Creature* pCreature)
+{
+    return new mob_ulduar_lightning_elementalAI(pCreature);
+}
+
+// Rune of Summoning
+struct MANGOS_DLL_DECL mob_rune_of_summoningAI : public ScriptedAI
+{
+    mob_rune_of_summoningAI(Creature* pCreature) : ScriptedAI(pCreature)
+	{
+		Reset();
+		SetCombatMovement(false);
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+	}
+
+	ScriptedInstance* m_pInstance;
+
+	uint32 Death_Timer;
+	uint32 Summon_Timer;
+	uint32 summon_delay;
+	uint32 summonnum;
+	bool summondone;
+
+    void Reset()
+    {
+		summondone = false;
+		summon_delay = 3000;
+		summonnum = 0;
+		m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+		m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+		DoCast(m_creature,  AURA_RUNE_OF_SUMMONING);
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+		if (Death_Timer < diff && summondone)
+        {
+			m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Death_Timer -= diff;
+
+		if (summon_delay < diff)
+		{
+			if (Creature* pTemp = m_creature->SummonCreature(MOB_LIGHTNING_ELEMENTAL, 0.0f, 0.0f, 0.0f, 0.0f, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+				++summonnum;
+			summon_delay = 500;
+			if (summonnum > 9)
+			{
+				summondone = true;
+				Death_Timer = 400;
+			}
+		} else summon_delay -= diff;
+	}
+};
+
+CreatureAI* GetAI_mob_rune_of_summoning(Creature* pCreature)
+{
+    return new mob_rune_of_summoningAI(pCreature);
+}
+
+//Stormcaller Brundir
+struct MANGOS_DLL_DECL boss_brundirAI : public ScriptedAI
+{
+    boss_brundirAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty(); 
+		Reset();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Chain_Lightning_Timer;
+	uint32 Overload_Timer;
+	uint32 Whirl_Timer;
+	uint32 Tendrils_start_Timer;
+	uint32 Tendrils_Change;
+	uint32 Tendrils_end_Timer;
+	uint32 die_delay;
+	uint32 Enrage_Timer;
+	uint32 Check;
+
+	bool supercharge1;
+	bool supercharge2;
+	bool tendrils;
+	bool die;
+	bool steelbreaker;
+	bool molgeim;
+	bool enrage;
+
+    void Reset()
+    {
+		m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+		Chain_Lightning_Timer = 0;
+		Overload_Timer = 35000;
+		Enrage_Timer = 900000;
+		Check = 1000;
+		enrage = false;
+		supercharge1 = false;
+		supercharge2 = false;
+		tendrils = false;
+		steelbreaker = false;
+		molgeim = false;
+		die = false;
+		if (m_creature->HasAura(SPELL_SUPERCHARGE))
+			m_creature->RemoveAurasDueToSpell(SPELL_SUPERCHARGE);
+    }
+
+	void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+		if (uiDamage > m_creature->GetHealth() && !die)
+		{
+			uiDamage = 0;
+			m_creature->CastStop();
+			m_creature->setFaction(1925);
+			if (supercharge1)
+			{
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+					if (pTemp->isAlive() && pTemp->HasAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0))
+						pTemp->GetAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0)->modStackAmount(+1);
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+					if (pTemp->isAlive() && pTemp->HasAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0))
+						pTemp->GetAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0)->modStackAmount(+1);
+			}else
+				DoCast(m_creature, SPELL_SUPERCHARGE);
+			die_delay = 500;
+			die = true;
+		}
+    }
+
+	void JustDied(Unit* pKiller)
+    {
+		//death yell
+		m_creature->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+		m_creature->setFaction(14);
+		Map* pMap = m_creature->GetMap();
+		if (pMap && pMap->IsDungeon())
+		{
+			Map::PlayerList const &PlayerList = pMap->GetPlayers();
+			if (PlayerList.isEmpty())
+				return;
+			for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+			{
+				if (i->getSource()->isAlive() && i->getSource()->HasAura(SPELL_SUPERCHARGE))
+					i->getSource()->RemoveAurasDueToSpell(SPELL_SUPERCHARGE);
+			}
+		}
+        if (m_pInstance)
+		{
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+				if (!pTemp->isAlive())
+					if (Creature* p2Temp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+                        if (!p2Temp->isAlive())
+                        {
+                            m_pInstance->SetData(TYPE_ASSEMBLY, DONE);
+                            m_creature->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+                            pTemp->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+                            p2Temp->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+
+                            // I'm on your side
+                            Map* pMap = m_creature->GetMap();
+                            AchievementEntry const *AchievYourSide = GetAchievementStore()->LookupEntry(m_bIsRegularMode ? ACHIEV_ON_YOUR_SIDE : ACHIEV_ON_YOUR_SIDE_H);
+                            if(AchievYourSide && pMap)
+                            {
+                                Map::PlayerList const &lPlayers = pMap->GetPlayers();
+                                if (!lPlayers.isEmpty())
+                                {
+                                    for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
+                                    {
+                                        if (Player* pPlayer = itr->getSource())
+                                        {
+                                            if(pPlayer->HasAura(SPELL_IRON_BOOT_AURA, EFFECT_INDEX_0))
+                                                pPlayer->CompletedAchievement(AchievYourSide);
+                                        }
+                                    }
+                                }
+                            }
+
+                            // ChooseBrundir
+                            if(m_pInstance)
+                                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_CHOOSE_BRUNDIR : ACHIEV_CHOOSE_BRUNDIR_H);
+                        }
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+				if (pTemp->isAlive())
+					pTemp->SetHealth(pTemp->GetMaxHealth());
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+				if (pTemp->isAlive())
+					pTemp->SetHealth(pTemp->GetMaxHealth());
+		}
+
+        if(irand(0,1))
+            DoScriptText(SAY_BRUNDIR_DEATH1, m_creature);
+        else
+            DoScriptText(SAY_BRUNDIR_DEATH2, m_creature);
+    }
+
+	void Aggro(Unit* pWho)
+    {
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+			if (pTemp->isAlive())
+				pTemp->SetInCombatWithZone();
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+			if (pTemp->isAlive())
+				pTemp->SetInCombatWithZone();
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ASSEMBLY, IN_PROGRESS);
+
+        DoScriptText(SAY_BRUNDIR_AGGR0, m_creature);
+    }
+
+	void JustReachedHome()
+    {
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+			if (!pTemp->isAlive())
+				pTemp->Respawn();
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+			if (!pTemp->isAlive())
+				pTemp->Respawn();
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ASSEMBLY, FAIL);
+    }
+
+    void KilledUnit(Unit *who)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_BRUNDIR_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_BRUNDIR_SLAY2, m_creature);
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+		if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Chain_Lightning_Timer < diff && !tendrils)
+        {
+			DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_CHAIN_LIGHTNING : SPELL_CHAIN_LIGHTNING_H);
+            Chain_Lightning_Timer = 2000;
+        }else Chain_Lightning_Timer -= diff;   
+
+		if (Overload_Timer < diff && !tendrils)
+        {
+			DoScriptText(SAY_BRUNDIR_OVERLOAD, m_creature);
+			m_creature->CastStop();
+			DoCast(m_creature, SPELL_OVERLOAD);
+            Overload_Timer = 40000;
+        }else Overload_Timer -= diff;  
+
+		if (Whirl_Timer < diff && !tendrils && supercharge1)
+		{
+            DoScriptText(SAY_BRUNDIR_WHIRL, m_creature);
+			m_creature->CastStop();
+            DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_LIGHTNING_WHIRL : SPELL_LIGHTNING_WHIRL_H);
+			Whirl_Timer = 10000;
+		}else Whirl_Timer -= diff;
+
+		if (Tendrils_start_Timer < diff && supercharge2)
+        {
+			if (!tendrils)
+			{
+				//tendrils emote (?)
+				m_creature->CastStop();
+				DoCast(m_creature, LIGHTNING_TENDRILS_VISUAL);
+				if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+				{
+					m_creature->AddThreat(pTarget,0.0f);
+					m_creature->AI()->AttackStart(pTarget);
+				}
+				tendrils = true;
+				m_creature->SetSpeedRate(MOVE_RUN, 0.8f);
+				Tendrils_start_Timer = 3000;
+				Tendrils_end_Timer = 40000;
+				Tendrils_Change = 5000;
+			} else
+			{
+				DoCast(m_creature, m_bIsRegularMode ? SPELL_LIGHTNING_TENDRILS : SPELL_LIGHTNING_TENDRILS_H);
+				Tendrils_start_Timer = 90000;
+			}
+		}else Tendrils_start_Timer -= diff;
+
+		if (Tendrils_Change < diff && tendrils)
+        {
+			if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+			{
+				m_creature->AddThreat(pTarget,0.0f);
+				m_creature->AI()->AttackStart(pTarget);
+			}
+			Tendrils_Change = 6000;
+        }else Tendrils_Change -= diff;
+
+		if (Tendrils_end_Timer < diff && tendrils)
+        {
+			if (m_creature->HasAura(SPELL_LIGHTNING_TENDRILS))
+				m_creature->RemoveAurasDueToSpell(SPELL_LIGHTNING_TENDRILS);
+			if (m_creature->HasAura(SPELL_LIGHTNING_TENDRILS_H))
+				m_creature->RemoveAurasDueToSpell(SPELL_LIGHTNING_TENDRILS_H);
+			if (m_creature->HasAura(LIGHTNING_TENDRILS_VISUAL))
+				m_creature->RemoveAurasDueToSpell(LIGHTNING_TENDRILS_VISUAL);
+            Tendrils_start_Timer = 90000;
+			m_creature->SetSpeedRate(MOVE_RUN, 1.8f);
+			tendrils = false;
+			Chain_Lightning_Timer = 5000;
+			Overload_Timer = 35000;
+			Whirl_Timer = 10000;
+        }else Tendrils_end_Timer -= diff;
+
+		if (die_delay < diff)
+		{
+			if (die)
+				m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+		}
+        else die_delay -= diff;
+
+		if (Enrage_Timer < diff && !enrage)
+		{
+            DoScriptText(SAY_BRUNDIR_BERSERK, m_creature);
+			m_creature->CastStop();
+			DoCast(m_creature, SPELL_BERSERK);
+			enrage = true;
+		}else Enrage_Timer -= diff;
+
+		if (Check < diff)
+		{
+			if (!steelbreaker)
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+					if (!pTemp->isAlive())
+					{
+						steelbreaker = true;
+						if (!supercharge1)
+						{
+							supercharge1 = true;
+							Whirl_Timer = 10000;
+						}
+						else
+						{
+							supercharge2 = true;
+							Tendrils_start_Timer = 40000;
+							Tendrils_end_Timer = 60000;
+							Tendrils_Change = 6000;
+						}
+					}
+			if (!molgeim)
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+					if (!pTemp->isAlive())
+					{
+						molgeim = true;
+						if (!supercharge1)
+						{
+							supercharge1 = true;
+							Whirl_Timer = 10000;
+						}
+						else
+						{
+							supercharge2 = true;
+							Tendrils_start_Timer = 40000;
+							Tendrils_end_Timer = 60000;
+							Tendrils_Change = 6000;
+						}
+					}
+			Check = 1000;
+		}else Check -= diff;
+		
+		if (!tendrils && !die)
+			DoMeleeAttackIfReady();
+	}
+};
+
+CreatureAI* GetAI_boss_brundir(Creature* pCreature)
+{
+    return new boss_brundirAI(pCreature);
+}
+
+//Runemaster Molgeim
+struct MANGOS_DLL_DECL boss_molgeimAI : public ScriptedAI
+{
+    boss_molgeimAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+
+		Reset();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Shield_Timer;
+	uint32 Rune_Power_Timer;
+	uint32 Rune_Death_Timer;
+	uint32 Rune_Summon_Timer;
+	uint32 die_delay;
+	uint32 Enrage_Timer;
+	uint32 Check;
+
+	bool supercharge1;
+	bool supercharge2;
+	bool die;
+	bool brundir;
+	bool steelbreaker;
+	bool enrage;
+
+    void Reset()
+    {
+		m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+		Shield_Timer = 20000;
+		Rune_Power_Timer = 10000;
+		Enrage_Timer = 900000;
+		Check = 1000;
+		enrage = false;
+		brundir = false;
+		steelbreaker = false;
+		supercharge1 = false;
+		supercharge2 = false;
+		die = false;
+		if (m_creature->HasAura(SPELL_SUPERCHARGE))
+			m_creature->RemoveAurasDueToSpell(SPELL_SUPERCHARGE);
+    }
+
+	void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+		if (uiDamage > m_creature->GetHealth() && !die)
+		{
+			uiDamage = 0;
+			m_creature->CastStop();
+			m_creature->setFaction(1925);
+			if (supercharge1)
+			{
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+					if (pTemp->isAlive() && pTemp->HasAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0))
+						pTemp->GetAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0)->modStackAmount(+1);
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+					if (pTemp->isAlive() && pTemp->HasAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0))
+						pTemp->GetAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0)->modStackAmount(+1);
+			}else
+				DoCast(m_creature, SPELL_SUPERCHARGE);
+			die_delay = 500;
+			die = true;
+		}
+    }
+
+	void JustDied(Unit* pKiller)
+    {
+		//death yell
+		m_creature->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+		m_creature->setFaction(14);
+		Map* pMap = m_creature->GetMap();
+		if (pMap && pMap->IsDungeon())
+		{
+			Map::PlayerList const &PlayerList = pMap->GetPlayers();
+			if (PlayerList.isEmpty())
+				return;
+			for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+			{
+				if (i->getSource()->isAlive() && i->getSource()->HasAura(SPELL_SUPERCHARGE))
+					i->getSource()->RemoveAurasDueToSpell(SPELL_SUPERCHARGE);
+			}
+		}
+        if (m_pInstance)
+		{
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+				if (!pTemp->isAlive())
+					if (Creature* p2Temp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+						if (!p2Temp->isAlive())
+						{
+							m_pInstance->SetData(TYPE_ASSEMBLY, DONE);
+							m_creature->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+							pTemp->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+							p2Temp->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+
+                            // I'm on your side
+                            Map* pMap = m_creature->GetMap();
+                            AchievementEntry const *AchievYourSide = GetAchievementStore()->LookupEntry(m_bIsRegularMode ? ACHIEV_ON_YOUR_SIDE : ACHIEV_ON_YOUR_SIDE_H);
+                            if(AchievYourSide && pMap)
+                            {
+                                Map::PlayerList const &lPlayers = pMap->GetPlayers();
+                                if (!lPlayers.isEmpty())
+                                {
+                                    for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
+                                    {
+                                        if (Player* pPlayer = itr->getSource())
+                                        {
+                                            if(pPlayer->HasAura(SPELL_IRON_BOOT_AURA, EFFECT_INDEX_0))
+                                                pPlayer->CompletedAchievement(AchievYourSide);
+                                        }
+                                    }
+                                }
+                            }
+
+                            // ChooseMolgeim
+                            if(m_pInstance)
+                                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_CHOOSE_MOLGEIM : ACHIEV_CHOOSE_MOLGEIM_H);
+						}
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+				if (pTemp->isAlive())
+					pTemp->SetHealth(pTemp->GetMaxHealth());
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+				if (pTemp->isAlive())
+					pTemp->SetHealth(pTemp->GetMaxHealth());
+		}
+
+        if(irand(0,1))
+            DoScriptText(SAY_MOLGEIM_DEATH1, m_creature);
+        else
+            DoScriptText(SAY_MOLGEIM_DEATH2, m_creature);
+    }
+
+	void Aggro(Unit* pWho)
+    {
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+			if (pTemp->isAlive())
+				pTemp->SetInCombatWithZone();
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+			if (pTemp->isAlive())
+				pTemp->SetInCombatWithZone();
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ASSEMBLY, IN_PROGRESS);
+
+        DoScriptText(SAY_MOLGEIM_AGGRO, m_creature);
+    }
+
+	void JustReachedHome()
+    {
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+			if (!pTemp->isAlive())
+				pTemp->Respawn();
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+			if (!pTemp->isAlive())
+				pTemp->Respawn();
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ASSEMBLY, FAIL);
+    }
+
+    void KilledUnit(Unit *who)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_MOLGEIM_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_MOLGEIM_SLAY2, m_creature);
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+		if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Shield_Timer < diff)
+        {
+			DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_SHIELD : SPELL_SHIELD_H);
+            Shield_Timer = 50000;
+        }else Shield_Timer -= diff;   
+
+		if (Rune_Power_Timer < diff)
+		{
+			switch(urand(0, 2))
+            {
+                case 0:
+					if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+						if (pTemp->isAlive())
+							DoCast(pTemp, SPELL_RUNE_OF_POWER);
+						else
+							DoCast(m_creature, SPELL_RUNE_OF_POWER);
+                break;
+				case 1:
+					if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+						if (pTemp->isAlive())
+							DoCast(pTemp, SPELL_RUNE_OF_POWER);
+						else
+							DoCast(m_creature, SPELL_RUNE_OF_POWER);
+                break;
+				case 2:
+					DoCast(m_creature, SPELL_RUNE_OF_POWER);
+                break;
+			}
+			Rune_Power_Timer = 55000;
+		}else Rune_Power_Timer -= diff;
+
+		if (Rune_Death_Timer < diff && supercharge1)
+		{
+            DoScriptText(SAY_MOLGEIM_DEATH_RUNE, m_creature);
+			if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+				DoCast(pTarget, m_bIsRegularMode ? SPELL_RUNE_OF_DEATH : SPELL_RUNE_OF_DEATH_H);
+			Rune_Death_Timer = 60000;
+		}else Rune_Death_Timer -= diff;
+
+		if (Rune_Summon_Timer < diff && supercharge2)
+		{
+            DoScriptText(SAY_MOLGEIM_SUMMON, m_creature);
+			m_creature->CastStop();
+			if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+				DoCast(pTarget, SPELL_RUNE_OF_SUMMONING);
+			Rune_Summon_Timer = 30000;
+		}else Rune_Summon_Timer -= diff;
+
+		if (die_delay < diff)
+		{
+			if (die)
+				m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+		}
+        else die_delay -= diff;
+
+		if (Enrage_Timer < diff && !enrage)
+		{
+            DoScriptText(SAY_MOLGEIM_BERSERK, m_creature);
+			m_creature->CastStop();
+			DoCast(m_creature, SPELL_BERSERK);
+			enrage = true;
+		}else Enrage_Timer -= diff;
+
+		if (Check < diff)
+		{
+			if (!steelbreaker)
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STEELBREAKER))))
+					if (!pTemp->isAlive())
+					{
+						steelbreaker = true;
+						if (!supercharge1)
+						{
+							supercharge1 = true;
+							Rune_Death_Timer = 10000;
+						}
+						else
+						{
+							supercharge2 = true;
+							Rune_Summon_Timer = 20000;
+						}
+					}
+			if (!brundir)
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+					if (!pTemp->isAlive())
+					{
+						brundir = true;
+						if (!supercharge1)
+						{
+							supercharge1 = true;
+							Rune_Death_Timer = 10000;
+						}
+						else
+						{
+							supercharge2 = true;
+							Rune_Summon_Timer = 20000;
+						}
+					}
+			Check = 1000;
+		}else Check -= diff;
+		
+		if (!die)
+			DoMeleeAttackIfReady();
+	}
+};
+
+CreatureAI* GetAI_boss_molgeim(Creature* pCreature)
+{
+    return new boss_molgeimAI(pCreature);
+}
+
+//Steelbreaker
+struct MANGOS_DLL_DECL boss_steelbreakerAI : public ScriptedAI
+{
+    boss_steelbreakerAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+
+		Reset();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Fusion_Punch_Timer;
+	uint32 Static_Disruption_Timer;
+	uint32 Power_Timer;
+	uint32 Meltdown_Timer;
+	uint32 die_delay;
+	uint32 Enrage_Timer;
+	uint32 Check;
+
+	uint64 MeltTarget;
+
+	bool brundir;
+	bool molgeim;
+	bool supercharge1;
+	bool supercharge2;
+	bool die;
+	bool enrage;
+
+    void Reset()
+    {
+		m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+		Fusion_Punch_Timer = 20000;
+		Enrage_Timer = 900000;
+		MeltTarget = 0;
+		Check = 1000;
+		enrage = false;
+		brundir = false;
+		molgeim = false;
+		supercharge1 = false;
+		supercharge2 = false;
+		die = false;
+		if (m_creature->HasAura(SPELL_SUPERCHARGE))
+			m_creature->RemoveAurasDueToSpell(SPELL_SUPERCHARGE);
+		if (m_creature->HasAura(SPELL_ELECTRICAL_CHARGE))
+			m_creature->RemoveAurasDueToSpell(SPELL_ELECTRICAL_CHARGE);
+		if (m_creature->HasAura(SPELL_HIGH_VOLTAGE))
+			m_creature->RemoveAurasDueToSpell(SPELL_HIGH_VOLTAGE);
+		if (m_creature->HasAura(SPELL_HIGH_VOLTAGE_H))
+			m_creature->RemoveAurasDueToSpell(SPELL_HIGH_VOLTAGE_H);
+    }
+
+	void KilledUnit(Unit* pVictim)
+    {
+		if (supercharge2)
+			DoCast(m_creature, SPELL_ELECTRICAL_CHARGE);
+
+        if(irand(0,1))
+            DoScriptText(SAY_STEEL_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_STEEL_SLAY2, m_creature);
+    }
+
+	void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+		if (uiDamage > m_creature->GetHealth() && !die)
+		{
+			uiDamage = 0;
+			m_creature->CastStop();
+			m_creature->setFaction(1925);
+			if (supercharge1)
+			{
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+					if (pTemp->isAlive() && pTemp->HasAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0))
+						pTemp->GetAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0)->modStackAmount(+1);
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+					if (pTemp->isAlive() && pTemp->HasAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0))
+						pTemp->GetAura(SPELL_SUPERCHARGE, EFFECT_INDEX_0)->modStackAmount(+1);
+			}else
+				DoCast(m_creature, SPELL_SUPERCHARGE);
+			die_delay = 500;
+			die = true;
+		}
+    }
+
+	void JustDied(Unit* pKiller)
+    {
+		//death yell
+		m_creature->RemoveFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+		m_creature->setFaction(14);
+		Map* pMap = m_creature->GetMap();
+		if (pMap && pMap->IsDungeon())
+		{
+			Map::PlayerList const &PlayerList = pMap->GetPlayers();
+			if (PlayerList.isEmpty())
+				return;
+			for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+			{
+				if (i->getSource()->isAlive() && i->getSource()->HasAura(SPELL_SUPERCHARGE))
+					i->getSource()->RemoveAurasDueToSpell(SPELL_SUPERCHARGE);
+			}
+		}
+        if (m_pInstance)
+		{
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+				if (!pTemp->isAlive())
+					if (Creature* p2Temp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+						if (!p2Temp->isAlive())
+						{
+							m_pInstance->SetData(TYPE_ASSEMBLY, DONE);
+                            m_pInstance->SetData(TYPE_ASSEMBLY_HARD, DONE);
+							m_creature->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+							pTemp->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+							p2Temp->SetFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE);
+
+                            // I'm on your side
+                            Map* pMap = m_creature->GetMap();
+                            AchievementEntry const *AchievYourSide = GetAchievementStore()->LookupEntry(m_bIsRegularMode ? ACHIEV_ON_YOUR_SIDE : ACHIEV_ON_YOUR_SIDE_H);
+                            if(AchievYourSide && pMap)
+                            {
+                                Map::PlayerList const &lPlayers = pMap->GetPlayers();
+                                if (!lPlayers.isEmpty())
+                                {
+                                    for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
+                                    {
+                                        if (Player* pPlayer = itr->getSource())
+                                        {
+                                            if(pPlayer->HasAura(SPELL_IRON_BOOT_AURA, EFFECT_INDEX_0))
+                                                pPlayer->CompletedAchievement(AchievYourSide);
+                                        }
+                                    }
+                                }
+                            }
+
+                            // ChooseSteelbreaker
+                            if(m_pInstance)
+                                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_CHOOSE_STEELBREAKER : ACHIEV_CHOOSE_STEELBREAKER_H);
+						}
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+				if (pTemp->isAlive())
+					pTemp->SetHealth(pTemp->GetMaxHealth());
+			if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+				if (pTemp->isAlive())
+					pTemp->SetHealth(pTemp->GetMaxHealth());
+		}
+
+        if(irand(0,1))
+            DoScriptText(SAY_STEEL_DEATH1, m_creature);
+        else
+            DoScriptText(SAY_STEEL_DEATH2, m_creature);
+    }
+
+	void Aggro(Unit* pWho)
+    {
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+			if (pTemp->isAlive())
+				pTemp->SetInCombatWithZone();
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+			if (pTemp->isAlive())
+				pTemp->SetInCombatWithZone();
+		DoCast(m_creature, m_bIsRegularMode ? SPELL_HIGH_VOLTAGE : SPELL_HIGH_VOLTAGE_H);
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ASSEMBLY, IN_PROGRESS);
+
+        DoScriptText(SAY_STEEL_AGGRO, m_creature);
+    }
+
+	void JustReachedHome()
+    {
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+			if (!pTemp->isAlive())
+				pTemp->Respawn();
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+			if (!pTemp->isAlive())
+				pTemp->Respawn();
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ASSEMBLY, FAIL);
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+		if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Fusion_Punch_Timer < diff)
+        {
+			DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FUSION_PUNCH : SPELL_FUSION_PUNCH_H);
+            Fusion_Punch_Timer = 20000;
+        }else Fusion_Punch_Timer -= diff;
+
+		if (Static_Disruption_Timer < diff && supercharge1)
+		{
+			if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
+				DoCast(pTarget, m_bIsRegularMode ? SPELL_STATIC_DISRUPTION : SPELL_STATIC_DISRUPTION_H);
+			Static_Disruption_Timer = 60000;
+		}else Static_Disruption_Timer -= diff;
+
+		if (Power_Timer < diff && supercharge2)
+		{
+			m_creature->CastStop();
+            DoScriptText(SAY_STEEL_OVERWHELMING, m_creature);
+			DoCast(m_creature->getVictim(), SPELL_POWER);
+			MeltTarget = m_creature->getVictim()->GetGUID();
+			Power_Timer = m_bIsRegularMode ? 65000 : 35000;
+			Meltdown_Timer = m_bIsRegularMode ? 60500 : 30500;
+		}else Power_Timer -= diff;
+
+		if (Meltdown_Timer < diff && supercharge2)
+		{
+			if (Unit* pMeltTarget = Unit::GetUnit(*m_creature, MeltTarget))
+				m_creature->DealDamage(pMeltTarget, pMeltTarget->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+			Meltdown_Timer = 90000;
+		}else Meltdown_Timer -= diff;
+
+		if (die_delay < diff)
+		{
+			if (die)
+				m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+		}
+        else die_delay -= diff;
+
+		if (Enrage_Timer < diff && !enrage)
+		{
+            DoScriptText(SAY_STEEL_BERSERK, m_creature);
+			m_creature->CastStop();
+			DoCast(m_creature, SPELL_BERSERK);
+			enrage = true;
+		}else Enrage_Timer -= diff;
+
+		if (Check < diff)
+		{
+			if (!brundir)
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BRUNDIR))))
+					if (!pTemp->isAlive())
+					{
+						brundir = true;
+						if (!supercharge1)
+						{
+							supercharge1 = true;
+							Static_Disruption_Timer = 12000;
+						}
+						else
+						{
+							supercharge2 = true;
+							Power_Timer = 5000;
+							Meltdown_Timer = m_bIsRegularMode ? 60000 : 30000;
+						}
+					}
+			if (!molgeim)
+				if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MOLGEIM))))
+					if (!pTemp->isAlive())
+					{
+						molgeim = true;
+						if (!supercharge1)
+						{
+							supercharge1 = true;
+							Static_Disruption_Timer = 22000;
+						}
+						else
+						{
+							supercharge2 = true;
+							Power_Timer = 5000;
+							Meltdown_Timer = m_bIsRegularMode ? 60000 : 30000;
+						}
+					}
+			Check = 1000;
+		}else Check -= diff;
+		
+		if (!die)
+			DoMeleeAttackIfReady();
+	}
+};
+
+CreatureAI* GetAI_boss_steelbreaker(Creature* pCreature)
+{
+    return new boss_steelbreakerAI(pCreature);
+}
+
+void AddSC_boss_iron_council()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_brundir";
+    NewScript->GetAI = GetAI_boss_brundir;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "boss_molgeim";
+    NewScript->GetAI = GetAI_boss_molgeim;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "boss_steelbreaker";
+    NewScript->GetAI = GetAI_boss_steelbreaker;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "mob_rune_of_power";
+    NewScript->GetAI = &GetAI_mob_rune_of_power;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "mob_rune_of_summoning";
+    NewScript->GetAI = &GetAI_mob_rune_of_summoning;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "mob_ulduar_lightning_elemental";
+    NewScript->GetAI = &GetAI_mob_ulduar_lightning_elemental;
+    NewScript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_kologarn.cpp b/scripts/northrend/ulduar/ulduar/boss_kologarn.cpp
new file mode 100644
index 0000000..e3c54ee
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_kologarn.cpp
@@ -0,0 +1,604 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_kologarn
+SD%Complete: 85%
+SDComment: stone grip
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    //yells
+    SAY_AGGRO           = -1603150,
+    SAY_SHOCKWEAVE      = -1603151,
+    SAY_GRAB            = -1603152,
+    SAY_LEFT_ARM_LOST   = -1603153,
+    SAY_RIGHT_ARM_LOST  = -1603154,
+    SAY_SLAY1           = -1603155,
+    SAY_SLAY2           = -1603156,
+    SAY_BERSERK         = -1603157,
+    SAY_DEATH           = -1603158,
+
+    //kologarn
+    SPELL_OVERHEAD_SMASH		= 63356,
+    SPELL_OVERHEAD_SMASH_H		= 64003,
+    SPELL_ONE_ARMED_SMASH		= 63573,
+    SPELL_ONE_ARMED_SMASH_H		= 64006,
+    SPELL_STONE_SHOUT			= 63716,
+    SPELL_STONE_SHOUT_H			= 64005,
+    SPELL_PETRIFYING_BREATH		= 62030,
+    SPELL_PETRIFYING_BREATH_H	= 63980,
+    SPELL_FOCUSED_EYEBEAN       = 63346,
+    SPELL_FOCUSED_EYEBEAN_H     = 63976,
+    SPELL_FOCUSED_EYEBEAN_VISUAL= 63368,
+    SPELL_ENRAGE                = 26662,
+    //left arm
+    SPELL_SHOCKWAVE				= 63783,
+    SPELL_SHOCKWAVE_H			= 63982,
+    //right arm
+    SPELL_STONE_GRIP			= 62166,
+    SPELL_STONE_GRIP_H			= 63981,
+    //both
+    SPELL_ARM_VISUAL			= 64753,
+    //rubble
+    SPELL_RUMBLE				= 63818,
+    SPELL_STONE_NOVA			= 63978,
+    //NPC ids
+    MOB_RUBBLE					= 33768, 
+
+    ACHIEV_RUBBLE_AND_ROLL      = 2959,
+    ACHIEV_RUBBLE_AND_ROLL_H    = 2960,
+    ACHIEV_WITH_OPEN_ARMS       = 2951,
+    ACHIEV_WITH_OPEN_ARMS_H     = 2952,
+    ACHIEV_DISARMED             = 2953,
+    ACHIEV_DISARMED_H           = 2954,
+};
+
+float LeftArm[3] = {1767.636f, -47.970f, 448.805f};
+float RightArm[3] = {1769.671f, 1.514f, 448.810f};
+const float KoloFront[3] = {1771.683f, -24.230f, 448.806f};
+
+bool m_bIsLeftDead;
+bool m_bIsRightDead;
+
+// Rubble
+struct MANGOS_DLL_DECL mob_ulduar_rubbleAI : public ScriptedAI
+{
+    mob_ulduar_rubbleAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        Reset();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 Stone_Nova_Timer;
+    uint32 Death_Timer;
+
+    bool die;
+
+    void Reset()
+    {
+        die = false;
+        Stone_Nova_Timer = urand(8000, 12000);
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+        if (uiDamage > m_creature->GetHealth())
+            if (!die)
+            {
+                uiDamage = 0;
+                DoCast(m_creature, SPELL_RUMBLE);
+                Death_Timer = 500;
+                die = true;
+            }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (Death_Timer < diff && die)
+        {
+            m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Death_Timer -= diff;
+
+        if (Stone_Nova_Timer < diff && !die)
+        {
+            DoCast(m_creature, SPELL_STONE_NOVA);
+            Stone_Nova_Timer = urand(7000, 9000);
+        }else Stone_Nova_Timer -= diff;
+
+        if (!die)
+            DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_ulduar_rubble(Creature* pCreature)
+{
+    return new mob_ulduar_rubbleAI(pCreature);
+}
+
+// Left Arm
+struct MANGOS_DLL_DECL boss_left_armAI : public ScriptedAI
+{
+    boss_left_armAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+        SetCombatMovement(false);
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 Shockwave_Timer;
+
+    void Reset()
+    {
+        Shockwave_Timer = 30000;
+        DoCast(m_creature, SPELL_ARM_VISUAL);
+
+        m_bIsLeftDead = false;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+        {
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIGHT_ARM))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KOLOGARN))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+        }
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_LEFT_ARM_LOST, m_creature);
+        if (!m_pInstance)
+            return;
+        if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KOLOGARN))))
+        {
+            if (pTemp->isAlive())
+                pTemp->DealDamage(pTemp, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+
+        m_bIsLeftDead = true;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Shockwave_Timer < diff)
+        {
+            DoScriptText(SAY_SHOCKWEAVE, m_creature);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_SHOCKWAVE : SPELL_SHOCKWAVE_H);
+            Shockwave_Timer = 30000;
+        }else Shockwave_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_left_arm(Creature* pCreature)
+{
+    return new boss_left_armAI(pCreature);
+}
+
+// Right Arm
+struct MANGOS_DLL_DECL boss_right_armAI : public ScriptedAI
+{
+    boss_right_armAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+        SetCombatMovement(false);
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
+
+    uint32 Stone_Grip_Timer;
+    uint32 gripdmg;
+    uint32 freedmg;
+    uint64 GripTarget;
+
+    bool grip;
+
+    void Reset()
+    {
+        Stone_Grip_Timer = 20000;
+        GripTarget = 0;
+        gripdmg = 0;
+        freedmg = 0;
+        grip = false;
+        DoCast(m_creature, SPELL_ARM_VISUAL);
+
+        m_bIsRightDead = false;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+        {
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEFT_ARM))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KOLOGARN))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+        }
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+        if (grip)
+        {
+            gripdmg += uiDamage;
+            freedmg = m_bIsRegularMode ? 100000 : 480000;
+            if (gripdmg > freedmg || uiDamage > m_creature->GetHealth())
+            {
+                if (Unit* pGripTarget = Unit::GetUnit(*m_creature, GripTarget)){
+                    if (pGripTarget->HasAura(SPELL_STONE_GRIP))
+                        pGripTarget->RemoveAurasDueToSpell(SPELL_STONE_GRIP);
+                    if (pGripTarget->HasAura(SPELL_STONE_GRIP_H))
+                        pGripTarget->RemoveAurasDueToSpell(SPELL_STONE_GRIP_H);
+                }
+                grip = false;
+                gripdmg = 0;
+            }
+        }
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_RIGHT_ARM_LOST, m_creature);
+        if (!m_pInstance)
+            return;
+        if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KOLOGARN))))
+        {
+            if (pTemp->isAlive())
+                pTemp->DealDamage(pTemp, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+
+        m_bIsRightDead = true;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Stone_Grip_Timer < diff)
+        {
+            DoScriptText(SAY_GRAB, m_creature);
+            //stone grip emote
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0)){
+                //DoCast(target, m_bIsRegularMode ? SPELL_STONE_GRIP : SPELL_STONE_GRIP_H);
+                GripTarget = target->GetGUID();
+                grip = true;
+                gripdmg = 0;
+            }
+            Stone_Grip_Timer = 30000;
+        }else Stone_Grip_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_right_arm(Creature* pCreature)
+{
+    return new boss_right_armAI(pCreature);
+}
+
+// Kologarn
+struct MANGOS_DLL_DECL boss_kologarnAI : public ScriptedAI
+{
+    boss_kologarnAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 Spell_Timer;
+    uint32 Check_Timer;
+    uint32 Eyebeah_Timer;
+    uint32 respawnright;
+    uint32 respawnleft;
+    uint32 EnrageTimer;
+
+    uint32 m_uiRubbleNo;
+    bool m_bHasLeftDied;
+    bool m_bHasRightDied;
+    bool m_bDisarmedCheck;
+    uint32 m_uiDisarmedTimer;
+
+    bool right;
+    bool left;
+
+    void Reset()
+    {
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+        Spell_Timer = 10000;
+        Check_Timer = 6300;
+        EnrageTimer = 600000;
+        Eyebeah_Timer = 10000 + urand(1000, 5000);
+        right = true;
+        left = true;
+
+        m_uiRubbleNo = 0;
+        m_bHasLeftDied  = false;
+        m_bHasRightDied = false;
+        m_bDisarmedCheck = false;
+        m_uiDisarmedTimer = 0;
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+
+        // Rubble and roll
+        if (m_uiRubbleNo >= 25)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_RUBBLE_AND_ROLL : ACHIEV_RUBBLE_AND_ROLL_H);
+        }
+
+        // With open arms
+        if (!m_bHasRightDied && !m_bHasLeftDied)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_WITH_OPEN_ARMS : ACHIEV_WITH_OPEN_ARMS_H);
+        }
+
+        // Disarmed
+        if (m_bIsLeftDead && m_bIsRightDead && m_uiDisarmedTimer <= 12000)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_DISARMED : ACHIEV_DISARMED_H);
+        }
+
+        //death yell
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_KOLOGARN, DONE);
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEFT_ARM))))
+                if (pTemp->isAlive())
+                    pTemp->DealDamage(pTemp, pTemp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIGHT_ARM))))
+                if (pTemp->isAlive())
+                    pTemp->DealDamage(pTemp, pTemp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_KOLOGARN, IN_PROGRESS);
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEFT_ARM))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIGHT_ARM))))
+                if (pTemp->isAlive())
+                    pTemp->SetInCombatWithZone();
+        }
+        //aggro yell
+        DoScriptText(SAY_AGGRO, m_creature);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_KOLOGARN, FAIL);
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEFT_ARM))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIGHT_ARM))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Spell_Timer < diff)
+        {
+            if (right && left)
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_OVERHEAD_SMASH : SPELL_OVERHEAD_SMASH_H);
+            else
+                if (!right && !left)
+                    DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_STONE_SHOUT : SPELL_STONE_SHOUT_H);
+                else
+                    DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_ONE_ARMED_SMASH : SPELL_ONE_ARMED_SMASH_H);
+            Spell_Timer = 20000;
+        }else Spell_Timer -= diff;   
+
+        /* to be fixed!
+        if (Eyebeah_Timer < diff)
+        {
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+            {
+                DoCast(target, SPELL_FOCUSED_EYEBEAN_VISUAL);
+                DoCast(target, m_bIsRegularMode ? SPELL_FOCUSED_EYEBEAN : SPELL_FOCUSED_EYEBEAN_H, true);
+            }
+            Eyebeah_Timer = 20000;
+        }else Eyebeah_Timer -= diff;
+        */
+
+        if (respawnleft < diff && !left)
+        {
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEFT_ARM))))
+                if (!pTemp->isAlive())
+                {
+                    pTemp->Respawn();
+                    left = true;
+                    m_bDisarmedCheck = false;
+                    m_bIsLeftDead = false;
+                }
+        }else respawnleft -= diff;  
+
+        if (respawnright < diff && !right)
+        {
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIGHT_ARM))))
+                if (!pTemp->isAlive())
+                {
+                    pTemp->Respawn();
+                    right = true;
+                    m_bDisarmedCheck = false;
+                    m_bIsRightDead = false;
+                }
+        }else respawnright -= diff; 
+
+        if (Check_Timer < diff)
+        {
+            if (Creature* lArm = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEFT_ARM))))
+            {
+                if (!lArm->isAlive() && left)
+                {
+                    m_bHasLeftDied = true;
+                    m_bDisarmedCheck = true;
+                    m_uiDisarmedTimer = 0;
+
+                    for(uint8 i = 0; i < 5; i ++)
+                    {
+                        if(Creature* pRubble = m_creature->SummonCreature(MOB_RUBBLE, LeftArm[0] + urand(5, 15), LeftArm[1] + urand(0, 10), LeftArm[2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                        {
+                            pRubble->GetMotionMaster()->MovePoint(0, KoloFront[0], KoloFront[1], KoloFront[2]);
+
+                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            {
+                                pRubble->AddThreat(pTarget,0.0f);
+                                pRubble->AI()->AttackStart(pTarget);
+                                pRubble->SetInCombatWithZone();
+                            }
+
+                            m_uiRubbleNo++;
+                        }
+                    }
+                    left = false;
+                    respawnleft = 50000;
+                }
+            }
+            if (Creature* rArm = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIGHT_ARM))))
+            {
+                if (!rArm->isAlive() && right)
+                {
+                    m_bHasRightDied = true;
+                    m_bDisarmedCheck = true;
+                    m_uiDisarmedTimer = 0;
+
+                    for(uint8 i = 0; i < 5; i ++)
+                    {
+                        if(Creature* pRubble = m_creature->SummonCreature(MOB_RUBBLE, RightArm[0] + urand(5, 15), RightArm[1] + urand(0, 10), RightArm[2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                        {
+                            pRubble->GetMotionMaster()->MovePoint(0, KoloFront[0], KoloFront[1], KoloFront[2]);
+
+                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            {
+                                pRubble->AddThreat(pTarget,0.0f);
+                                pRubble->AI()->AttackStart(pTarget);
+                                pRubble->SetInCombatWithZone();
+                            }
+
+                            m_uiRubbleNo++;
+                        }
+                    }
+                    right = false;
+                    respawnright = 50000;
+                }
+            }
+
+            //Petrifying breath
+            if (!m_creature->IsWithinDistInMap(m_creature->getVictim(), 10))
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_PETRIFYING_BREATH : SPELL_PETRIFYING_BREATH_H);
+
+            Check_Timer = 500;
+        }else Check_Timer -= diff;
+
+        // disarmed achiev check
+        if (m_bIsRightDead || m_bIsLeftDead)
+            m_uiDisarmedTimer += diff;
+
+        if(EnrageTimer < diff)
+        {
+            DoScriptText(SAY_BERSERK, m_creature);
+            DoCast(m_creature, SPELL_ENRAGE);
+            EnrageTimer = 30000;
+        }
+        else EnrageTimer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_kologarn(Creature* pCreature)
+{
+    return new boss_kologarnAI(pCreature);
+}
+
+void AddSC_boss_kologarn()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_kologarn";
+    NewScript->GetAI = GetAI_boss_kologarn;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_ulduar_rubble";
+    NewScript->GetAI = &GetAI_mob_ulduar_rubble;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "boss_left_arm";
+    NewScript->GetAI = &GetAI_boss_left_arm;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "boss_right_arm";
+    NewScript->GetAI = &GetAI_boss_right_arm;
+    NewScript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_leviathan.cpp b/scripts/northrend/ulduar/ulduar/boss_leviathan.cpp
new file mode 100644
index 0000000..af62822
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_leviathan.cpp
@@ -0,0 +1,380 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_leviathan
+SD%Complete: 40%
+SDComment: implement vehicules, implement towers, implement passive Ai scripts
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+#include "Vehicle.h"
+
+enum say
+{
+    SAY_AGGRO           = -1603203,
+    SAY_DEATH           = -1603202,
+    SAY_SLAY            = -1603201,
+    SAY_CHANGE1         = -1603204,
+    SAY_CHANGE2         = -1603205,
+    SAY_CHANGE3         = -1603206,
+    SAY_PLAYER_ON_TOP   = -1603207,
+    SAY_OVERLOAD1       = -1603208,
+    SAY_OVERLOAD2       = -1603209,
+    SAY_OVERLOAD3       = -1603210,
+    SAY_HARD_MODE       = -1603211,
+    SAY_TOWERS_DOWN     = -1603212,
+    SAY_FROST_TOWER     = -1603213,
+    SAY_FIRE_TOWER      = -1603214,
+    SAY_ENERGY_TOWER    = -1603215,
+    SAY_NATURE_TOWER    = -1603216
+
+};
+
+enum spells
+{
+    SPELL_PURSUED           = 62374,
+
+    SPELL_MISSILE_BARRAGE   = 62400,
+    SPELL_FLAME_VENTS       = 62396,
+    SPELL_BATTERING_RAM     = 62376,
+
+    SPELL_GATHERING_SPEED   = 62375,
+    // interupted by
+    SPELL_OVERLOAD_CIRCUIT  = 62399,
+
+    SPELL_SEARING_FLAME     = 62402, // used by defense turret
+    // interuptec by
+    SPELL_SYSTEMS_SHUTDOWN  = 62475,
+
+    SPELL_FLAME_CANNON      = 62395,
+    //SPELL_FLAME_CANNON    = 64692, trigger the same spell
+    SPELL_BLAZE             = 62292,
+
+    // used by players -> to be added later
+    SPELL_ELECTROSHOCK      = 62522,
+    SPELL_SMOKE_TRAIL       = 63575,
+
+    // tower of nature
+    SPELL_FREYAS_WARD       = 62906,
+    SPELL_TOWER_OF_LIFE     = 64482,
+    // tower of flames
+    SPELL_MIMIRON_INFERNO   = 62910,
+    SPELL_TOWER_OF_FLAMES   = 65075,
+    // tower of frost
+    SPELL_HODIR_FURY        = 62297, // also + 10% hp
+    // tower of storms
+    SPELL_THORIMS_HAMMER    = 62912,
+    SPELL_TOWER_OF_STORMS   = 65076
+};
+
+enum Mobs
+{
+    MOB_MECHANOLIFT     = 33214,
+    MOB_LIQUID          = 33189,
+    MOB_CONTAINER       = 33218,
+
+    DEFENSE_TURRET      = 33142,
+    KEEPER_OF_NORGANNON = 33686
+};
+
+enum Seats
+{
+    SEAT_PLAYER = 0,
+    SEAT_TURRET = 1,
+    SEAT_DEVICE = 2,
+};
+
+
+struct MANGOS_DLL_DECL boss_flame_leviathan : public ScriptedAI
+{
+    boss_flame_leviathan(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Regular = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->setFaction(35);  // remove this when vehicules fixed!
+        //assert(vehicle);
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    //Vehicle *vehicle;
+    bool Regular;
+
+    uint32 BatteringRamTimer;
+    uint32 FlameVentsTimer;
+    uint32 MissileBarrageTimer;
+    uint32 PursueTimer;
+    uint32 GatheringSpeedTimer;
+    uint32 SummonFlyerTimer;
+    uint8 maxFlyers;
+
+    bool isHardMode;
+    bool isHodirsTower;
+    bool isFreyasTower;
+    bool isMimironsTower;
+    bool isThorimsTower;
+
+    uint32 FreyaWardTimer;
+    uint32 MimironInfernoTimer;
+    uint32 HodirFuryTimer;
+    uint32 ThorimHammerTimer;
+
+    void Reset()
+    {
+        BatteringRamTimer = 15000 + rand()%20000;
+        FlameVentsTimer = 20000 + rand()%10000;
+        MissileBarrageTimer = 1000;
+        PursueTimer = 30000;
+        GatheringSpeedTimer = 50000;
+        SummonFlyerTimer = 2000;
+        maxFlyers = 10;
+
+        isHardMode      = false;
+        isHodirsTower   = false;
+        isFreyasTower   = false;
+        isMimironsTower = false;
+        isThorimsTower  = false;
+
+        FreyaWardTimer = 40000 + urand(1000, 10000);
+        MimironInfernoTimer = 40000 + urand(1000, 10000);
+        HodirFuryTimer = 40000 + urand(1000, 10000);
+        ThorimHammerTimer = 40000 + urand(1000, 10000);
+
+        if(pInstance) 
+            pInstance->SetData(TYPE_LEVIATHAN, NOT_STARTED);
+
+        m_creature->SetSpeedRate(MOVE_RUN,0.3f);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(pInstance) 
+            pInstance->SetData(TYPE_LEVIATHAN, IN_PROGRESS);
+
+        DoScriptText(SAY_AGGRO, m_creature);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        if(pInstance) 
+        {
+            pInstance->SetData(TYPE_LEVIATHAN, DONE);
+            if(isHardMode)
+                pInstance->SetData(TYPE_LEVIATHAN_HARD, DONE);
+        }
+
+        DoScriptText(SAY_DEATH, m_creature);
+    }
+
+    void KilledUnit(Unit *who)
+    {
+        DoScriptText(SAY_SLAY, m_creature);
+    }
+
+    // TODO: effect 0 and effect 1 may be on different target
+    void SpellHitTarget(Unit *pTarget, const SpellEntry *spell)
+    {
+        if (spell->Id == SPELL_PURSUED)
+            AttackStart(pTarget);
+    }
+
+    void SpellHit(Unit *caster, const SpellEntry *spell)
+    {
+        /*if(spell->Id == 62472)
+        vehicle->InstallAllAccessories();
+        else if(spell->Id == SPELL_ELECTROSHOCK)
+        m_creature->InterruptSpell(CURRENT_CHANNELED_SPELL);*/
+    }
+
+    void DamageTaken(Unit *pDoneBy, uint32 &dmg)
+    {
+        dmg *= 4;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        // pursue
+        if(PursueTimer < diff)
+        {
+            switch(urand(0, 3))
+            {
+                case 0: DoScriptText(SAY_CHANGE1, m_creature); break;
+                case 1: DoScriptText(SAY_CHANGE2, m_creature); break;
+                case 2: DoScriptText(SAY_CHANGE3, m_creature); break;
+            }
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, SPELL_PURSUED);
+
+            PursueTimer = 30000;
+        }
+        else PursueTimer -= diff;
+
+        // flame vents
+        if(FlameVentsTimer < diff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_FLAME_VENTS);
+            FlameVentsTimer = 30000 + rand()%20000;
+        }
+        else FlameVentsTimer -= diff;
+
+        // battering ram
+        if(BatteringRamTimer < diff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_BATTERING_RAM);
+            BatteringRamTimer = 25000 + rand()%15000;
+        }
+        else BatteringRamTimer -= diff;
+
+        /* flyers
+        if(SummonFlyerTimer < diff)
+        {
+        m_creature->SummonCreature(MOB_MECHANOLIFT, m_creature->GetPositionX() + rand()%20, m_creature->GetPositionY() + rand()%20, m_creature->GetPositionZ() + 50, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 40000);
+        SummonFlyerTimer = 2000;
+        }
+        else SummonFlyerTimer -= diff;*/
+
+        // missile barrage
+        if(MissileBarrageTimer < diff)
+        {
+            for(uint8 i = 0; i < 5; i++)
+            {
+                Unit *target = SelectUnit(SELECT_TARGET_RANDOM, 0);
+                int32 dmg = Regular ? (3000 + rand()%2000) : (2000 + rand()%1200);
+                if(target && target->isAlive())
+                    m_creature->CastCustomSpell(target, SPELL_MISSILE_BARRAGE, &dmg, 0, 0, false);
+            }
+            MissileBarrageTimer = 3000 + rand()%2000;
+        }
+        else MissileBarrageTimer -= diff;
+
+        // tower of freya
+        if(isFreyasTower)
+        {
+            DoCast(m_creature, SPELL_TOWER_OF_LIFE);
+
+            if(FreyaWardTimer < diff)
+            {
+                DoCast(m_creature, SPELL_FREYAS_WARD);
+                FreyaWardTimer = 40000 + urand(1000, 10000);
+            }
+            else FreyaWardTimer -= diff;
+        }
+
+        // tower of mimiron
+        if(isMimironsTower)
+        {
+            DoCast(m_creature, SPELL_TOWER_OF_FLAMES);
+
+            if(MimironInfernoTimer < diff)
+            {
+                DoCast(m_creature, SPELL_FREYAS_WARD);
+                MimironInfernoTimer = 40000 + urand(1000, 10000);
+            }
+            else MimironInfernoTimer -= diff;
+        }
+
+        // tower of hodir
+        if(isHodirsTower)
+        {
+            m_creature->SetHealth(m_creature->GetHealth() + 0.1* m_creature->GetHealth());
+
+            if(HodirFuryTimer < diff)
+            {
+                DoCast(m_creature, SPELL_HODIR_FURY);
+                HodirFuryTimer = 40000 + urand(1000, 10000);
+            }
+            else HodirFuryTimer -= diff;
+        }
+
+        // tower of thorim
+        if(isThorimsTower)
+        {
+            DoCast(m_creature, SPELL_TOWER_OF_STORMS);
+
+            if(ThorimHammerTimer < diff)
+            {
+                DoCast(m_creature, SPELL_THORIMS_HAMMER);
+                ThorimHammerTimer = 40000 + urand(1000, 10000);
+            }
+            else ThorimHammerTimer -= diff;
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_defense_turretAI : public ScriptedAI
+{
+    mob_defense_turretAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+
+    uint32 Spell_Timer;
+
+    void Reset()
+    {
+        Spell_Timer = urand(10000, 15000);
+    }
+
+    void SpellHit(Unit *caster, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_SYSTEMS_SHUTDOWN)
+            m_creature->ForcedDespawn();
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Spell_Timer < diff)
+        {
+            DoCast(m_creature, SPELL_SEARING_FLAME);
+            Spell_Timer = urand(10000, 15000);
+        }else Spell_Timer -= diff;        
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_defense_turret(Creature* pCreature)
+{
+    return new mob_defense_turretAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_flame_leviathan(Creature* pCreature)
+{
+    return new boss_flame_leviathan(pCreature);
+}
+
+void AddSC_boss_leviathan()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_flame_leviathan";
+    newscript->GetAI = &GetAI_boss_flame_leviathan;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_defense_turret";
+    newscript->GetAI = &GetAI_mob_defense_turret;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/ulduar/ulduar/boss_mimiron.cpp b/scripts/northrend/ulduar/ulduar/boss_mimiron.cpp
new file mode 100644
index 0000000..6a8c67f
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_mimiron.cpp
@@ -0,0 +1,1736 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_mimiron
+SD%Complete: 75%
+SDComment: Put the robot's pieces together; Implement fires in hard mode
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    //yells
+    SAY_AGGRO           = -1603241,
+    SAY_HARD_MODE       = -1603242,
+    SAY_BERSERK         = -1603243,
+    SAY_TANK_ACTIVE     = -1603244,
+    SAY_TANK_SLAY1      = -1603245,
+    SAY_TANK_SLAY2      = -1603246,
+    SAY_TANK_DEATH      = -1603247,
+    SAY_TORSO_ACTIVE    = -1603248,
+    SAY_TORSO_SLAY1     = -1603249,
+    SAY_TORSO_SLAY2     = -1603250,
+    SAY_TORSO_DEATH     = -1603251,
+    SAY_HEAD_ACTIVE     = -1603252,
+    SAY_HEAD_SLAY1      = -1603253,
+    SAY_HEAD_SLAY2      = -1603254,
+    SAY_HEAD_DEATH      = -1603255,
+    SAY_ROBOT_ACTIVE    = -1603256,
+    SAY_ROBOT_SLAY1     = -1603257,
+    SAY_ROBOT_SLAY2     = -1603258,
+    SAY_ROBOT_DEATH     = -1603259,
+
+    //spells
+    //leviathan
+    SPELL_PROXIMITY_MINES   = 63016, // also in phase 4
+    MOB_PROXIMITY_MINE      = 34362,
+    SPELL_EXPLOSION         = 66351,
+    SPELL_EXPLOSION_H       = 63009,
+    SPELL_NAPALM_SHELL      = 63666,
+    SPELL_NAPALM_SHELL_H    = 65026,
+    SPELL_PLASMA_BLAST      = 62997,
+    SPELL_PLASMA_BLAST_H    = 64529,
+    SPELL_SHOCK_BLAST       = 63631, // also in phase 4
+    LEVIATHAN_TURRET        = 34071,
+
+    //vx001
+    SPELL_RAPID_BURST       = 63387,
+    SPELL_RAPID_BURST_H     = 64531,
+    SPELL_LASER_BARRAGE     = 63293, // also in phase 4
+    SPELL_ROCKET_STRIKE     = 63041, // also in phase 4
+    SPELL_HEAT_WAVE         = 63677,
+    SPELL_HEAT_WAVE_H       = 64533,
+    SPELL_HAND_PULSE        = 64348, // only in phase 4
+    SPELL_HAND_PULSE_H      = 64536,
+
+    //aerial unit
+    SPELL_PLASMA_BALL       = 63689, // also in phase 4
+    SPELL_PLASMA_BALL_H     = 64535, // also in phase 4
+    MOB_ASSALT_BOT          = 34057,
+    MOB_BOMB_BOT            = 33836,
+    MOB_BOMB_BOT_321        = 33346,
+    MOB_BOMB_BOT_500        = 34192,
+    MOB_JUNK_BOT            = 33855,
+    SPELL_MAGNETIC_CORE     = 64444,
+    MOB_MAGNETIC_CORE       = 34068,
+    ITEM_MAGNETIC_CORE      = 46029,
+
+    //hard mode
+    // summons fires
+    SPELL_EMERGENCY_MODE    = 64582,
+    SPELL_FROST_BOMB        = 64627,
+    MOB_FROST_BOMB          = 34149,
+    MOB_EMERGENCY_FIRE_BOT  = 34147,
+    SPELL_DEAFENING_SIREN   = 64616,
+    SPELL_WATER_SPRAY       = 64619,
+
+    SPELL_BERSERK           = 26662,
+};
+
+#define CENTER_X            2744.732f
+#define CENTER_Y            2569.479f
+#define CENTER_Z            364.312f 
+
+const float PosTankHome[2]= {2794.86f, 2597.83f};
+struct LocationsXY
+{
+    float x, y;
+    uint32 id;
+};
+static LocationsXY SummonLoc[]=
+{
+    {2753.665f, 2584.712f},
+    {2754.150f, 2554.445f},
+    {2726.966f, 2569.032f},
+    {2759.085f, 2594.249f},
+    {2759.977f, 2544.345f},
+    {2715.542f, 2569.160f},
+    {2765.070f, 2604.337f},
+    {2765.676f, 2534.558f},
+    {2703.810f, 2569.132f},
+};
+
+struct MANGOS_DLL_DECL boss_leviathan_mkAI : public ScriptedAI
+{   
+    boss_leviathan_mkAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->setFaction(35);
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    bool isPhase4;
+
+    uint32 minesTimer;
+    uint32 napalmTimer;
+    uint32 plasmaBlastTimer;
+    uint32 shockBlastTimer;
+    Creature* Tank;
+
+    // intro & outro
+    bool isOutro;
+    uint32 OutroTimer;
+    uint32 Step;
+
+    bool isEventFinished;
+
+    // dist for mines
+    double distX;
+    double distY;
+
+    void Reset()
+    {
+        isPhase4 = false;
+
+        minesTimer      = 10000;
+        napalmTimer     = 20000;
+        plasmaBlastTimer= 10000;
+        shockBlastTimer = 30000;
+
+        isEventFinished = false;
+
+        OutroTimer          = 10000;
+        Step                = 1;
+        isOutro             = false;
+        m_creature->setFaction(35);
+
+        distX = 10;
+        distY = 0;
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_LEVIATHAN_MK, NOT_STARTED);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_LEVIATHAN_MK, IN_PROGRESS);
+
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+    }
+
+    void DoOutro()
+    {
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_LEVIATHAN_MK, DONE);
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > m_creature->GetHealth())
+        {
+            if(!isPhase4)
+            {
+                uiDamage = 0;
+                isOutro = true;
+            }
+            else
+            {
+                uiDamage = 0;
+                m_creature->SetHealth(0);
+                m_creature->InterruptNonMeleeSpells(true);
+                m_creature->RemoveAllAuras();
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_creature->GetMotionMaster()->MovementExpired(false);
+                m_creature->GetMotionMaster()->MoveIdle();
+                m_creature->SetStandState(UNIT_STAND_STATE_DEAD);
+
+                if(m_pInstance) 
+                    m_pInstance->SetData(TYPE_LEVIATHAN_MK, SPECIAL);
+
+                isEventFinished = true;
+            }
+        }
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if (Creature* pMimiron = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON))))
+        {
+            if(!isPhase4)
+            {
+                if(irand(0,1))
+                    DoScriptText(SAY_TANK_SLAY1, pMimiron);
+                else
+                    DoScriptText(SAY_TANK_SLAY2, pMimiron);
+            }
+            else
+            {
+                if(!isEventFinished)
+                {
+                    if(irand(0,1))
+                        DoScriptText(SAY_ROBOT_SLAY1, pMimiron);
+                    else
+                        DoScriptText(SAY_ROBOT_SLAY2, pMimiron);
+                }
+            }
+        }
+    }
+
+    void SetPhase()
+    {
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        isPhase4 = true;
+        isOutro = false;
+        minesTimer      = 10000;
+        shockBlastTimer = 30000;
+        // look like a robot
+        SetCombatMovement(false);
+    }
+
+    void Repair()
+    {
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        m_creature->SetHealth(m_creature->GetMaxHealth() * 0.5);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+        m_creature->AI()->AttackStart(m_creature->getVictim());
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_LEVIATHAN_MK, IN_PROGRESS);
+
+        isEventFinished = false;
+        SetPhase();
+    }
+
+    void SelfDestruct()
+    {
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+        m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+    }
+
+    void SummonProximityMinesFirst()
+    {
+        for(uint8 i = 0; i < 4; i++)
+        {
+            m_creature->SummonCreature(MOB_PROXIMITY_MINE, m_creature->GetPositionX() + distX, m_creature->GetPositionY() + distY, m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+            distX -= 2.5;
+            distY += 2.5;
+        }
+    }
+
+    void SummonProximityMinesSecond()
+    {
+        for(uint8 i = 0; i < 4; i++)
+        {
+            m_creature->SummonCreature(MOB_PROXIMITY_MINE, m_creature->GetPositionX() - distX, m_creature->GetPositionY() + distY, m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+            distX -= 2.5;
+            distY += 2.5;
+        }
+    }
+
+    void SummonProximityMinesThird()
+    {
+        for(uint8 i = 0; i < 4; i++)
+        {
+            m_creature->SummonCreature(MOB_PROXIMITY_MINE, m_creature->GetPositionX() + distX, m_creature->GetPositionY() - distY, m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+            distX -= 2.5;
+            distY += 2.5;
+        }
+    }
+
+    void SummonProximityMinesForth()
+    {
+        for(uint8 i = 0; i < 4; i++)
+        {
+            m_creature->SummonCreature(MOB_PROXIMITY_MINE, m_creature->GetPositionX() - distX, m_creature->GetPositionY() - distY, m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+            distX -= 2.5;
+            distY += 2.5;
+        }
+    }
+
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!isOutro)
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+
+            if(minesTimer < diff && !isEventFinished)
+            {
+                //DoCast(m_creature, SPELL_PROXIMITY_MINES);
+                distX = 10; distY = 0;
+                SummonProximityMinesFirst();
+                distX = 10; distY = 0;
+                SummonProximityMinesSecond();
+                distX = 10; distY = 0;
+                SummonProximityMinesThird();
+                distX = 10; distY = 0;
+                SummonProximityMinesForth();
+                minesTimer = 30000;
+            }
+            else minesTimer -= diff;
+
+            if(plasmaBlastTimer < diff && !isPhase4)
+            {
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, m_bIsRegularMode ? SPELL_PLASMA_BLAST : SPELL_PLASMA_BLAST_H);
+                plasmaBlastTimer = 35000;
+            }
+            else plasmaBlastTimer -= diff;
+
+            if(napalmTimer < diff && !isPhase4)
+            {
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    if(!m_creature->IsWithinDistInMap(pTarget, 15))
+                        DoCast(pTarget, m_bIsRegularMode ? SPELL_NAPALM_SHELL : SPELL_NAPALM_SHELL_H);
+                napalmTimer = urand (5000, 10000);
+            }
+            else napalmTimer -= diff;
+
+            if(shockBlastTimer < diff  && !isEventFinished)
+            {
+                DoCast(m_creature, SPELL_SHOCK_BLAST);
+                shockBlastTimer = 40000;
+            }
+            else shockBlastTimer -= diff;
+
+            DoMeleeAttackIfReady();
+        }
+        // outro
+        if(isOutro)
+        {
+            switch(Step)
+            {
+            case 1:
+                Tank = m_creature;
+                Tank->setFaction(35);
+                Tank->RemoveAllAuras();
+                Tank->DeleteThreatList();
+                Tank->CombatStop(true);
+                Tank->InterruptNonMeleeSpells(false);
+                Tank->SetHealth(Tank->GetMaxHealth());
+                Tank->GetMotionMaster()->MovePoint(0, PosTankHome[0], PosTankHome[1], CENTER_Z); 
+                Tank->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                if (Creature* pMimiron = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON))))
+                    DoScriptText(SAY_TANK_DEATH, pMimiron);
+                ++Step;
+                OutroTimer = 12000;
+                break;
+            case 3:
+                DoOutro();
+                ++Step;
+                OutroTimer = 3000;
+                break;
+            }
+        }
+        else return;
+
+        if (OutroTimer <= diff)
+        {
+            ++Step;
+            OutroTimer = 330000;
+        } OutroTimer -= diff;
+    }
+};
+
+struct MANGOS_DLL_DECL boss_vx001AI : public ScriptedAI
+{   
+    boss_vx001AI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 rapidBurstTimer;
+    uint32 laserBarrageTimer;
+    uint32 rocketStrikeTimer;
+    uint32 heatWaveTimer;
+    uint32 handPulseTimer;
+
+    bool isPhase4;
+    bool isEventFinished;
+
+    void Reset()
+    {
+        isPhase4 = false;
+        isEventFinished = false;
+
+        rapidBurstTimer     = 1000;
+        laserBarrageTimer   = 60000;
+        rocketStrikeTimer   = 25000;
+        heatWaveTimer       = 20000;
+        handPulseTimer      = 1000;
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_VX001, NOT_STARTED);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_VX001, IN_PROGRESS);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if (Creature* pMimiron = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON))))
+        {
+            if(!isPhase4)
+            {
+                if(irand(0,1))
+                    DoScriptText(SAY_TORSO_SLAY1, pMimiron);
+                else
+                    DoScriptText(SAY_TORSO_SLAY2, pMimiron);
+            }
+            else
+            {
+                if(!isEventFinished)
+                {
+                    if(irand(0,1))
+                        DoScriptText(SAY_ROBOT_SLAY1, pMimiron);
+                    else
+                        DoScriptText(SAY_ROBOT_SLAY2, pMimiron);
+                }
+            }
+        }
+    }
+
+    void SetPhase()
+    {
+        //SetCombatMovement(true);
+        isPhase4 = true;
+        laserBarrageTimer   = 60000;
+        rocketStrikeTimer   = 25000;
+        handPulseTimer      = 1000;
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_VX001, IN_PROGRESS);
+
+        // look like a robot
+        m_creature->GetMotionMaster()->MoveIdle();
+        SetCombatMovement(false);
+        m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  3, 0.0f);
+        m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  3, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if(!isEventFinished)
+        {
+            if(m_pInstance) 
+                m_pInstance->SetData(TYPE_VX001, DONE);
+
+            if(!isPhase4)
+            {
+                if (Creature* pMimiron = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON))))
+                    DoScriptText(SAY_TORSO_DEATH, pMimiron);
+            }
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(isPhase4 && !isEventFinished)
+        {
+            if(uiDamage > m_creature->GetHealth())
+            {
+                uiDamage = 0;
+                m_creature->SetHealth(0);
+                m_creature->InterruptNonMeleeSpells(true);
+                m_creature->RemoveAllAuras();
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_creature->GetMotionMaster()->MovementExpired(false);
+                m_creature->GetMotionMaster()->MoveIdle();
+                m_creature->SetStandState(UNIT_STAND_STATE_DEAD);
+                if(m_pInstance) 
+                    m_pInstance->SetData(TYPE_VX001, SPECIAL);
+
+                isEventFinished = true;
+            }
+        }
+    }
+
+    void Repair()
+    {
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        m_creature->SetHealth(m_creature->GetMaxHealth() * 0.5);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+        m_creature->AI()->AttackStart(m_creature->getVictim());
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_VX001, IN_PROGRESS);
+        isEventFinished = false;
+        SetPhase();
+    }
+
+    void SelfDestruct()
+    {
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+        m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(rapidBurstTimer < diff && !isPhase4)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_RAPID_BURST : SPELL_RAPID_BURST_H);
+            rapidBurstTimer = 1000;
+        }
+        else rapidBurstTimer -= diff;
+
+        if(laserBarrageTimer < diff && !isEventFinished)
+        {
+            DoCast(m_creature, SPELL_LASER_BARRAGE);
+            laserBarrageTimer = urand(50000, 60000);
+        }
+        else laserBarrageTimer -= diff;
+
+        if(rocketStrikeTimer < diff && !isEventFinished)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, SPELL_ROCKET_STRIKE);
+            rocketStrikeTimer = urand(25000, 30000);
+        }
+        else rocketStrikeTimer -= diff;
+
+        if(heatWaveTimer < diff  && !isPhase4)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_HEAT_WAVE : SPELL_HEAT_WAVE_H);
+            heatWaveTimer = 10000;
+        }
+        else heatWaveTimer -= diff;
+
+        if(handPulseTimer < diff && isPhase4 && !isEventFinished)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_HAND_PULSE : SPELL_HAND_PULSE_H);
+            handPulseTimer = 1000;
+        }
+        else handPulseTimer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL boss_aerial_command_unitAI : public ScriptedAI
+{   
+    boss_aerial_command_unitAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 plasmaBallTimer;
+    uint32 summonWavesTimer;
+    uint32 groundTimer;
+    uint32 timeGround;
+    bool isGrounded;
+    uint8 i;
+
+    bool isPhase4;
+    bool isEventFinished;
+    uint32 checkEventTimer;
+
+    bool mustDie;
+    uint32 dieTimer;
+
+    void Reset()
+    {
+        plasmaBallTimer = 3000;
+        summonWavesTimer = 15000;
+        timeGround = 40000;
+        isGrounded = false;
+
+        isPhase4 = false;
+        isEventFinished = false;
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_AERIAL_UNIT, NOT_STARTED);
+
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_AERIAL_UNIT, IN_PROGRESS);
+
+        if(!isPhase4)
+        {
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+            m_creature->GetMotionMaster()->MoveIdle();
+            SetCombatMovement(false);
+            m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  7, 0.0f);
+            m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  7, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(isPhase4 && !isEventFinished)
+        {
+            if(uiDamage > m_creature->GetHealth())
+            {
+                uiDamage = 0;
+                m_creature->SetHealth(0);
+                m_creature->InterruptNonMeleeSpells(true);
+                m_creature->RemoveAllAuras();
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_creature->GetMotionMaster()->MovementExpired(false);
+                m_creature->GetMotionMaster()->MoveIdle();
+                m_creature->SetStandState(UNIT_STAND_STATE_DEAD);
+
+                if(m_pInstance) 
+                    m_pInstance->SetData(TYPE_AERIAL_UNIT, SPECIAL);
+                isEventFinished = true;
+            }
+        }
+    }
+
+    void Repair()
+    {
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        m_creature->SetHealth(m_creature->GetMaxHealth() * 0.5);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+        m_creature->AI()->AttackStart(m_creature->getVictim());
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_AERIAL_UNIT, IN_PROGRESS);
+        isEventFinished = false;
+        SetPhase();
+    }
+
+    void SelfDestruct()
+    {
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+        m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        if(!isEventFinished)
+        {
+            if(!isPhase4)
+            {
+                if (Creature* pMimiron = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON))))
+                    DoScriptText(SAY_HEAD_DEATH, pMimiron);
+            }
+
+            if(m_pInstance) 
+                m_pInstance->SetData(TYPE_AERIAL_UNIT, DONE);
+        }
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if (Creature* pMimiron = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON))))
+        {
+            if(!isPhase4)
+            {
+                if(irand(0,1))
+                    DoScriptText(SAY_HEAD_SLAY1, pMimiron);
+                else
+                    DoScriptText(SAY_HEAD_SLAY2, pMimiron);
+            }
+            else
+            {
+                if(!isEventFinished)
+                {
+                    if(irand(0,1))
+                        DoScriptText(SAY_ROBOT_SLAY1, pMimiron);
+                    else
+                        DoScriptText(SAY_ROBOT_SLAY2, pMimiron);
+                }
+            }
+        }
+    }
+
+    void SetPhase()
+    {
+        isPhase4 = true;
+        plasmaBallTimer = 3000;
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_AERIAL_UNIT, IN_PROGRESS);
+
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+        SetCombatMovement(false);
+        m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  6.5f, 0.0f);
+        m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() + 6.5f, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(plasmaBallTimer < diff && !isEventFinished)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_PLASMA_BALL : SPELL_PLASMA_BALL_H);
+            plasmaBallTimer = 3000;
+        }
+        else plasmaBallTimer -= diff;
+
+        if(timeGround < diff && !isPhase4)
+        {
+            m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), CENTER_Z, 0);
+            m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), CENTER_Z, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+            isGrounded = true;
+            // make boss land
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+            timeGround = 50000;
+            groundTimer = 10000;
+        }
+        else timeGround -= diff;
+
+        if (groundTimer < diff && isGrounded)
+        {
+            m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  7, 0.0f);
+            m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  7, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+            isGrounded = false;
+            // make boss fly
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+        }else groundTimer -= diff;
+
+        // spawn adds in arena
+        if(summonWavesTimer < diff && !isPhase4)
+        {
+            // 1 junk bot
+            // 1 bomb bot
+            // 1 assalt bot
+            switch(urand(0, 2))
+            {
+            case 0:
+                i = urand(0, 8);
+                if(Creature *pTemp = m_creature->SummonCreature(MOB_BOMB_BOT, m_creature->GetPositionX(), m_creature->GetPositionY(), CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000))
+                {
+                    if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    {
+                        pTemp->AddThreat(pTarget,0.0f);
+                        pTemp->AI()->AttackStart(pTarget);
+                    }
+                }
+                break;
+            case 1:
+                i = urand(0, 8);
+                if(Creature *pTemp = m_creature->SummonCreature(MOB_JUNK_BOT, SummonLoc[i].x, SummonLoc[i].y, CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000))
+                {
+                    if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    {
+                        pTemp->AddThreat(pTarget,0.0f);
+                        pTemp->AI()->AttackStart(pTarget);
+                    }
+                }
+                break;
+            case 2:
+                i = urand(0, 8);
+                if(Creature *pTemp = m_creature->SummonCreature(MOB_ASSALT_BOT, SummonLoc[i].x, SummonLoc[i].y, CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000))
+                {
+                    if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    {
+                        pTemp->AddThreat(pTarget,0.0f);
+                        pTemp->AI()->AttackStart(pTarget);
+                    }
+                }
+                break;
+            }
+            summonWavesTimer = urand (7000, 10000);
+        }
+        else summonWavesTimer -= diff;         
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL boss_mimironAI : public ScriptedAI
+{   
+    boss_mimironAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        //pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    bool isHardMode;
+    uint8 phase;
+    uint32 phaseDelayTimer;
+    uint32 robotDelayTimer;
+    uint32 endCheckTimer;
+    uint32 selfRepairTimer;
+    uint32 berserkTimer;
+    bool hasChecked;
+    uint32 outroTimer;
+    uint32 phaseCheckTimer;
+    uint32 hardModeCheckTimer;
+    uint32 hpCheckTimer;
+    bool hasMoreHp;
+
+    //hard mode
+    uint32 fireTimer;
+    uint32 supresionTimer;  // extinguish the fires in phase 1 -> just once
+    bool hasSupresed;
+    uint32 frostBombTimer;  // 50k dmg in 15y ->extinguish fires in phase 2
+    uint32 extinguishTimer; // extinguish fires in 5y in phase 2
+    uint32 emergencyBotTimer;   //extinguish fires in phase 3
+
+    uint32 IntroTimer;
+    uint32 IntroStep;
+    bool isIntro;
+    bool isOutro;
+
+    bool isTankDone;
+    bool isTorsoDone;
+    bool isHeadDone;
+    bool isRobotReady;
+
+    Creature *Tank;
+    Creature *Torso;
+    Creature *Head;
+
+    Creature *RobotTank;
+    Creature *RobotTorso;
+    Creature *RobotHead;
+
+    bool isTankDead;
+    bool isTorsoDead;
+    bool isHeadDead;
+
+    bool m_bIsTaunted;
+
+    void Reset()
+    {
+        phase               = 0;
+        isHardMode          = false;
+        isIntro             = true;
+        phaseDelayTimer     = 10000;
+        endCheckTimer       = 1000;
+        berserkTimer        = 900000;   // 15 min
+        hasChecked          = false;
+        isOutro             = false;
+        phaseCheckTimer     = 1000;
+        hardModeCheckTimer  = 1000;
+        hasMoreHp           = false;
+
+        // hard
+        fireTimer           = 5000;     //5k dmg /sec
+        supresionTimer      = 60000;    // just once in phase 1
+        hasSupresed         = false;
+        extinguishTimer     = 30000;    //in range of 5y
+        frostBombTimer      = 60000;
+        emergencyBotTimer   = 10000;    //40 secs after -> 3 robots
+
+        isTankDone          = false;
+        isTorsoDone         = false;
+        isHeadDone          = false;
+        isRobotReady        = false;
+
+        IntroTimer          = 10000;
+        IntroStep           = 1;
+
+        isTankDead          = false;
+        isTorsoDead         = false;
+        isHeadDead          = false;
+
+        m_bIsTaunted        = false;
+
+        phase = 10;
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_MIMIRON, NOT_STARTED);
+
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        if(GameObject* pButton = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(DATA_RED_BUTTON)))
+        {
+            pButton->SetGoState(GO_STATE_READY);
+            pButton->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_UNK1);
+        }
+
+        if(Torso = GetClosestCreatureWithEntry(m_creature, NPC_VX001, 80.0f))
+            m_creature->DealDamage(Torso, Torso->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+
+        if(Head = GetClosestCreatureWithEntry(m_creature, NPC_AERIAL_UNIT, 80.0f))
+            m_creature->DealDamage(Head, Head->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+
+        if (Tank = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEVIATHAN_MK))))
+             ((boss_leviathan_mkAI*)Tank->AI())->Reset();
+    }
+
+    void Aggro(Unit *who) 
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        phase = 0;
+    }
+
+    /*void MoveInLineOfSight(Unit* pWho)
+    {
+        if (pWho->isTargetableForAttack() && pWho->isInAccessablePlaceFor(m_creature) && !m_bIsTaunted && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 30) && m_creature->IsWithinLOSInMap(pWho))
+        {
+            m_bIsTaunted = true;
+            phase = 0;
+            DoScriptText(SAY_AGGRO, m_creature);
+        }
+    }*/
+
+    void DoOutro()
+    {
+        if(m_pInstance) 
+        {
+            m_pInstance->SetData(TYPE_MIMIRON, DONE);
+            if(isHardMode)
+                m_pInstance->SetData(TYPE_MIMIRON_HARD, DONE);
+        }
+
+        m_creature->ForcedDespawn();
+    }
+
+    // for debug only
+    void JustDied(Unit* pKiller)
+    {
+       if(m_pInstance) 
+        {
+            m_pInstance->SetData(TYPE_MIMIRON, DONE);
+            if(isHardMode)
+                m_pInstance->SetData(TYPE_MIMIRON_HARD, DONE);
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(phase == 0)
+        {
+            if (hardModeCheckTimer <= diff && !isHardMode)
+            {
+                if(m_pInstance && m_pInstance->GetData(TYPE_MIMIRON) == SPECIAL) 
+                {
+                    berserkTimer = 460000;  // 8 min
+                    isHardMode = true;
+                }
+                hardModeCheckTimer = 1000;
+            }
+            else hardModeCheckTimer -= diff;
+
+            if(isIntro)
+            {
+                //hard mode check
+                switch(IntroStep)
+                {
+                case 1:
+                    ++IntroStep;
+                    IntroTimer = 15000;
+                    break;
+                case 3:
+                    if(isHardMode)
+                    {
+                        DoScriptText(SAY_HARD_MODE, m_creature);
+                        ++IntroStep;
+                        IntroTimer = 15000;
+                    }
+                    else
+                    {
+                        ++IntroStep;
+                        IntroTimer = 1000;
+                    }
+                    break;
+                case 5:
+                    if (Tank = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEVIATHAN_MK))))
+                    {
+                        if(Tank->isAlive())
+                        {
+                            DoScriptText(SAY_TANK_ACTIVE, m_creature);
+                            Tank->GetMotionMaster()->MovePoint(0, CENTER_X, CENTER_Y, CENTER_Z);
+                        }
+                        else
+                        {
+                            IntroStep = 1;
+                            Tank->Respawn();
+                        }
+                    }
+                    else
+                        return;
+                    if (m_pInstance)
+                    {
+                        if(GameObject* pButton = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(DATA_RED_BUTTON)))
+                            pButton->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_UNK1); 
+
+                        m_pInstance->SetData(TYPE_MIMIRON, IN_PROGRESS);
+                    }
+                    ++IntroStep;
+                    IntroTimer = 15000;
+                    break;
+                case 7:
+                    Tank->setFaction(14);
+                    if(isHardMode)
+                    {
+                        Tank->CastSpell(Tank, SPELL_EMERGENCY_MODE, false);
+                        ++IntroStep;
+                        IntroTimer = 1000;
+                    }
+                    else
+                    {
+                        phase = 1;
+                        isIntro = false;
+                        ++IntroStep;
+                        IntroTimer = 9000;
+                    }
+                    break;
+                case 9:
+                    if(isHardMode)
+                    {
+                        Tank->SetHealth(m_creature->GetMaxHealth()+ (m_creature->GetMaxHealth() * 0.3));                  
+                        phase = 1;
+                        isIntro = false;
+                        ++IntroStep;
+                        IntroTimer = 9000;
+                    }
+                    break;
+                }
+            }
+            else return;
+
+            if (IntroTimer <= diff)
+            {
+                ++IntroStep;
+                IntroTimer = 330000;
+            } IntroTimer -= diff;
+        }
+        if(phase == 1)
+        {
+            if (phaseCheckTimer <= diff && !isTankDone)
+            {
+                if(m_pInstance && m_pInstance->GetData(TYPE_LEVIATHAN_MK) == DONE)
+                {
+                    isTankDone = true;
+                    phaseDelayTimer = 15000;
+                }
+                phaseCheckTimer = 1000;
+            }
+            else phaseCheckTimer -= diff;
+
+            if(isTankDone)
+            {
+                if(phaseDelayTimer < diff && !hasMoreHp)
+                {
+                    if(m_pInstance)
+                        m_pInstance->SetData(TYPE_VX001, SPECIAL);
+                    DoScriptText(SAY_TORSO_ACTIVE, m_creature);
+                    Torso = m_creature->SummonCreature(NPC_VX001, CENTER_X, CENTER_Y, CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000);
+                    if(isHardMode)
+                    {
+                        Torso->CastSpell(Torso, SPELL_EMERGENCY_MODE, false);
+                        hasMoreHp = true;
+                        hpCheckTimer = 1000;
+                    }
+                    else
+                    {
+                        phase = 2;
+                        phaseDelayTimer = 10000;
+                        phaseCheckTimer = 1000;
+                    }
+                }
+                else phaseDelayTimer -= diff;
+
+                if (hpCheckTimer <= diff && hasMoreHp)
+                {
+                    Torso->SetHealth(m_creature->GetMaxHealth()+ (m_creature->GetMaxHealth() * 0.3));
+                    phase = 2;
+                    hasMoreHp = false;
+                    phaseDelayTimer = 10000;
+                    phaseCheckTimer = 1000;
+                    hpCheckTimer = 10000;
+                }
+                else hpCheckTimer -= diff;
+            }
+        }
+        if(phase == 2)
+        {
+            if (phaseCheckTimer <= diff && !isTorsoDone)
+            {
+                if(m_pInstance && m_pInstance->GetData(TYPE_VX001) == DONE)
+                {
+                    phaseDelayTimer = 20000;
+                    hasMoreHp = false;
+                    isTorsoDone = true;
+                }
+                phaseCheckTimer = 1000;
+            }
+            else phaseCheckTimer -= diff;
+
+            if(isTorsoDone)
+            {
+                if(phaseDelayTimer < diff && !hasMoreHp)
+                {
+                    DoScriptText(SAY_HEAD_ACTIVE, m_creature);
+                    Head = m_creature->SummonCreature(NPC_AERIAL_UNIT, CENTER_X, CENTER_Y, CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000);
+                    if(isHardMode)
+                    {
+                        Head->CastSpell(Head, SPELL_EMERGENCY_MODE, false);
+                        hasMoreHp = true;
+                        hpCheckTimer = 1000;
+                    }
+                    else
+                    {
+                        phase = 3;
+                        phaseCheckTimer = 1000;
+                        phaseDelayTimer = 10000;
+                    }
+                }
+                else phaseDelayTimer -= diff;
+
+                if (hpCheckTimer <= diff && hasMoreHp)
+                {
+                    Head->SetHealth(m_creature->GetMaxHealth()+ (m_creature->GetMaxHealth() * 0.3));
+                    phase = 3;
+                    hasMoreHp = false;
+                    phaseDelayTimer = 10000;
+                    phaseCheckTimer = 1000;
+                    hpCheckTimer = 10000;
+                }
+                else hpCheckTimer -= diff;
+            }
+        }
+        if(phase == 3)
+        {
+            if (phaseCheckTimer <= diff && !isHeadDone)
+            {
+                if(m_pInstance && m_pInstance->GetData(TYPE_AERIAL_UNIT) == DONE)
+                {
+                    phaseDelayTimer = 10000;
+                    hasMoreHp = false;
+                    isHeadDone = true;
+                }
+                phaseCheckTimer = 1000;
+            }
+            else phaseCheckTimer -= diff;
+
+            if(isHeadDone)
+            {
+                if(phaseDelayTimer < diff && !isRobotReady)
+                {
+                    if (Tank = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_LEVIATHAN_MK))))
+                    {
+                        if(Tank->isAlive())
+                            Tank->GetMotionMaster()->MovePoint(0, CENTER_X, CENTER_Y, CENTER_Z);
+
+                        isRobotReady = true;
+                        robotDelayTimer = 10000;
+                    }
+                    else
+                        return;
+                    phaseDelayTimer = 100000;
+                }
+                else phaseDelayTimer -= diff;
+            }
+
+            if(robotDelayTimer < diff && isRobotReady && !hasMoreHp)
+            {
+                DoScriptText(SAY_ROBOT_ACTIVE, m_creature);
+                Tank->setFaction(14);
+
+                Torso = m_creature->SummonCreature(NPC_VX001, CENTER_X, CENTER_Y, CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000);
+                Head = m_creature->SummonCreature(NPC_AERIAL_UNIT, CENTER_X, CENTER_Y, CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000);
+
+                // insert phase 4 for robot
+                ((boss_leviathan_mkAI*)Tank->AI())->SetPhase();
+                ((boss_vx001AI*)Torso->AI())->SetPhase();
+                ((boss_aerial_command_unitAI*)Head->AI())->SetPhase();
+                if(isHardMode)
+                {
+                    Torso->CastSpell(Torso, SPELL_EMERGENCY_MODE, false);
+                    Head->CastSpell(Head, SPELL_EMERGENCY_MODE, false);
+                    Tank->CastSpell(Tank, SPELL_EMERGENCY_MODE, false);
+                    hasMoreHp = true;
+                    hpCheckTimer = 1000;
+                }
+                else
+                {
+                    Torso->SetHealth(Torso->GetMaxHealth() * 0.5);
+                    Head->SetHealth(Head->GetMaxHealth() * 0.5);
+                    Tank->SetHealth(Tank->GetMaxHealth() * 0.5);
+                    phase = 4;
+                    endCheckTimer = 2000;
+                    robotDelayTimer = 100000;
+                }
+            }
+            else robotDelayTimer -= diff;
+
+            if (hpCheckTimer <= diff && hasMoreHp)
+            {
+                Head->SetHealth(m_creature->GetMaxHealth() * 0.5);
+                Torso->SetHealth(m_creature->GetMaxHealth()* 0.5);
+                Tank->SetHealth(m_creature->GetMaxHealth()* 0.5);   
+                phase = 4;
+                endCheckTimer = 1000;
+                robotDelayTimer = 100000;
+                hpCheckTimer = 10000;
+            }
+            else hpCheckTimer -= diff;
+        }
+        if(phase == 4)
+        {
+            if(!isOutro)
+            {
+                if(endCheckTimer < diff && !hasChecked)
+                {
+                    if(m_pInstance && m_pInstance->GetData(TYPE_LEVIATHAN_MK) == SPECIAL)
+                    {
+                        selfRepairTimer = 15000;
+                        isTankDead = true;
+                        hasChecked = true;
+                    }
+                    if(m_pInstance && m_pInstance->GetData(TYPE_VX001) == SPECIAL)
+                    {
+                        selfRepairTimer = 15000;
+                        isTorsoDead = true;
+                        hasChecked = true;
+                    }
+                    if(m_pInstance && m_pInstance->GetData(TYPE_AERIAL_UNIT) == SPECIAL)
+                    {
+                        selfRepairTimer = 15000;
+                        isHeadDead = true;
+                        hasChecked = true;
+                    }
+                    endCheckTimer = 1000;
+                }
+                else endCheckTimer -= diff;
+
+                if(selfRepairTimer < diff && hasChecked)
+                {
+                    if(m_pInstance && m_pInstance->GetData(TYPE_LEVIATHAN_MK) == SPECIAL)
+                        isTankDead = true;
+                    if(m_pInstance && m_pInstance->GetData(TYPE_VX001) == SPECIAL)
+                        isTorsoDead = true;
+                    if(m_pInstance && m_pInstance->GetData(TYPE_AERIAL_UNIT) == SPECIAL)
+                        isHeadDead = true;
+
+                    if(isTankDead && isTorsoDead && isHeadDead)
+                    {
+                        DoScriptText(SAY_ROBOT_DEATH, m_creature);
+                        outroTimer = 15000;
+                        isOutro = true;
+                    }
+                    else
+                    {
+                        if(isTankDead)
+                        {
+                            ((boss_leviathan_mkAI*)Tank->AI())->Repair();
+                            endCheckTimer = 1000;
+                            hasChecked = false;
+                        }
+                        if(isTorsoDead)
+                        {
+                            ((boss_vx001AI*)Torso->AI())->Repair();
+                            endCheckTimer = 1000;
+                            hasChecked = false;
+                        }
+                        if(isHeadDead)
+                        {
+                            ((boss_aerial_command_unitAI*)Head->AI())->Repair();
+                            endCheckTimer = 1000;
+                            hasChecked = false;
+                        }
+                    }
+                    selfRepairTimer = 1000;
+                }
+                else selfRepairTimer -= diff;
+            }
+            else
+            {
+                if(outroTimer < diff)
+                {
+                    ((boss_leviathan_mkAI*)Tank->AI())->SelfDestruct();
+                    ((boss_aerial_command_unitAI*)Head->AI())->SelfDestruct();
+                    ((boss_vx001AI*)Torso->AI())->SelfDestruct();
+                    DoOutro();
+                }
+                else outroTimer -= diff;
+            }
+        }
+
+        // berserk
+        if (berserkTimer <= diff && (phase == 1 || phase == 2 || phase == 3 || phase == 4))
+        {
+            if(Tank && Tank->isAlive())
+                Tank->CastSpell(Tank, SPELL_BERSERK, false);
+            if(Torso && Torso->isAlive())
+                Torso->CastSpell(Torso, SPELL_BERSERK, false);
+            if(Head && Head->isAlive())
+                Head->CastSpell(Head, SPELL_BERSERK, false);
+
+            berserkTimer = 330000;
+        } 
+        else
+            berserkTimer -= diff;
+
+        // hard mode
+        if(isHardMode)
+        {
+            // TODO: implement hard mode
+            if (fireTimer <= diff)
+            {
+                if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+
+                    fireTimer = 5000;
+            } 
+            else fireTimer -= diff;
+
+            // supres fires in phase 1
+            if(phase == 1)
+            {
+                if (supresionTimer <= diff && !hasSupresed)
+                {
+
+                    supresionTimer = 60000;
+                    hasSupresed = true;
+                } 
+                else supresionTimer -= diff;
+            }
+
+            // supress fires in phase 2 & 4
+            if(phase == 2 || phase == 4)
+            {
+                if (frostBombTimer <= diff)
+                {
+                    if(Torso)
+                    {
+                        //if(Creature *pTemp = GetClosestCreatureWithEntry(Torso, MOB_BOMB_BOT, 10))  // fix id!!!
+                        //m_creature->SummonCreature(MOB_FROST_BOMB, pTemp->GetPositionX(), pTemp->GetPositionY(), CENTER_Z, 0, TEMPSUMMON_TIMED_DESPAWN, 10000);
+                    }
+
+                    frostBombTimer = 60000;
+                } 
+                else frostBombTimer -= diff;
+            }
+
+            // supress fires in phase 2
+            if(phase == 2)
+            {
+                if (extinguishTimer <= diff)
+                {
+
+                    extinguishTimer = 30000;
+                } 
+                else extinguishTimer -= diff;
+            }
+
+            // supress fires in phase 3
+            if(phase == 3)
+            {
+                if (emergencyBotTimer <= diff)
+                {
+                    for(uint8 i = 0; i < 3; i++)
+                        if(Creature *pTemp = m_creature->SummonCreature(MOB_EMERGENCY_FIRE_BOT, SummonLoc[i].x, SummonLoc[i].y, CENTER_Z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000))
+                        {
+                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            {
+                                pTemp->AddThreat(pTarget,0.0f);
+                                pTemp->AI()->AttackStart(pTarget);
+                            }
+                        }
+                        emergencyBotTimer = 40000;
+                } 
+                else emergencyBotTimer -= diff;
+            }
+
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL leviathan_turretAI : public ScriptedAI
+{   
+    leviathan_turretAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    void Reset()
+    {}
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_proximity_mineAI : public ScriptedAI
+{   
+    mob_proximity_mineAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 explosionTimer;
+    uint32 rangeCheckTimer;
+
+    void Reset()
+    {
+        explosionTimer = 60000;
+        rangeCheckTimer = 1000;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(explosionTimer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_EXPLOSION : SPELL_EXPLOSION_H);
+            m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            explosionTimer = 20000;
+        }
+        else explosionTimer -= diff;
+
+        if (rangeCheckTimer < diff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 1)
+                        explosionTimer = 500;
+                }
+            } 
+            rangeCheckTimer = 100000;
+        }
+        else rangeCheckTimer -= diff;
+    }
+};
+
+struct MANGOS_DLL_DECL mob_bomb_botAI : public ScriptedAI
+{   
+    mob_bomb_botAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    void Reset()
+    {}
+
+    void JustDied(Unit* pKiller)
+    {
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (PlayerList.isEmpty())
+                return;
+
+            for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+            {
+                if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                    i->getSource()->DealDamage(i->getSource(), urand(9425, 10575), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_FIRE, NULL, false);
+            }
+        } 
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_emergency_botAI : public ScriptedAI
+{   
+    mob_emergency_botAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 spellTimer;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 1))
+            {
+            case 0:
+                if(!m_bIsRegularMode)
+                    DoCast(m_creature->getVictim(), SPELL_DEAFENING_SIREN);
+                break;
+            case 1:
+                DoCast(m_creature, SPELL_WATER_SPRAY);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_frost_bombAI : public ScriptedAI
+{   
+    mob_frost_bombAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 explosionTimer;
+
+    void Reset()
+    {
+        explosionTimer = 10000;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (explosionTimer < diff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 15)
+                        i->getSource()->DealDamage(i->getSource(), 50000, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_FROST, NULL, false);
+                }
+            } 
+            m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            explosionTimer = 100000;
+        }
+        else explosionTimer -= diff;
+    }
+};
+CreatureAI* GetAI_boss_mimiron(Creature* pCreature)
+{
+    return new boss_mimironAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_leviathan_mk(Creature* pCreature)
+{
+    return new boss_leviathan_mkAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_vx001(Creature* pCreature)
+{
+    return new boss_vx001AI(pCreature);
+}
+
+CreatureAI* GetAI_boss_aerial_command_unit(Creature* pCreature)
+{
+    return new boss_aerial_command_unitAI(pCreature);
+}
+
+CreatureAI* GetAI_leviathan_turret(Creature* pCreature)
+{
+    return new leviathan_turretAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_proximity_mine(Creature* pCreature)
+{
+    return new mob_proximity_mineAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_bomb_bot(Creature* pCreature)
+{
+    return new mob_bomb_botAI(pCreature);
+}
+CreatureAI* GetAI_mob_emergency_bot(Creature* pCreature)
+{
+    return new mob_emergency_botAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_frost_bomb(Creature* pCreature)
+{
+    return new mob_frost_bombAI(pCreature);
+}
+
+void AddSC_boss_mimiron()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_mimiron";
+    newscript->GetAI = &GetAI_boss_mimiron;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_leviathan_mk";
+    newscript->GetAI = &GetAI_boss_leviathan_mk;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "leviathan_turret";
+    newscript->GetAI = &GetAI_leviathan_turret;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_vx001";
+    newscript->GetAI = &GetAI_boss_vx001;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_aerial_command_unit";
+    newscript->GetAI = &GetAI_boss_aerial_command_unit;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_proximity_mine";
+    newscript->GetAI = &GetAI_mob_proximity_mine;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_bomb_bot";
+    newscript->GetAI = &GetAI_mob_bomb_bot;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_emergency_bot";
+    newscript->GetAI = &GetAI_mob_emergency_bot;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_frost_bomb";
+    newscript->GetAI = &GetAI_mob_bomb_bot;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/ulduar/ulduar/boss_razorscale.cpp b/scripts/northrend/ulduar/ulduar/boss_razorscale.cpp
new file mode 100644
index 0000000..0cd754e
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_razorscale.cpp
@@ -0,0 +1,659 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_razorscale
+SD%Complete: 90%
+SDComment: missing knockback at beggining of phase2. yells and emotes missing, need to use harpoons to start ground phase instead of timer
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+	//yells/emotes
+    SAY_INTRO               = -1603020,
+    SAY_AGGRO1              = -1603021,
+    SAY_AGGRO2              = -1603022,
+    SAY_AGGRO3              = -1603023,
+    SAY_GROUND              = -1603024,
+    SAY_DEEP_BREATH         = -1603025,
+    SAY_FIRES_EXTINGUISH    = -1603026,
+
+	//razorscale air phase
+	SPELL_FIREBALL				= 62796,
+	SPELL_FIREBALL_H			= 63815,
+	SPELL_WING_BUFFET			= 62666,
+	SPELL_STUN					= 62794,
+	//both
+	SPELL_BERSERK				= 47008,
+	DEVOURING_FLAME_VISUAL		= 63236,
+	SPELL_FLAME_BREATH			= 63317,
+	SPELL_FLAME_BREATH_H		= 64021,
+	//ground
+	SPELL_FLAME_BUFFET			= 64016,
+	SPELL_FLAME_BUFFET_H		= 64023,
+	SPELL_FUSE_ARMOR			= 64771,
+
+	//devouring flame target
+	AURA_DEVOURING_FLAME		= 64709,
+	AURA_DEVOURING_FLAME_H		= 64734,
+
+	//dark rune watcher
+	SPELL_LIGHTNING_BOLT		= 63809,
+	SPELL_LIGHTNING_BOLT_H		= 64696,
+	SPELL_CHAIN_LIGHTNING		= 64758,
+	SPELL_CHAIN_LIGHTNING_H		= 64759,
+
+	//dark rune sentinel
+	SPELL_BATTLE_SHOUT			= 46763,
+	SPELL_BATTLE_SHOUT_H		= 64062,
+	SPELL_WHIRLWIND				= 63808,
+
+	//dark rune guardian
+	SPELL_STORMSTRIKE			= 64757,
+
+	//NPC ids
+	MOB_DARK_RUNE_WATCHER		= 33453,
+	MOB_DARK_RUNE_SENTINEL		= 33846,
+	MOB_DARK_RUNE_GUARDIAN		= 33388, 
+
+    NPC_COMMANDER               = 33210, 
+
+    ACHIEV_QUICK_SHAVE          = 2919,
+    ACHIEV_QUICK_SHAVE_H        = 2921,
+};
+
+#define HOME_X                      587.546997f
+#define HOME_Y                      -174.927002f
+ 
+#define GOSSIP_START     "Bring Razorscale down!"
+
+//expedition commander
+struct MANGOS_DLL_DECL npc_expedition_commanderAI : public ScriptedAI
+{
+    npc_expedition_commanderAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+		SetCombatMovement(false);
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    void Reset()
+    {
+    }
+
+    void BeginRazorscaleEvent(Player* pPlayer)
+    {
+		if (!m_pInstance)
+			return;
+		if(m_pInstance->GetData(TYPE_RAZORSCALE) == NOT_STARTED || m_pInstance->GetData(TYPE_RAZORSCALE) == FAIL){
+
+        debug_log("SD2: Razorscale - event initiated by player %s", pPlayer->GetName());
+
+		if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RAZORSCALE))))
+                {
+					pTemp->SetInCombatWithZone();
+                    pTemp->AddThreat(pPlayer,0.0f);
+                    pTemp->AI()->AttackStart(pPlayer);
+                }
+		}else debug_log("SD2: Razorscale - player %s is a moron. he tried to start the event when its already done, or over", pPlayer->GetName());
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+		DoMeleeAttackIfReady();
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim()) return;
+
+		if (!m_pInstance)
+            return;
+    }
+};
+
+CreatureAI* GetAI_npc_expedition_commander(Creature* pCreature)
+{
+    return new npc_expedition_commanderAI(pCreature);
+}
+
+bool GossipHello_npc_expedition_commander(Player* pPlayer, Creature* pCreature)
+{
+	pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, GOSSIP_START, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_npc_expedition_commander(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+    {
+        pPlayer->CLOSE_GOSSIP_MENU();
+		((npc_expedition_commanderAI*)pCreature->AI())->BeginRazorscaleEvent(pPlayer);
+    }
+
+    return true;
+}
+
+// devouring_flame_target
+struct MANGOS_DLL_DECL mob_devouring_flame_targetAI : public ScriptedAI
+{
+    mob_devouring_flame_targetAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		Reset();
+		SetCombatMovement(false);
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Death_Timer;
+
+    void Reset()
+    {
+		Death_Timer = 25500;
+		m_creature->SetDisplayId(11686);
+		m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+		m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+		DoCast(m_creature,  m_bIsRegularMode ? AURA_DEVOURING_FLAME : AURA_DEVOURING_FLAME_H);
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Death_Timer < diff)
+        {
+			m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Death_Timer -= diff;
+	}
+};
+
+CreatureAI* GetAI_mob_devouring_flame_target(Creature* pCreature)
+{
+    return new mob_devouring_flame_targetAI(pCreature);
+}
+
+// dark rune watcher
+struct MANGOS_DLL_DECL mob_dark_rune_watcherAI : public ScriptedAI
+{
+    mob_dark_rune_watcherAI(Creature* pCreature) : ScriptedAI(pCreature)
+	{
+		Reset();
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Spell_Timer;
+
+    void Reset()
+    {
+		Spell_Timer = 10000;
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Spell_Timer < diff)
+        {
+			switch(urand(0, 1))
+            {
+                case 0:
+					DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_LIGHTNING_BOLT : SPELL_LIGHTNING_BOLT_H);
+				break;
+				case 1:
+					DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_CHAIN_LIGHTNING : SPELL_CHAIN_LIGHTNING_H);
+				break;
+			}
+            Spell_Timer = urand(7000, 11000);
+        }else Spell_Timer -= diff;        
+		
+		DoMeleeAttackIfReady();
+	}
+};
+
+CreatureAI* GetAI_mob_dark_rune_watcher(Creature* pCreature)
+{
+    return new mob_dark_rune_watcherAI(pCreature);
+}
+
+// dark rune sentinel
+struct MANGOS_DLL_DECL mob_dark_rune_sentinelAI : public ScriptedAI
+{
+    mob_dark_rune_sentinelAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		Reset();
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Whirl_Timer;
+	uint32 Shout_Timer;
+
+    void Reset()
+    {
+		Whirl_Timer = 10000;
+		Shout_Timer = 2000;
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Whirl_Timer < diff)
+        {
+			DoCast(m_creature, SPELL_WHIRLWIND);
+            Whirl_Timer = urand(10000, 15000);
+        }else Whirl_Timer -= diff;
+
+		if (Shout_Timer < diff)
+        {
+			DoCast(m_creature, m_bIsRegularMode ? SPELL_BATTLE_SHOUT : SPELL_BATTLE_SHOUT_H);
+            Shout_Timer = 30000;
+        }else Shout_Timer -= diff;
+		
+		DoMeleeAttackIfReady();
+	}
+
+};
+
+CreatureAI* GetAI_mob_dark_rune_sentinel(Creature* pCreature)
+{
+    return new mob_dark_rune_sentinelAI(pCreature);
+}
+
+// dark rune guardian
+struct MANGOS_DLL_DECL mob_dark_rune_guardianAI : public ScriptedAI
+{
+    mob_dark_rune_guardianAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		Reset();
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Stormstrike_Timer;
+
+    void Reset()
+    {
+		Stormstrike_Timer = 10000;
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Stormstrike_Timer < diff)
+        {
+			DoCast(m_creature->getVictim(), SPELL_STORMSTRIKE);
+            Stormstrike_Timer = urand(7000, 13000);
+        }else Stormstrike_Timer -= diff;
+		
+		DoMeleeAttackIfReady();
+	}
+
+};
+
+CreatureAI* GetAI_mob_dark_rune_guardian(Creature* pCreature)
+{
+    return new mob_dark_rune_guardianAI(pCreature);
+}
+
+float RazorscaleAddX[4];
+float RazorscaleAddY[4];
+float RazorscaleAddZ[4];
+float RazorscaleBossX[2];
+float RazorscaleBossY[2];
+float RazorscaleBossZ[2];
+
+//razorscale
+struct MANGOS_DLL_DECL boss_razorscaleAI : public ScriptedAI
+{
+    boss_razorscaleAI(Creature* pCreature) : ScriptedAI(pCreature) 
+	{
+		m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+
+		RazorscaleAddX[3] = 621.633301f; RazorscaleAddY[3] = -228.671371f; RazorscaleAddZ[3] = 391.180328f; //right
+        RazorscaleAddX[1] = 564.140198f; RazorscaleAddY[1] = -222.049149f; RazorscaleAddZ[1] = 391.517212f; //left
+        RazorscaleAddX[2] = 591; RazorscaleAddY[2] = -209; RazorscaleAddZ[2] = 392; //middle
+        RazorscaleBossX[2] = 587.629761f; RazorscaleBossY[2] = -179.022522f; RazorscaleBossZ[2] = 391.625061f; //ground
+		RazorscaleBossX[1] = 587.629761f; RazorscaleBossY[1] = -179.022522f; RazorscaleBossZ[1] = 435.415070f; //air
+
+		Reset();
+	}
+
+	ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+	uint32 Fireball_Timer;
+	uint32 Devouring_Flame_Timer;
+	uint32 Flame_Buffet_Timer;
+	uint32 Fuse_Armor_Timer;
+	uint32 Flame_Breath_Timer;
+	uint32 wave1_spawn;  //right side, 1 of each
+	uint32 wave2_spawn; //left side, 1 of each
+	uint32 wave3_spawn; // big guy
+	uint32 Berserk_Timer;
+	uint32 Grounded_Timer; // 8 secs after ground fase is over, adds come
+	uint32 Ground_Cast;
+	uint32 Ground_Knockback;
+	uint32 Timetoground;
+	uint32 Stun_Timer;
+	bool airphase;
+	bool grounded;
+	bool berserk;
+    bool knockback;
+
+    uint8 m_uiFlyNo;
+
+    Creature* pCommander;
+
+    void Reset()
+    {
+		Fireball_Timer = 10000;  // 10 secs for the first, fckin spam after that ~2secs
+		Devouring_Flame_Timer = 18000; // 18 secs first, 12 seconds after
+		wave1_spawn = 7000; // 54
+		wave2_spawn = 9000; //52
+		wave3_spawn = 11000; //56
+		Berserk_Timer = 900000;
+		Timetoground = 80000;
+		airphase = false;
+		grounded = false;
+		berserk = false;
+        knockback = false;
+
+        m_uiFlyNo = 0;
+
+        pCommander = GetClosestCreatureWithEntry(m_creature, NPC_COMMANDER, 80.0f);
+
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+		if (m_pInstance)
+            m_pInstance->SetData(TYPE_RAZORSCALE, NOT_STARTED);
+    }
+
+	void JustDied(Unit* pKiller)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_RAZORSCALE, DONE);
+
+        if (m_uiFlyNo < 2)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_QUICK_SHAVE : ACHIEV_QUICK_SHAVE_H);
+        }
+    }
+
+	void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_RAZORSCALE, IN_PROGRESS);
+		airphase = true;
+		SetCombatMovement(false);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+		m_creature->GetMotionMaster()->MoveIdle();
+		m_creature->GetMap()->CreatureRelocation(m_creature, RazorscaleBossX[1], RazorscaleBossY[1], RazorscaleBossZ[1], 0.0f);
+		m_creature->SendMonsterMove(RazorscaleBossX[1], RazorscaleBossY[1], RazorscaleBossZ[1], SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+    }
+
+	void JustReachedHome()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_RAZORSCALE, FAIL);
+    }
+
+	void UpdateAI(const uint32 diff)
+    {
+		if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+		if (Fireball_Timer < diff && airphase && !grounded)
+        {
+			if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+				DoCast(target, m_bIsRegularMode ? SPELL_FIREBALL : SPELL_FIREBALL_H);
+            Fireball_Timer = 2000;
+        }else Fireball_Timer -= diff;   
+
+		if (Devouring_Flame_Timer < diff && !grounded)
+        {
+			if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+				DoCast(target, DEVOURING_FLAME_VISUAL);
+            Devouring_Flame_Timer = 12000;
+        }else Devouring_Flame_Timer -= diff;  
+
+		if (wave1_spawn < diff && airphase && !grounded)
+        {
+			if (Creature* pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_WATCHER, RazorscaleAddX[3], RazorscaleAddY[3], RazorscaleAddZ[3], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+			if (Creature* pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_GUARDIAN, RazorscaleAddX[3] + 5, RazorscaleAddY[3] + 5, RazorscaleAddZ[3], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+            wave1_spawn = 54000;
+        }else wave1_spawn -= diff;
+
+		if (wave2_spawn < diff && airphase && !grounded)
+        {
+			if (Creature* pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_WATCHER, RazorscaleAddX[1], RazorscaleAddY[1], RazorscaleAddZ[1], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+			if (Creature* pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_GUARDIAN, RazorscaleAddX[1] + 5, RazorscaleAddY[1] + 5, RazorscaleAddZ[1], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+            wave2_spawn = 54000;
+        }else wave2_spawn -= diff;
+
+		if (wave3_spawn < diff && airphase && !grounded)
+        {
+			switch(urand(0, 2)) //33% chance of spawning
+            {
+                case 0:
+				break;
+				case 1:
+					if (Creature* pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_SENTINEL, RazorscaleAddX[2], RazorscaleAddY[2], RazorscaleAddZ[2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 10000))
+						if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+						{
+							pTemp->AddThreat(pTarget,0.0f);
+							pTemp->AI()->AttackStart(pTarget);
+						}
+				break;
+				case 2:
+				break;
+			}
+            wave3_spawn = 54000;
+        }else wave3_spawn -= diff;
+
+		if (Berserk_Timer < diff && !berserk)
+        {
+			DoCast(m_creature, SPELL_BERSERK);
+            berserk = true;
+        }else Berserk_Timer -= diff;
+
+		if (Timetoground < diff && airphase)
+        {
+            DoScriptText(SAY_GROUND, pCommander);
+			m_creature->GetMap()->CreatureRelocation(m_creature, RazorscaleBossX[2], RazorscaleBossY[2], RazorscaleBossZ[2], 1.5);
+            m_creature->SendMonsterMove(RazorscaleBossX[2], RazorscaleBossY[2], RazorscaleBossZ[2], SPLINETYPE_FACINGSPOT, m_creature->GetSplineFlags(), 1);
+			grounded = true;
+			Stun_Timer = 2000;
+			Ground_Cast = 37000;
+			Grounded_Timer = 45000;
+            Timetoground = 130000;
+            // make boss land
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+        }else Timetoground -= diff;
+
+		if (Stun_Timer < diff && grounded)
+		{
+			DoCast(m_creature, SPELL_STUN);
+			Stun_Timer = 60000;
+		}else Stun_Timer -= diff;
+
+		if (Ground_Cast < diff && grounded)
+		{
+			m_creature->RemoveAurasDueToSpell(SPELL_STUN);
+            DoScriptText(SAY_DEEP_BREATH, m_creature);
+			DoCast(m_creature, m_bIsRegularMode ? SPELL_FLAME_BREATH : SPELL_FLAME_BREATH_H);
+			Ground_Cast = 15000;
+			Ground_Knockback = 5000;
+		}else Ground_Cast -= diff;
+
+		if (Ground_Knockback < diff && grounded)
+		{
+			DoCast(m_creature, SPELL_WING_BUFFET);
+			Ground_Knockback = 15000;
+		}else Ground_Knockback -= diff;
+
+		if (Grounded_Timer < diff && grounded)
+		{
+			m_creature->GetMap()->CreatureRelocation(m_creature, RazorscaleBossX[1], RazorscaleBossY[1], RazorscaleBossZ[1], 0.0f);
+            m_creature->SendMonsterMove(RazorscaleBossX[1], RazorscaleBossY[1], RazorscaleBossZ[1], SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+			grounded = false;
+			Fireball_Timer = 10000;
+			Devouring_Flame_Timer = 18000;
+			wave1_spawn = 7000;
+			wave2_spawn = 9000;
+			wave3_spawn = 11000;
+            // make boss fly
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+            // achiev counter
+            m_uiFlyNo++;
+		}else Grounded_Timer -= diff;
+
+		if (airphase && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
+		{
+			if (m_creature->HasAura(SPELL_STUN))
+				m_creature->RemoveAurasDueToSpell(SPELL_STUN);
+            Ground_Knockback = grounded ? 0 : 2500;
+			airphase = false;
+			grounded = false;
+			Devouring_Flame_Timer = 12000;
+			Flame_Buffet_Timer = 10000; //every 10 secs
+			Fuse_Armor_Timer = 13000; //every ~13
+			Flame_Breath_Timer = 6000; //every 14
+			SetCombatMovement(true);
+            // make boss land
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+            m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+			m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+		}
+
+        // knockback at the beginning at the phase
+        if (Ground_Knockback < diff && !knockback && !airphase)
+		{
+			DoCast(m_creature, SPELL_WING_BUFFET);
+			knockback = true;
+		}else Ground_Knockback -= diff;
+
+		if (Fuse_Armor_Timer < diff && !airphase)
+		{
+			DoCast(m_creature->getVictim(), SPELL_FUSE_ARMOR);
+			Fuse_Armor_Timer = 13000;
+		}else Fuse_Armor_Timer -= diff;
+
+		if (Flame_Buffet_Timer < diff && !airphase)
+		{
+			DoCast(m_creature, m_bIsRegularMode ? SPELL_FLAME_BUFFET : SPELL_FLAME_BUFFET_H);
+			Flame_Buffet_Timer = 13000;
+		}else Flame_Buffet_Timer -= diff;
+
+		if (Flame_Breath_Timer < diff && !airphase)
+		{
+			DoCast(m_creature, m_bIsRegularMode ? SPELL_FLAME_BREATH : SPELL_FLAME_BREATH_H);
+			Flame_Breath_Timer = 14000;
+		}else Flame_Breath_Timer -= diff;
+
+		if (!airphase && !grounded)
+			DoMeleeAttackIfReady();
+
+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
+            EnterEvadeMode();
+	}
+};
+
+CreatureAI* GetAI_boss_razorscale(Creature* pCreature)
+{
+    return new boss_razorscaleAI(pCreature);
+}
+
+void AddSC_boss_razorscale()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_razorscale";
+    NewScript->GetAI = GetAI_boss_razorscale;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "mob_devouring_flame_target";
+    NewScript->GetAI = &GetAI_mob_devouring_flame_target;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "mob_dark_rune_watcher";
+    NewScript->GetAI = &GetAI_mob_dark_rune_watcher;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "mob_dark_rune_sentinel";
+    NewScript->GetAI = &GetAI_mob_dark_rune_sentinel;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "mob_dark_rune_guardian";
+    NewScript->GetAI = &GetAI_mob_dark_rune_guardian;
+    NewScript->RegisterSelf();
+
+	NewScript = new Script;
+    NewScript->Name = "npc_expedition_commander";
+	NewScript->GetAI = &GetAI_npc_expedition_commander;
+    NewScript->pGossipHello = &GossipHello_npc_expedition_commander;
+    NewScript->pGossipSelect = &GossipSelect_npc_expedition_commander;
+    NewScript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_thorim.cpp b/scripts/northrend/ulduar/ulduar/boss_thorim.cpp
new file mode 100644
index 0000000..9dd1b7e
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_thorim.cpp
@@ -0,0 +1,945 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_thorim
+SD%Complete: 90%
+SDComment: Implement lightning orbs, summon Sit on the platform in the first 3 min.
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    //yells
+    SAY_AGGRO1          = -1603221,
+    SAY_AGGRO2          = -1603222,
+    SAY_SPECIAL1        = -1603223,
+    SAY_SPECIAL2        = -1603224,
+    SAY_SPECIAL3        = -1603225,
+    SAY_JUMP            = -1603226,
+    SAY_SLAY1           = -1603227,
+    SAY_SLAY2           = -1603228,
+    SAY_BERSERK         = -1603229,
+    SAY_ARENA_WIPE      = -1603230,
+    SAY_DEATH           = -1603231,
+    SAY_OUTRO1          = -1603232,
+    SAY_OUTRO2          = -1603233,
+    SAY_OUTRO3          = -1603234,
+    SAY_OUTRO_HARD1     = -1603235,
+    SAY_OUTRO_HARD2     = -1603236,
+    SAY_OUTRO_HARD3     = -1603237,
+
+    // Sif
+    SAY_SIF_INTRO           = -1603185,
+    SAY_SIF_EVENT           = -1603186,
+    SAY_SIF_DESPAWN         = -1603187,
+
+    // spells
+    // phase1
+    SPELL_SHEAT_OF_LIGHTNING        = 62276,
+    SPELL_STORMHAMMER               = 62042,
+    SPELL_DEAFENING_THUNDER         = 62470,
+    SPELL_LIGHTNING_SHOCK           = 62017,
+    SPELL_CHARGE_ORB                = 62016,
+    SPELL_BERSERK_ADDS              = 62560,    // 5 min phase 1 -> for adds
+    SPELL_SUMMON_LIGHTNING_ORB      = 62391,
+    MOB_LIGHTNING_ORB               = 33138,
+    // phase2
+    SPELL_TOUTCH_OF_DOMINION        = 62565,    // not available in hard mode
+    SPELL_CHAIN_LIGHTNING           = 62131,
+    SPELL_CHAIN_LIGHTNING_H         = 64390,
+    SPELL_LIGHTNING_CHARGE          = 62279,
+    SPELL_UNBALANCING_STRIKE        = 62130,
+    SPELL_BERSERK                   = 26662,    // 5 min phase 2
+
+    // hard mode
+    SPELL_FROSTBOLT_VOLLEY          = 62580,
+    SPELL_FROSTBOLT_VOLLEY_H        = 62604,
+    SPELL_FROST_NOVA                = 62597,
+    SPELL_FROST_NOVA_H              = 62605,
+    SPELL_BLIZZARD                  = 62576,
+    SPELL_BLIZZARD_H                = 62602,
+    NPC_SIF                         = 33196,
+    SPELL_SOUL_CHANNEL              = 40401,
+
+    // pre phase adds
+    MOB_JORMUNGAR_BEHEMOTH          = 32882,
+    SPELL_ACID_BREATH               = 62315,
+    SPELL_ACID_BREATH_H             = 62415,
+    SPELL_SWEEP                     = 62316,
+    SPELL_SWEEP_H                   = 62417,
+
+    // arena
+    MOB_DARK_RUNE_CHAMPION          = 32876,
+    MOB_DARK_RUNE_COMMONER          = 32904,
+    MOB_DARK_RUNE_EVOKER            = 32878,
+    MOB_DARK_RUNE_WARBRINGER        = 32877,
+
+    // hallway
+    MOB_DARK_RUNE_ACOLYTE           = 33110,
+    MOB_IRON_RING_GUARD             = 32874,
+    MINIBOSS_RUNIC_COLOSSUS         = 32872,
+    SPELL_SMASH                     = 62339,
+    SPELL_RUNIC_BARRIER             = 62338,
+    SPELL_CHARGE                    = 62613,
+    SPELL_CHARGE_H                  = 62614,
+
+    MOB_IRON_HOHOR_GUARD            = 32875,
+    MINIBOSS_ANCIENT_RUNE_GIANT     = 32873,
+    SPELL_RUNIC_FORTIFICATION       = 62942,
+    SPELL_STOMP                     = 62411,
+    SPELL_STOMP_H                   = 62413,
+    SPELL_RUNE_DETONATION           = 62526,
+
+};
+#define LOC_Z                       419.5f  
+struct LocationsXY
+{
+    float x, y;
+    uint32 id;
+};
+static LocationsXY ArenaLoc[]=
+{
+    {2158.082f, -240.572f},
+    {2111.883f, -240.561f},
+    {2105.243f, -274.499f},
+    {2163.927f, -277.834f},
+    {2104.865f, -251.027f},
+    {2167.612f, -262.128f},
+};
+
+struct MANGOS_DLL_DECL boss_thorimAI : public ScriptedAI
+{
+    boss_thorimAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *pInstance;
+
+    uint8 phase;
+    bool hasStarted;
+
+    uint32 arenaBerserkTimer;
+    uint32 berserkTimer;
+    uint32 arenaYellTimer;
+    uint32 stormHammerTimer;
+    uint32 deafeningThunderTimer;
+    uint32 chargeOrbTimer;
+    uint32 summonWavesTimer;
+    uint32 minibossCheckTimer;
+
+    uint32 chainLightningTimer;
+    uint32 lightningChargeTimer;
+    uint32 unbalancingStrikeTimer;
+
+    uint32 phase2Timer;
+    uint32 hardModeTimer;
+    uint8 i;
+    uint8 k;
+
+    bool phaseEnd;
+    bool isHardMode;
+
+    Creature* Thorim;
+    Creature* Sif;
+
+    // intro & outro
+    bool isOutro;
+    uint32 OutroTimer;
+    uint32 Step;
+    bool isIntro;
+    uint32 IntroTimer;
+    uint32 IntroStep;
+
+    // mob list check
+    std::list<Creature*> lIronRingGuards;
+    std::list<Creature*> lDarkRuneAcolytes;
+    std::list<Creature*> lIronHonorGuards;
+
+    void Reset()
+    {
+        phase = 10;
+        hasStarted = false;
+        SetCombatMovement(false);
+
+        isHardMode          = true;
+        phaseEnd            = false;
+
+        Sif                 = NULL;
+
+        arenaBerserkTimer   = 300000; // 5 min
+        berserkTimer        = 300000; // 5 min
+        hardModeTimer       = 180000; // 3 min
+        arenaYellTimer      = 30000;
+        summonWavesTimer    = 10000;
+
+        stormHammerTimer        = 20000;
+        deafeningThunderTimer   = 22000;
+        chargeOrbTimer          = 15000;
+
+        chainLightningTimer     = 15000;
+        lightningChargeTimer    = 50000;
+        unbalancingStrikeTimer  = 35000;
+
+        OutroTimer          = 10000;
+        Step                = 1;
+        isIntro             = true;
+        IntroTimer          = 10000;
+        IntroStep           = 1;
+        isOutro             = false;
+
+        if(GameObject* pLever = pInstance->instance->GetGameObject(pInstance->GetData64(DATA_THORIM_LEVER)))
+            pLever->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_UNK1); 
+
+        if(pInstance) 
+        {
+            pInstance->SetData(TYPE_THORIM, NOT_STARTED);
+
+            if(Sif && !Sif->isAlive())
+                Sif->ForcedDespawn();
+
+            // respawn ring guards
+            GetCreatureListWithEntryInGrid(lIronRingGuards, m_creature, MOB_IRON_RING_GUARD, DEFAULT_VISIBILITY_INSTANCE);
+            if (!lIronRingGuards.empty())
+            {
+                for(std::list<Creature*>::iterator iter = lIronRingGuards.begin(); iter != lIronRingGuards.end(); ++iter)
+                {
+                    if ((*iter) && !(*iter)->isAlive())
+                        (*iter)->Respawn();
+                }
+            }
+
+            // respawn dark rune acolytes
+            GetCreatureListWithEntryInGrid(lDarkRuneAcolytes, m_creature, MOB_DARK_RUNE_ACOLYTE, DEFAULT_VISIBILITY_INSTANCE);
+            if (!lDarkRuneAcolytes.empty())
+            {
+                for(std::list<Creature*>::iterator iter = lDarkRuneAcolytes.begin(); iter != lDarkRuneAcolytes.end(); ++iter)
+                {
+                    if ((*iter) && !(*iter)->isAlive())
+                        (*iter)->Respawn();
+                }
+            }
+
+            // respawn honor guards
+            GetCreatureListWithEntryInGrid(lIronHonorGuards, m_creature, MOB_IRON_HOHOR_GUARD, DEFAULT_VISIBILITY_INSTANCE);
+            if (!lIronHonorGuards.empty())
+            {
+                for(std::list<Creature*>::iterator iter = lIronHonorGuards.begin(); iter != lIronHonorGuards.end(); ++iter)
+                {
+                    if ((*iter) && !(*iter)->isAlive())
+                        (*iter)->Respawn();
+                }
+            }
+
+            // respawn runic colossus
+            if (Creature* pColossus = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_RUNIC_COLOSSUS))))
+            {
+                if (!pColossus->isAlive())
+                    pColossus->Respawn();
+            }
+
+            // respawn ancient rune giant
+            if (Creature* pRuneGiant = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_RUNE_GIANT))))
+            {
+                if (!pRuneGiant->isAlive())
+                    pRuneGiant->Respawn();
+            }
+        }
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+
+    void DoOutro()
+    {
+        if(pInstance) 
+        {
+            pInstance->SetData(TYPE_THORIM, DONE);
+            if(isHardMode)
+                pInstance->SetData(TYPE_THORIM_HARD, DONE);
+        }
+
+        m_creature->ForcedDespawn();
+    }
+
+    // for debug only
+    void JustDied(Unit* pKiller)
+    {
+       if(pInstance) 
+        {
+            pInstance->SetData(TYPE_THORIM, DONE);
+            if(isHardMode)
+                pInstance->SetData(TYPE_THORIM_HARD, DONE);
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > m_creature->GetHealth())
+        {
+            uiDamage = 0;
+            isOutro = true;
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if(!isOutro)
+        {
+            if(pInstance && pInstance->GetData(TYPE_THORIM) == SPECIAL && !hasStarted)
+            {
+                m_creature->SetInCombatWithZone();
+                hasStarted = true;
+                if(GameObject* pLever = pInstance->instance->GetGameObject(pInstance->GetData64(DATA_THORIM_LEVER)))
+                    pLever->SetFlag(GAMEOBJECT_FLAGS, GO_FLAG_UNK1);
+                phase = 0;
+            }
+            // phase 0, intro
+            if(phase == 0)
+            {
+                // intro
+                if(isIntro)
+                {
+                    switch(IntroStep)
+                    {
+                    case 1:
+                        DoScriptText(SAY_AGGRO1, m_creature);
+                        DoCast(m_creature, SPELL_SHEAT_OF_LIGHTNING);
+                        ++IntroStep;
+                        IntroTimer = 10000;
+                        break;
+                    case 3:
+                        DoScriptText(SAY_AGGRO2, m_creature);
+                        if (pInstance)
+                            pInstance->SetData(TYPE_THORIM, IN_PROGRESS);
+                        Sif = m_creature->SummonCreature(NPC_SIF, m_creature->GetPositionX() + 10, m_creature->GetPositionY(), m_creature->GetPositionZ(), m_creature->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN, 200000);
+                        Sif->setFaction(35);
+                        ++IntroStep;
+                        IntroTimer = 9000;
+                        break;
+                    case 5:
+                        DoScriptText(SAY_SIF_INTRO, Sif);
+                        phase = 1;
+                        isIntro = false;
+                        ++IntroStep;
+                        IntroTimer = 9000;
+                        break;
+                    }
+                }
+                else return;
+
+                if (IntroTimer <= diff)
+                {
+                    ++IntroStep;
+                    IntroTimer = 330000;
+                } IntroTimer -= diff;
+            }
+
+            // phase 1, fight in arena & hallway
+            if(phase == 1)
+            {
+                if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                    return;
+
+                // hard mode check
+                if (hardModeTimer <= diff && isHardMode)
+                {
+                    isHardMode = false;
+                    if(Sif && Sif->isAlive())
+                    {
+                        DoScriptText(SAY_SIF_DESPAWN, Sif);
+                        Sif->ForcedDespawn();
+                    }
+                    hardModeTimer = 330000;
+                } hardModeTimer -= diff;
+
+                // spawn adds in arena
+                if(summonWavesTimer < diff)
+                {
+                    // 1-2 warbringer
+                    // 1 evoker
+                    // 5-6 commoners
+                    // 1 champion
+                    // 1 acolyte
+                    switch(urand(0, 4))
+                    {
+                    case 0:
+                        i = urand(0, 5);
+                        if(Creature *pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_CHAMPION, ArenaLoc[i].x, ArenaLoc[i].y, LOC_Z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000))
+                        {
+                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            {
+                                pTemp->AddThreat(pTarget,0.0f);
+                                pTemp->AI()->AttackStart(pTarget);
+                                pTemp->GetMotionMaster()->MovePoint(0, 2134.72f, -263.148f, 419.846f);
+                            }
+                        }
+                        break;
+                    case 1:
+                        i = urand(0, 5);
+                        if(Creature *pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_EVOKER, ArenaLoc[i].x, ArenaLoc[i].y, LOC_Z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000))
+                        {
+                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            {
+                                pTemp->AddThreat(pTarget,0.0f);
+                                pTemp->AI()->AttackStart(pTarget);
+                                pTemp->GetMotionMaster()->MovePoint(0, 2134.72f, -263.148f, 419.846f);
+                            }
+                        }
+                        break;
+                    case 2:
+                        i = urand(5, 6);
+                        for(uint8 j = 0; j < i; j++)
+                        {
+                            if(Creature *pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_COMMONER, ArenaLoc[j].x, ArenaLoc[j].y, LOC_Z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000))
+                            {
+                                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                                {
+                                    pTemp->AddThreat(pTarget,0.0f);
+                                    pTemp->AI()->AttackStart(pTarget);
+                                    pTemp->GetMotionMaster()->MovePoint(0, 2134.72f, -263.148f, 419.846f);
+                                }
+                            }
+                        }
+                        break;
+                    case 3:
+                        k = urand(0, 3);
+                        i = urand(k + 1, k + 2);
+                        for(uint8 j = k; j < i; j++)
+                        {
+                            if(Creature *pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_WARBRINGER, ArenaLoc[j].x, ArenaLoc[j].y, LOC_Z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000))
+                            {
+                                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                                {
+                                    pTemp->AddThreat(pTarget,0.0f);
+                                    pTemp->AI()->AttackStart(pTarget);
+                                    pTemp->GetMotionMaster()->MovePoint(0, 2134.72f, -263.148f, 419.846f);
+                                }
+                            }
+                        }
+                        break;
+                    case 4:
+                        i = urand(0, 5);
+                        if(Creature *pTemp = m_creature->SummonCreature(MOB_DARK_RUNE_ACOLYTE, ArenaLoc[i].x, ArenaLoc[i].y, LOC_Z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000))
+                        {
+                            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                            {
+                                pTemp->AddThreat(pTarget,0.0f);
+                                pTemp->AI()->AttackStart(pTarget);
+                                pTemp->GetMotionMaster()->MovePoint(0, 2134.72f, -263.148f, 419.846f);
+                            }
+                        }
+                        break;
+                    }
+                    summonWavesTimer = urand (7000, 10000);
+                }
+                else summonWavesTimer -= diff; 
+
+                // phase 1 spells
+                // charge orb
+                if(chargeOrbTimer < diff)
+                {
+                    // missing orbs from DB :(
+                    //if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    //DoCast(pTarget, SPELL_CHARGE_ORB);
+                    chargeOrbTimer = 10000;
+                }
+                else chargeOrbTimer -= diff; 
+
+                // storm hammer
+                if(stormHammerTimer < diff)
+                {
+                    if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                        DoCast(pTarget, SPELL_STORMHAMMER);
+                    stormHammerTimer = 15000;
+                    deafeningThunderTimer = 3000;
+                }
+                else stormHammerTimer -= diff; 
+
+                // deafening thunder
+                if(deafeningThunderTimer < diff)
+                {
+                    if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                        DoCast(pTarget, SPELL_DEAFENING_THUNDER);
+                    deafeningThunderTimer = 20000;
+                }
+                else deafeningThunderTimer -= diff; 
+
+                if(arenaYellTimer < diff)
+                {
+                    switch(urand(0, 2))
+                    {
+                    case 0: DoScriptText(SAY_SPECIAL1, m_creature); break;
+                    case 1: DoScriptText(SAY_SPECIAL2, m_creature); break;
+                    case 2: DoScriptText(SAY_SPECIAL3, m_creature); break;
+                    }
+                    arenaYellTimer = 30000;
+                }
+                else arenaYellTimer -= diff;
+
+                // phase 1 berserk
+                if(arenaBerserkTimer < diff)
+                {
+                    DoScriptText(SAY_ARENA_WIPE, m_creature);
+                    // disabled because is cast on players
+                    //DoCast(m_creature, SPELL_BERSERK_ADDS);
+                    DoCast(m_creature, SPELL_BERSERK);
+                    if(Creature *pOrb = m_creature->SummonCreature(MOB_LIGHTNING_ORB, 2123.389f, -440.639f, 438.247f, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                    {
+                        pOrb->RemoveSplineFlag(SPLINEFLAG_WALKMODE);
+                        pOrb->SetSpeedRate(MOVE_RUN, 4.0f);
+                        pOrb->GetMotionMaster()->MovePoint(0, 2166.806f, -441.160f, 438.246f);
+                        pOrb->GetMotionMaster()->MovePoint(1, 2227.267f, -431.599f, 412.177f);
+                        pOrb->GetMotionMaster()->MovePoint(2, 2228.072f, -266.417f, 412.177f);
+
+                        // dmg
+                        Map *map = m_creature->GetMap();
+                        if (map->IsDungeon())
+                        {
+                            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                            if (PlayerList.isEmpty())
+                                return;
+
+                            for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                            {
+                                if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                                    i->getSource()->DealDamage(i->getSource(), i->getSource()->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_MAGIC, NULL, false);
+                            }
+                        } 
+                    }
+                    arenaBerserkTimer = 30000;
+                }
+                else arenaBerserkTimer -= diff;
+
+                //enter phase 2
+                if (m_creature->IsWithinDistInMap(m_creature->getVictim(), 10) && !phaseEnd)
+                {
+                    if (Creature* pColossus = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_RUNIC_COLOSSUS))))
+                    {
+                        // check colossus for exploit
+                        if(!pColossus->isAlive())
+                        {
+                            if(Creature* pGiant = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_RUNE_GIANT))))
+                            {
+                                // check giant for exploit
+                                if(!pGiant->isAlive())
+                                {
+                                    // say
+                                    DoScriptText(SAY_JUMP, m_creature);
+
+                                    // move in arena
+                                    m_creature->GetMotionMaster()->MovePoint(0, 2134.719f, -263.148f, 419.846f);
+                                    m_creature->RemoveSplineFlag(SPLINEFLAG_WALKMODE);
+                                    m_creature->SetSplineFlags(SPLINEFLAG_FALLING); 
+                                    phaseEnd = true;
+                                    phase2Timer = 9000;
+                                }
+                                // disable for debug
+                                else
+                                    EnterEvadeMode();
+                            }
+                        }
+                        // disable for debug
+                        else
+                            EnterEvadeMode();
+                    }
+                }
+
+                if(phase2Timer < diff && phaseEnd)
+                {
+                    m_creature->RemoveSplineFlag(SPLINEFLAG_FALLING);
+                    m_creature->RemoveAurasDueToSpell(SPELL_SHEAT_OF_LIGHTNING);
+                    if(!isHardMode)
+                    {
+                        // not working: workaround
+                        DoCast(m_creature, SPELL_TOUTCH_OF_DOMINION);
+                        m_creature->SetHealth(m_creature->GetHealth() - (m_creature->GetHealth() * 0.25));
+                    }
+                    if(isHardMode)
+                    {
+                        //Sif = m_creature->SummonCreature(NPC_SIF, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                        Sif->setFaction(14);
+                        DoScriptText(SAY_SIF_EVENT, Sif);
+                        Sif->SetInCombatWithZone();
+                    }
+                    m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+                    SetCombatMovement(true);
+                    phase = 2;
+                    phaseEnd = false;
+                }
+                else phase2Timer -= diff;
+            }
+
+            if(phase == 2)
+            {
+                if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                    return;
+
+                // all spells
+                // chain lightning
+                if(chainLightningTimer < diff)
+                {
+                    DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_CHAIN_LIGHTNING : SPELL_CHAIN_LIGHTNING_H);
+                    chainLightningTimer = 10000 + rand()%5000;
+                }
+                else chainLightningTimer -= diff; 
+
+                // lightning charge
+                if(lightningChargeTimer < diff)
+                {
+                    DoCast(m_creature->getVictim(), SPELL_LIGHTNING_CHARGE);
+                    lightningChargeTimer = 30000;
+                }
+                else lightningChargeTimer -= diff; 
+
+                // unbalancing strike
+                if(unbalancingStrikeTimer < diff)
+                {
+                    DoCast(m_creature->getVictim(), SPELL_UNBALANCING_STRIKE);
+                    unbalancingStrikeTimer = 30000 + urand(2000, 7000);
+                }
+                else unbalancingStrikeTimer -= diff; 
+
+                // phase 2 berserk
+                if(berserkTimer < diff)
+                {
+                    DoScriptText(SAY_BERSERK, m_creature);
+                    DoCast(m_creature, SPELL_BERSERK);
+                    berserkTimer = 30000;
+                }
+                else berserkTimer -= diff;
+
+                DoMeleeAttackIfReady();
+            }
+        }
+        // outro
+        if(isOutro)
+        {
+            switch(Step)
+            {
+            case 1:
+                Thorim = m_creature;
+                Thorim->setFaction(35);
+                Thorim->RemoveAllAuras();
+                Thorim->DeleteThreatList();
+                Thorim->CombatStop(true);
+                Thorim->InterruptNonMeleeSpells(false);
+                Thorim->SetHealth(Thorim->GetMaxHealth());
+                Thorim->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                ++Step;
+                OutroTimer = 1000;
+                break;
+            case 3:
+                Thorim->SetOrientation(4.99f);
+                DoScriptText(SAY_DEATH, Thorim);
+                ++Step;
+                OutroTimer = 3000;
+                break;
+            case 5:
+                if(isHardMode)
+                {
+                    DoScriptText(SAY_OUTRO_HARD1, Thorim);
+                    DoCast(Sif, SPELL_STORMHAMMER);
+                }
+                else
+                    DoScriptText(SAY_OUTRO1, Thorim);
+                ++Step;
+                OutroTimer = 1000;
+                break;
+            case 7:
+                if(isHardMode)
+                {
+                    //summon a tentacule
+                    if(Creature *tentacule = m_creature->SummonCreature(34266, Sif->GetPositionX(), Sif->GetPositionY(), Sif->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 7000))
+                    {
+                        tentacule->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                        tentacule->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    }
+                    Sif->SetVisibility(VISIBILITY_OFF);
+                    Sif->setFaction(35);
+                    Sif->RemoveAllAuras();
+                    Sif->DeleteThreatList();
+                    Sif->CombatStop(true);
+                    Sif->InterruptNonMeleeSpells(false);
+                }
+                ++Step;
+                OutroTimer = 7000;
+                break;
+            case 9:
+                if(isHardMode)
+                    DoScriptText(SAY_OUTRO_HARD2, Thorim);
+                else
+                    DoScriptText(SAY_OUTRO2, Thorim);
+                ++Step;
+                OutroTimer = 13000;
+                break;
+            case 11:
+                if(isHardMode)
+                    DoScriptText(SAY_OUTRO_HARD3, Thorim);
+                else
+                    DoScriptText(SAY_OUTRO3, Thorim);
+                ++Step;
+                OutroTimer = 15000;
+                break;
+            case 13:
+                DoOutro();
+                ++Step;
+                OutroTimer = 10000;
+                break;
+            }
+        }
+        else return;
+
+        if (OutroTimer <= diff)
+        {
+            ++Step;
+            OutroTimer = 330000;
+        } OutroTimer -= diff;
+    }
+};
+
+CreatureAI* GetAI_boss_thorim(Creature* pCreature)
+{
+    return new boss_thorimAI(pCreature);
+}
+
+struct MANGOS_DLL_DECL boss_runic_colossusAI : public ScriptedAI
+{
+    boss_runic_colossusAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *pInstance;
+
+    uint32 spellTimer;
+    uint32 runicBarrierTimer;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+        runicBarrierTimer = 15000;
+
+        if(pInstance) 
+            pInstance->SetData(TYPE_RUNIC_COLOSSUS, NOT_STARTED);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(pInstance) 
+            pInstance->SetData(TYPE_RUNIC_COLOSSUS, IN_PROGRESS);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        if(pInstance) 
+            pInstance->SetData(TYPE_RUNIC_COLOSSUS, DONE);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 1))
+            {
+            case 0:
+                DoCast(m_creature->getVictim(), SPELL_SMASH);
+                break;
+            case 1:
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, m_bIsRegularMode ? SPELL_CHARGE : SPELL_CHARGE_H);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        if (runicBarrierTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_RUNIC_BARRIER);
+            runicBarrierTimer = 15000 + urand(1000, 5000);
+        }else runicBarrierTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_runic_colossus(Creature* pCreature)
+{
+    return new boss_runic_colossusAI(pCreature);
+}
+
+struct MANGOS_DLL_DECL boss_ancient_rune_giantAI : public ScriptedAI
+{
+    boss_ancient_rune_giantAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *pInstance;
+
+    uint32 spellTimer;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+
+        if(pInstance) 
+            pInstance->SetData(TYPE_RUNE_GIANT, NOT_STARTED);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        if(pInstance) 
+            pInstance->SetData(TYPE_RUNE_GIANT, DONE);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        // should be cast on adds!!!
+        //DoCast(m_creature, SPELL_RUNIC_FORTIFICATION);
+
+        if(pInstance) 
+            pInstance->SetData(TYPE_RUNE_GIANT, IN_PROGRESS);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 1))
+            {
+            case 0:
+                DoCast(m_creature->getVictim(), m_bIsRegularMode? SPELL_STOMP : SPELL_STOMP_H);
+                break;
+            case 1:
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, SPELL_RUNE_DETONATION);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_ancient_rune_giant(Creature* pCreature)
+{
+    return new boss_ancient_rune_giantAI(pCreature);
+}
+
+struct MANGOS_DLL_DECL npc_sifAI : public ScriptedAI
+{
+    npc_sifAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *pInstance;
+
+    uint32 spellTimer;
+
+    void Reset()
+    {
+        spellTimer = 10000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 2))
+            {
+            case 0:
+                DoCast(m_creature->getVictim(), m_bIsRegularMode? SPELL_FROSTBOLT_VOLLEY : SPELL_FROSTBOLT_VOLLEY_H);
+                break;
+            case 1:
+                DoCast(m_creature, m_bIsRegularMode? SPELL_FROST_NOVA : SPELL_FROST_NOVA_H);
+                break;
+            case 2:
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, m_bIsRegularMode? SPELL_BLIZZARD : SPELL_BLIZZARD_H);
+                break;
+            }
+
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_npc_sif(Creature* pCreature)
+{
+    return new npc_sifAI(pCreature);
+}
+
+void AddSC_boss_thorim()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_thorim";
+    newscript->GetAI = &GetAI_boss_thorim;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_runic_colossus";
+    newscript->GetAI = &GetAI_boss_runic_colossus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_ancient_rune_giant";
+    newscript->GetAI = &GetAI_boss_ancient_rune_giant;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_sif";
+    newscript->GetAI = &GetAI_npc_sif;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/ulduar/ulduar/boss_vezax.cpp b/scripts/northrend/ulduar/ulduar/boss_vezax.cpp
new file mode 100644
index 0000000..7fb3674
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_vezax.cpp
@@ -0,0 +1,562 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_vezax
+SD%Complete:
+SDComment: despawn vapors in hard mode, implement mark of the faceless
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    SAY_AGGRO       = -1603120,
+    SAY_SURGE       = -1603123,
+    SAY_HARD        = -1603126,
+    SAY_SLAY1       = -1603121,
+    SAY_SLAY2       = -1603122,
+    SAY_BERSERK     = -1603125,
+    SAY_DEATH       = -1603124,
+
+
+    SPELL_AURA_OF_DESPAIR       = 62692,
+    SPELL_SHADOW_CRASH          = 62660,
+    SPELL_MARK_OF_FACELESS      = 63276,
+    SPELL_SEARING_FLAMES        = 62661,
+    SPELL_SURGE_OF_DARKNESS     = 62662,
+    SPELL_BERSERK               = 26662, 
+    SPELL_SARONITE_BARRIER      = 63364,
+
+    NPC_SARONITE_VAPOR          = 33488,
+    SPELL_SARONITE_VAPORS       = 63322, //63323, //not working yet
+
+    NPC_SARONITE_ANIMUS         = 33524,
+    SPELL_PROFOUND_DARKNESS     = 63420, 
+
+    ACHIEV_MORNING_SARONITE     = 3181,
+    ACHIEV_MORNING_SARONITE_H   = 3188,
+};
+
+struct VaporsPositions
+{
+    float x, y, z;
+};
+ 
+// Saronite Vapors Spawn Positions
+static VaporsPositions VaporsSP[] =
+{
+    {1888.806396f,128.965668f,342.380219f},
+    {1876.695557f,149.551529f,342.354980f},
+    {1827.845093f,147.315857f,341.311432f},
+    {1809.365112f,115.901085f,342.377747f},
+    {1850.341309f,151.806229f,342.377869f},
+    {1872.992554f,106.913689f,342.377960f},
+    {1813.253906f,97.265800f,342.377960f},
+    {1845.484863f,124.527130f,341.802368f}
+};
+
+uint8 SaroniteVaporCount;
+
+struct MANGOS_DLL_DECL boss_vezaxAI : public ScriptedAI
+{
+    boss_vezaxAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 EnrageTimer;
+    uint32 CrashTimer;
+    uint32 MarkTimer;
+    uint32 FlamesTimer;
+    uint32 SurgeTimer;
+    uint32 SaroniteVaporTimer;
+    uint32 AddsCheckTimer;
+    uint32 SimphonTimer;
+    uint32 EndSimphonTimer;
+
+    bool isHardMode;
+    bool hasMark;
+    float zLoc;
+
+    bool m_bHasCheckedKeepers;
+
+    void Reset()
+    {
+        EnrageTimer = 600000; //10 minutes
+        FlamesTimer = 10000 + rand()%10000;
+        SaroniteVaporTimer = 40000;
+
+        isHardMode = false;
+        hasMark = false;
+
+        SurgeTimer = urand(60000, 70000);
+        MarkTimer = 30000;
+        CrashTimer = 10000;
+        AddsCheckTimer = 2000;
+        SimphonTimer = 1000;
+        EndSimphonTimer = 10000;
+
+        SaroniteVaporCount = 0;
+
+        zLoc = 342.188f;
+
+        m_bHasCheckedKeepers = false;
+        
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_VEZAX, NOT_STARTED);
+
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_VEZAX, IN_PROGRESS);
+        DoCast(NULL, SPELL_AURA_OF_DESPAIR, true);
+
+        DoScriptText(SAY_AGGRO, m_creature);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        if(m_pInstance) 
+        {
+            m_pInstance->SetData(TYPE_VEZAX, DONE);
+
+            if(isHardMode)
+            {
+                m_pInstance->SetData(TYPE_VEZAX_HARD, DONE);
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_MORNING_SARONITE : ACHIEV_MORNING_SARONITE_H);
+            }
+        }
+
+        DoScriptText(SAY_DEATH, m_creature);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+
+    void CheckAdds()
+    {
+        if(SaroniteVaporCount == 6)
+        {
+            DoCast(m_creature, SPELL_SARONITE_BARRIER);
+            DoScriptText(SAY_HARD, m_creature);
+            Creature *Animus = m_creature->SummonCreature(NPC_SARONITE_ANIMUS, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ(), m_creature->GetOrientation(), TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+            Animus->SetInCombatWithZone();
+            isHardMode = true;
+            SaroniteVaporCount = 0;        
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(!m_bHasCheckedKeepers)
+        {
+            // hodir doesn't save!!! fix it
+            if(m_pInstance && /*m_pInstance->GetData(TYPE_HODIR) == DONE &&*/ m_pInstance->GetData(TYPE_FREYA) == DONE && m_pInstance->GetData(TYPE_THORIM) == DONE && m_pInstance->GetData(TYPE_MIMIRON) == DONE)
+            {
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_bHasCheckedKeepers = true;
+            }
+            else
+            {
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_bHasCheckedKeepers = true;
+            }
+        }
+
+        // check for adds
+        if(!isHardMode)
+        {
+            if(AddsCheckTimer < diff)
+            {
+                CheckAdds();
+                AddsCheckTimer = 2000;
+            }
+            else AddsCheckTimer -= diff;
+
+            // saronite vapor
+            if(SaroniteVaporTimer < diff && (SaroniteVaporCount < 8))
+            {      
+                m_creature->SummonCreature(NPC_SARONITE_VAPOR, VaporsSP[SaroniteVaporCount].x, VaporsSP[SaroniteVaporCount].y, VaporsSP[SaroniteVaporCount].z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 25000);
+                SaroniteVaporCount += 1;
+                if(SaroniteVaporCount == 8)
+                    SaroniteVaporCount = 0;
+                SaroniteVaporTimer = 40000;
+            }
+            else SaroniteVaporTimer -= diff;
+
+        }
+
+        // searing flames
+        if(FlamesTimer < diff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_SEARING_FLAMES);
+            FlamesTimer = 10000 + rand()%10000;
+        }
+        else FlamesTimer -= diff; 
+
+        // surge of darkness
+        if(SurgeTimer < diff)
+        {
+            DoScriptText(SAY_SURGE, m_creature);
+            DoCast(m_creature->getVictim(), SPELL_SURGE_OF_DARKNESS);
+            SurgeTimer = urand(60000, 70000);
+        }
+        else SurgeTimer -= diff; 
+
+        // mark of faceless
+        if(MarkTimer < diff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, SPELL_MARK_OF_FACELESS);
+
+            hasMark = true;
+            MarkTimer = 30000;
+            EndSimphonTimer = 10000;
+        }
+        else MarkTimer -= diff;
+
+        if(hasMark)
+        {
+            if(SimphonTimer < diff)
+            {
+                m_creature->SetHealth(m_creature->GetHealth() + 5000);
+
+                // drain life from target -> workaround
+                ThreatList const& tList = m_creature->getThreatManager().getThreatList();
+                for (ThreatList::const_iterator iter = tList.begin();iter != tList.end(); ++iter)
+                {
+                    Unit* pUnit = Unit::GetUnit((*m_creature), (*iter)->getUnitGuid());
+                    if (pUnit && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                    {
+                        if (pUnit->HasAura(SPELL_MARK_OF_FACELESS))
+                        {
+                            pUnit->SetHealth(pUnit->GetHealth() - 5000);
+                        }
+                    }
+                }
+                SimphonTimer = 1000;
+            }
+            else SimphonTimer -= diff; 
+
+            // end simphon
+            if(EndSimphonTimer < diff)
+            {
+                hasMark = false;  
+            }
+            else EndSimphonTimer -= diff;
+        }
+
+        // shadow crash
+        if(CrashTimer < diff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, SPELL_SHADOW_CRASH);
+            CrashTimer = 10000;
+        }
+        else CrashTimer -= diff;
+
+        // enrage 10 min
+        if(EnrageTimer < diff)
+        {
+            DoScriptText(SAY_BERSERK, m_creature);
+            DoCast(m_creature, SPELL_BERSERK);
+            EnrageTimer = 30000;
+        }
+        else EnrageTimer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_saronite_animusAI : public ScriptedAI
+{
+    mob_saronite_animusAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    uint32 ProfoundDarknessTimer;
+
+    void Reset()
+    {
+        ProfoundDarknessTimer = 5000;
+    }
+
+    void JustDied(Unit *killer)
+    {
+        if(pInstance)
+        {
+            if (Creature* pVezax = ((Creature*)Unit::GetUnit((*m_creature), pInstance->GetData64(DATA_VEZAX))))
+            {
+                if (pVezax->isAlive())
+                    pVezax->RemoveAurasDueToSpell(SPELL_SARONITE_BARRIER);
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(ProfoundDarknessTimer < diff)
+        {
+            DoCast(m_creature, SPELL_PROFOUND_DARKNESS);
+            ProfoundDarknessTimer = 5000;
+        }
+        else ProfoundDarknessTimer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_saronite_vaporAI : public ScriptedAI
+{
+    mob_saronite_vaporAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance *pInstance;
+
+    void Reset()
+    {}
+
+    void JustDied(Unit *killer)
+    {
+        SaroniteVaporCount -= 1;
+        DoCast(killer, SPELL_SARONITE_VAPORS);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+    }
+};
+
+CreatureAI* GetAI_boss_vezax(Creature* pCreature)
+{
+    return new boss_vezaxAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_saronite_animus(Creature* pCreature)
+{
+    return new mob_saronite_animusAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_saronite_vapor(Creature* pCreature)
+{
+    return new mob_saronite_vaporAI(pCreature);
+}
+
+void AddSC_boss_vezax()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_vezax";
+    newscript->GetAI = &GetAI_boss_vezax;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_saronite_animus";
+    newscript->GetAI = &GetAI_mob_saronite_animus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_saronite_vapor";
+    newscript->GetAI = &GetAI_mob_saronite_vapor;
+    newscript->RegisterSelf();
+}
+
+
+/* check this:
+
+enum Enums
+{
+    //General Vezax yells
+    SAY_VEZAX_AGGRO                     = -1999925,
+    SAY_VEZAX_KILL_PLAYER_1             = -1999926,
+    SAY_VEZAX_KILL_PLAYER_2             = -1999927,
+    SAY_VEZAX_SUMMON                    = -1999928,
+    SAY_VEZAX_ENRAGE                    = -1999929,
+    SAY_VEZAX_DEATH                     = -1999930,
+    SAY_VEZAX_SURGE                     = -1999931,
+ 
+    //Vezax spells
+    SPELL_ENRAGE                        = 61632, // Increases the caster's attack speed by 150% and all damage it deals by 500% for 5 min.
+    SPELL_AURA_OF_DESPAIR               = 62692, // Unable to regenerate or gain mana from most natural sources. Melee attack speed reduced by 20%.
+    SPELL_SHADOW_CRASH                  = 60835, // Fires a missile towards a random target. When this missile lands, it deals 5655 to 6345 Shadow damage to all enemies within 10 yards of that location.
+    SPELL_SHADOW_CRASH_H                = 63721, // deals 11310 to 12690 Shadow damage
+    SPELL_SEARING_FLAMES                = 62661, // Deals 13875 to 16125 Fire damage to all enemies within 100 yards, Armor reduced by 75% for 10 seconds.
+    SPELL_SURGE_OF_DARKNESS             = 62662, // Physical damage increased by 100%. Movement speed reduced by 55%.
+    SPELL_MARK_OF_FACELESS              = 63276, // Siphoning 5000 health from nearby allies every 1 sec., healing General Vezax.
+    SPELL_CORRUPTED_RAGE                = 68415, // Your insight into Shamanistic Rage is intensified but corrupted by General Vezax's Aura of Despair, hindering your ability to heal.
+    SPELL_SARONITE_BARRIER              = 63364,
+ 
+    //summons
+    BOSS_SARONITE_ANIMUS                = 33524, //only hardmode (if at least 6 saronite vapors arent destroyed)
+    NPC_SARONITE_VAPORS                 = 33488,
+ 
+    //summons spells
+    SPELL_PROFOUND_OF_DARKNESS          = 63420, //saronite animus
+    SPELL_SARONITE_VAPORS               = 63323, //not working yet
+ 
+    //phases
+    PHASE_NORMAL                        = 1,
+    PHASE_ANIMUS_SPAWNED                = 2,
+    PHASE_HARD_MODE_ACTIVE              = 3
+};
+ 
+struct VaporsPositions
+{
+    float x, y, z;
+};
+ 
+// Saronite Vapors Spawn Positions
+static VaporsPositions VaporsSP[] =
+{
+    {1888.806396,128.965668,342.380219},
+    {1876.695557,149.551529,342.354980},
+    {1827.845093,147.315857,341.311432},
+    {1809.365112,115.901085,342.377747},
+    {1850.341309,151.806229,342.377869},
+    {1872.992554,106.913689,342.377960},
+    {1813.253906,97.265800,342.377960},
+    {1845.484863,124.527130,341.802368}
+};
+ 
+struct TRINITY_DLL_DECL boss_general_vezaxAI : public BossAI
+{
+    boss_general_vezaxAI(Creature* pCreature) : BossAI(pCreature, TYPE_VEZAX) {}
+ 
+    uint32 EnrageTimer;
+    uint32 ShadowCrashTimer;
+    uint32 SearingFlamesTimer;
+    uint32 SurgeOfDarknessTimer;
+    uint32 MarkOfFacelessTimer;
+    uint32 SummonVaporsTimer;
+ 
+    uint8 Phase;
+    uint8 VaporsCounter;
+    bool HardMode;
+    bool AchievHardModeKill;
+    bool AchievShadowdodger;
+    bool AnimusSummoned;
+ 
+    void Reset()
+    {
+        EnrageTimer = 10*MINUTE*IN_MILISECONDS;
+        ShadowCrashTimer = 10000;
+        SearingFlamesTimer = urand(5000,10000);
+        SurgeOfDarknessTimer = 65000;
+        MarkOfFacelessTimer = urand(15000,25000);
+        SummonVaporsTimer = 30000;
+ 
+        Phase = PHASE_NORMAL;
+        VaporsCounter = 0;
+        HardMode = true;
+        AchievHardModeKill = true;
+        AchievShadowdodger = true;
+        AnimusSummoned = false;
+ 
+        m_creature->ResetLootMode();
+        m_creature->SetMaxHealth(HEROIC(5000000,20000000));
+    }
+ 
+    void EnterCombat(Unit* pWho)
+    {
+        DoScriptText(SAY_VEZAX_AGGRO, m_creature);
+        DoZoneInCombat();
+ 
+        m_creature->ApplySpellImmune(0, IMMUNITY_ID, SPELL_AURA_OF_DESPAIR, true);
+        DoCastAOE(SPELL_AURA_OF_DESPAIR, true);
+        m_creature->AddLootMode(2); // emblem of valor drop
+    }
+ 
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_VEZAX_DEATH, m_creature);
+    }
+ 
+    void KilledUnit(Unit* pVictim)
+    {
+        DoScriptText(RAND(SAY_VEZAX_KILL_PLAYER_1,SAY_VEZAX_KILL_PLAYER_2), m_creature);
+    }
+ 
+    void UpdateAI(const uint32 diff)
+    {
+        if (!UpdateVictim())
+            return;
+ 
+        if (diff > EnrageTimer) {
+            DoCast(m_creature, SPELL_ENRAGE);
+            DoScriptText(SAY_VEZAX_ENRAGE, m_creature);
+        } else EnrageTimer -= diff;
+ 
+        if (Phase != PHASE_ANIMUS_SPAWNED) {
+            if (diff > SearingFlamesTimer) {
+                DoCastVictim(SPELL_SEARING_FLAMES);
+                SearingFlamesTimer = urand(5000,10000);
+            } else SearingFlamesTimer -= diff;
+        }
+ 
+        if (diff > SurgeOfDarknessTimer) {
+            DoCast(m_creature, SPELL_SURGE_OF_DARKNESS);
+            DoScriptText(SAY_VEZAX_SURGE, m_creature);
+            SurgeOfDarknessTimer = 65000;
+        } else SurgeOfDarknessTimer -= diff;
+ 
+        if ((Phase == PHASE_NORMAL) && (VaporsCounter<8)) {
+            if (diff > SummonVaporsTimer) {
+                m_creature->SummonCreature(NPC_SARONITE_VAPORS, VaporsSP[VaporsCounter].x, VaporsSP[VaporsCounter].y, VaporsSP[VaporsCounter].z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 25000);
+                m_creature->SummonCreature(NPC_SARONITE_VAPORS, VaporsSP[VaporsCounter+1].x, VaporsSP[VaporsCounter+1].y, VaporsSP[VaporsCounter+1].z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 25000);
+                VaporsCounter+=2;
+                if (VaporsCounter == 6) {
+                    Phase = PHASE_ANIMUS_SPAWNED;
+                    DoCast(m_creature, SPELL_SARONITE_BARRIER);
+                    m_creature->SummonCreature(BOSS_SARONITE_ANIMUS, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ(), m_creature->GetOrientation(), TEMPSUMMON_CORPSE_DESPAWN);
+                    m_creature->RemoveLootMode(2);
+                    m_creature->AddLootMode(4); // change emblem of valor for emblem of conquest and add hard mode loot items
+                }
+            } else SummonVaporsTimer -= diff;
+        }
+    }
+};
+*/
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_xt002.cpp b/scripts/northrend/ulduar/ulduar/boss_xt002.cpp
new file mode 100644
index 0000000..d967726
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_xt002.cpp
@@ -0,0 +1,868 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_xt002
+SD%Complete: 95%
+SDComment: need core support for light and gravity bomb. correct number of adds in 25man missing
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    //xt yells
+    SAY_AGGRO				= -1603038,
+    SAY_DEATH				= -1603030,
+    SAY_TANCTRUM			= -1603037,
+    SAY_SLAY_01				= -1603036,
+    SAY_SLAY_02				= -1603035,
+    SAY_BERSERK				= -1603031,
+    SAY_ADDS				= -1603032,
+    SAY_HEART_OPEN			= -1603034,
+    SAY_HEART_CLOSE			= -1603033,
+
+    //xt-002
+    SPELL_TANCTRUM			= 62776,
+    SPELL_LIGHT_BOMB		= 63018,
+    SPELL_LIGHT_BOMB_H		= 65121,
+    SPELL_GRAVITY_BOMB		= 63024,
+    SPELL_GRAVITY_BOMB_H	= 64234,
+    SPELL_ENRAGE			= 47008,
+    SPELL_STUN				= 3618,
+
+    // hard mode
+    SPELL_HEARTBREAK        = 65737,
+    SPELL_HEARTBREAK_H      = 64193,
+    SPELL_VOIDZONE          = 64203,
+    SPELL_VOIDZONE_H        = 64235,
+    SPELL_LIFE_SPARK        = 64210,
+    SPELL_STATIC_CHARGED    = 64227,
+
+    NPC_VOIDZONE            = 34001,
+    NPC_LIFESPARK           = 34004,
+
+    //heart of the deconstructor
+    SPELL_EXPOSED_HEART		= 63849,
+
+    //XE-321 Boombot
+    SPELL_BOOM				= 38831,			// replacing real spell
+
+    //XM-024 Pummeller
+    SPELL_CLEAVE			= 8374,
+    SPELL_TRAMPLE			= 5568,
+    SPELL_UPPERCUT			= 10966,
+
+    //NPC ids
+    //NPC_HEART				= 33329,
+    NPC_SCRAPBOT			= 33343,
+    NPC_BOOMBOT				= 33346,
+    NPC_PUMMELER			= 33344, 
+
+
+    // Achievs
+    ACHIEV_HEARTBREAKER     = 3058,
+    ACHIEV_HEARTBREAKER_H   = 3059,
+    ACHIEV_DECONSTRUCT_FAST = 2937,
+    ACHIEV_DECONSTRUCT_FAST_H = 2938,
+};
+
+// void zone
+struct MANGOS_DLL_DECL mob_voidzoneAI : public ScriptedAI
+{
+    mob_voidzoneAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    uint32 Spell_Timer;
+    uint32 DespawnTimer;
+    bool m_bIsRegularMode;
+
+    void Reset()
+    {
+        Spell_Timer = 4000;
+        DespawnTimer = 180000;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Spell_Timer < diff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                        i->getSource()->DealDamage(i->getSource(), m_bIsRegularMode ? 5000 : 7500, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_SHADOW, NULL, false);
+                }
+            } 
+            Spell_Timer = 4000;
+        }else Spell_Timer -= diff;  
+
+        if (DespawnTimer < diff)
+            m_creature->ForcedDespawn();
+        else DespawnTimer -= diff; 
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_voidzone(Creature* pCreature)
+{
+    return new mob_voidzoneAI(pCreature);
+}
+
+// lifespark
+struct MANGOS_DLL_DECL mob_lifesparkAI : public ScriptedAI
+{
+    mob_lifesparkAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+
+    uint32 Spell_Timer;
+
+    void Reset()
+    {  
+        Spell_Timer = 4000;
+        DoCast(m_creature, SPELL_STATIC_CHARGED, false);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Spell_Timer < diff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 80)
+                        i->getSource()->DealDamage(i->getSource(), 500, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NATURE, NULL, false);
+                }
+            } 
+            Spell_Timer = 3000;
+
+        }else Spell_Timer -= diff;  
+
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_lifespark(Creature* pCreature)
+{
+    return new mob_lifesparkAI(pCreature);
+}
+
+// XM-024 Pummeller
+struct MANGOS_DLL_DECL mob_pummelerAI : public ScriptedAI
+{
+    mob_pummelerAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+
+    uint32 Spell_Timer;
+
+    void Reset()
+    {
+        Spell_Timer = urand(15000, 25000);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (Spell_Timer < diff)
+        {
+            switch(urand(0, 2))
+            {
+            case 0:
+                DoCast(m_creature->getVictim(), SPELL_CLEAVE);
+                break;
+            case 1:
+                DoCast(m_creature->getVictim(), SPELL_TRAMPLE);
+                break;
+            case 2:
+                DoCast(m_creature->getVictim(), SPELL_UPPERCUT);
+                break;
+            }
+            Spell_Timer = urand(15000, 25000);
+        }else Spell_Timer -= diff;        
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_pummeler(Creature* pCreature)
+{
+    return new mob_pummelerAI(pCreature);
+}
+
+// XE-321 Boombot
+struct MANGOS_DLL_DECL mob_boombotAI : public ScriptedAI
+{
+    mob_boombotAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+
+    void Reset()
+    {
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+        if (uiDamage > m_creature->GetHealth()){
+            uiDamage = 0;
+            DoCast(m_creature, SPELL_BOOM);
+        }
+    }
+
+    void DoMeleeAttackIfReady()
+    {
+        //If we are within range melee the target
+        if (m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+        {
+            DoCast(m_creature, SPELL_BOOM);
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_boombot(Creature* pCreature)
+{
+    return new mob_boombotAI(pCreature);
+}
+
+// Heart of the Deconstructor
+struct MANGOS_DLL_DECL mob_xtheartAI : public ScriptedAI
+{
+    mob_xtheartAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        SetCombatMovement(false);
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 Exposed_Timer;
+    uint32 heartdamage;
+
+    void Reset()
+    {
+        Exposed_Timer = 30000;
+        DoCast(m_creature, SPELL_EXPOSED_HEART);
+        heartdamage = 0;
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+        heartdamage += uiDamage;
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (heartdamage != 0)
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_XT002))))
+                if (pTemp->isAlive())
+                {
+                    pTemp->DealDamage(pTemp, heartdamage, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                    heartdamage = 0;
+                }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (Exposed_Timer < diff)
+        {
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_XT002))))
+                if (pTemp->isAlive())
+                    pTemp->DealDamage(pTemp, heartdamage, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            heartdamage = 0;
+            m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }else Exposed_Timer -= diff;
+
+    }
+
+};
+
+CreatureAI* GetAI_mob_xtheart(Creature* pCreature)
+{
+    return new mob_xtheartAI(pCreature);
+}
+
+float XtAddX[4];
+float XtAddY[4];
+float XtAddZ[4];
+
+//XT-002 Deconstructor
+struct MANGOS_DLL_DECL boss_xt002AI : public ScriptedAI
+{
+    boss_xt002AI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        XtAddX[0] = 792.706f; XtAddY[0] = 64.033f; XtAddZ[0] = 413.632f;
+        XtAddX[1] = 879.750f; XtAddY[1] = 64.815f; XtAddZ[1] = 409.804f;
+        XtAddX[2] = 896.488f; XtAddY[2] = -93.018f; XtAddZ[2] = 411.731f;
+        XtAddX[3] = 791.016f; XtAddY[3] = -83.516f; XtAddZ[3] = 409.804f;
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    std::list<uint64> m_lScrapbotsGUIDList;
+    std::list<uint64> m_lBoombotsGUIDList;
+    std::list<uint64> m_lPummelerGUIDList;
+
+    uint32 Heart_Timer;
+    uint32 Light_Bomb_Timer;
+    uint32 Gravity_Bomb_Timer;
+    uint32 Tanctrum_Timer;
+    uint32 add_summon_delay;
+    uint32 Enrage_Timer;
+    uint32 Range_Check_Timer;
+    uint32 Addcount;
+    uint32 VoidZoneTimer;
+    uint32 LifeSparkTimer;
+    uint8 hp;
+    uint32 hpDelayTimer;
+    bool heart1;
+    bool heart2;
+    bool heart3;
+    bool enrage;
+    bool phase2;
+    bool add1;
+    bool add2;
+    bool add3;
+    bool add4;
+
+    uint64 pLightBombTarGUID;
+    uint64 pGravityBombTarGUID;
+
+    bool isHardMode;
+    bool hasMoreHealth;
+
+    uint32 uiEncounterTimer;
+
+    void Reset()
+    {
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+        Light_Bomb_Timer = 5000; //7 seconds the first 14 secs all after(7 secs in 25man)
+        Gravity_Bomb_Timer = 30000; //11 seconds first 18 secs all after(11 secs in 25man)
+        Tanctrum_Timer = 38000; // 38 seconds first 40 secs all after
+        add_summon_delay = 5000;
+        Enrage_Timer = 600000;
+        Range_Check_Timer = 1000;
+        VoidZoneTimer = 60000;
+        LifeSparkTimer = urand (5000, 10000);
+        hp = m_bIsRegularMode? 0.5 : 0.6;
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        Addcount = 0;
+        heart1 = false;
+        heart2 = false;
+        heart3 = false;
+        enrage = false;
+        phase2 = false;
+        add1 = false;
+        add2 = false;
+        add3 = false;
+        add4 = false;
+        isHardMode = false;
+        hasMoreHealth = false;
+        m_lScrapbotsGUIDList.clear();
+        m_lBoombotsGUIDList.clear();
+        m_lPummelerGUIDList.clear();
+
+        pLightBombTarGUID = 0;
+        pGravityBombTarGUID = 0;
+
+        uiEncounterTimer = 0;
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_XT002, DONE);
+            if(isHardMode)
+                m_pInstance->SetData(TYPE_XT002_HARD, DONE);
+        }
+
+        DoScriptText(SAY_DEATH, m_creature);
+        if (!m_lScrapbotsGUIDList.empty())
+        {
+            for(std::list<uint64>::iterator itr = m_lScrapbotsGUIDList.begin(); itr != m_lScrapbotsGUIDList.end(); ++itr)
+                if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                    pTemp->ForcedDespawn();
+        }
+        if (!m_lBoombotsGUIDList.empty())
+        {
+            for(std::list<uint64>::iterator itr = m_lBoombotsGUIDList.begin(); itr != m_lBoombotsGUIDList.end(); ++itr)
+                if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                    pTemp->ForcedDespawn();
+        }
+        if (!m_lPummelerGUIDList.empty())
+        {
+            for(std::list<uint64>::iterator itr = m_lPummelerGUIDList.begin(); itr != m_lPummelerGUIDList.end(); ++itr)
+                if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                    pTemp->ForcedDespawn();
+        }
+
+        // Deconstruct Fast
+        if (uiEncounterTimer < 205000)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_DECONSTRUCT_FAST : ACHIEV_DECONSTRUCT_FAST_H);
+        }
+
+        // Heartbreaker
+        if (isHardMode)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_HEARTBREAKER : ACHIEV_HEARTBREAKER_H);
+        }
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_XT002, IN_PROGRESS);
+        DoScriptText(SAY_AGGRO, m_creature);
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_XT002, FAIL);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 1))
+        {
+        case 0: DoScriptText(SAY_SLAY_01, m_creature); break;
+        case 1: DoScriptText(SAY_SLAY_02, m_creature); break;
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        // Achiev timer
+        uiEncounterTimer += diff;
+
+        if (Light_Bomb_Timer < diff && !phase2)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+            {
+                // fix spell range
+                //DoCast(pTarget, m_bIsRegularMode ? SPELL_LIGHT_BOMB : SPELL_LIGHT_BOMB_H);
+                pLightBombTarGUID = pTarget->GetGUID();
+            }
+
+            if(isHardMode)
+                LifeSparkTimer = 9000;
+
+            Light_Bomb_Timer = urand(10000, 14000);//m_bIsRegularMode ? 14000 :7000;
+        }else Light_Bomb_Timer -= diff;   
+
+        if (Gravity_Bomb_Timer < diff && !phase2)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+            {
+                // fix spell range
+                //DoCast(pTarget, m_bIsRegularMode ? SPELL_GRAVITY_BOMB : SPELL_GRAVITY_BOMB_H);
+                pGravityBombTarGUID = pTarget->GetGUID();
+            }
+
+            if(isHardMode)
+                VoidZoneTimer = 9000;
+
+            Gravity_Bomb_Timer = urand(25000, 30000);//18000 :11000; 
+        }else Gravity_Bomb_Timer -= diff;  
+
+        if (Tanctrum_Timer < diff && !phase2)
+        {
+            DoCast(m_creature, SPELL_TANCTRUM);
+            DoScriptText(SAY_TANCTRUM, m_creature);
+            Tanctrum_Timer = 40000;
+        }else Tanctrum_Timer -= diff;
+
+        if (Enrage_Timer < diff && !enrage && !phase2)
+        {
+            DoCast(m_creature, SPELL_ENRAGE);
+            if (m_creature->HasAura(SPELL_ENRAGE))
+            {
+                enrage = true;
+                DoScriptText(SAY_BERSERK, m_creature);
+            }
+            else
+                Enrage_Timer = 5000;
+        }else Enrage_Timer -= diff;
+
+        if (Range_Check_Timer < diff)
+        {
+            if (!m_lScrapbotsGUIDList.empty())
+            {
+                for(std::list<uint64>::iterator itr = m_lScrapbotsGUIDList.begin(); itr != m_lScrapbotsGUIDList.end(); ++itr)
+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                        if (pTemp->isAlive() && m_creature->IsWithinDistInMap(pTemp, ATTACK_DISTANCE))
+                        {
+                            m_creature->SetHealth(m_creature->GetHealth() + m_creature->GetMaxHealth() * 0.01);
+                            pTemp->DealDamage(pTemp, pTemp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                        }
+            }
+            if (!m_lBoombotsGUIDList.empty())
+            {
+                for(std::list<uint64>::iterator itr = m_lBoombotsGUIDList.begin(); itr != m_lBoombotsGUIDList.end(); ++itr)
+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                        if (pTemp->isAlive() && m_creature->IsWithinDistInMap(pTemp, ATTACK_DISTANCE))
+                        {
+                            pTemp->DealDamage(pTemp, pTemp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                        }
+            }
+            Range_Check_Timer = 1000;
+        }else Range_Check_Timer -= diff;
+
+        // Hard mode
+        
+        if (m_pInstance->GetData(TYPE_XT002) == SPECIAL && !isHardMode)
+        {
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_HEART))))
+            {
+                if (!pTemp->isAlive())
+                {
+                    DoScriptText(SAY_HEART_CLOSE, m_creature);
+                    m_creature->RemoveAurasDueToSpell(SPELL_STUN);
+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    m_creature->AI()->AttackStart(m_creature->getVictim());
+
+                    DoCast(m_creature, m_bIsRegularMode ? SPELL_HEARTBREAK : SPELL_HEARTBREAK_H);
+                    hpDelayTimer = 1000;
+                    hasMoreHealth = true;
+                    isHardMode = true;
+                }
+            }
+        }
+        
+        if(isHardMode)
+        {
+            phase2 = false;
+
+            if(hpDelayTimer < diff && hasMoreHealth)
+            {
+                m_creature->SetHealth(m_creature->GetMaxHealth()+ (m_creature->GetMaxHealth() * hp));
+                hasMoreHealth = false;
+            }else hpDelayTimer -= diff;
+
+            if (LifeSparkTimer < diff)
+            {
+                //TODO: fix the target -> should be the same with the light bomb
+                //if (Unit* pTarget = Unit::GetUnit(*m_creature, pLightBombTarGUID))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    Creature * LifeSpark = m_creature->SummonCreature(NPC_LIFESPARK, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 30000);
+                    if(m_bIsRegularMode)
+                        LifeSpark->SetHealth(50400);
+                }
+                LifeSparkTimer = 60000;
+            }else LifeSparkTimer -= diff;
+
+            if (VoidZoneTimer < diff)
+            {
+                //TODO: fix the target -> should be the same with the gravity bomb
+                //if (Unit* pTarget = Unit::GetUnit(*m_creature, pGravityBombTarGUID))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    m_creature->SummonCreature(NPC_VOIDZONE, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 180000);         
+                VoidZoneTimer = 60000;
+            }else VoidZoneTimer -= diff;
+        }
+
+        if (!phase2 && !heart1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 75)
+        {
+            Heart_Timer = 30000;
+            heart1 = true;
+            phase2 = true;
+            add1 = false;
+            add2 = false;
+            add3 = false;
+            add4 = false;
+            add_summon_delay = 5000;
+            DoScriptText(SAY_HEART_OPEN, m_creature);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            DoCast(m_creature, SPELL_STUN);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            Creature *Heart = m_creature->SummonCreature(NPC_HEART, 0.0f, 0.0f, 0.0f, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+            if(!m_bIsRegularMode)
+                Heart->SetMaxHealth(7199999);
+
+            if (m_pInstance)
+            {
+                m_pInstance->SetData(TYPE_XT002, SPECIAL);
+                //m_pInstance->SetData(DATA_HEART, Heart->GetGUID());
+            }
+        }
+
+        if (phase2 && Heart_Timer < diff)
+        {
+            DoScriptText(SAY_HEART_CLOSE, m_creature);
+            m_creature->RemoveAurasDueToSpell(SPELL_STUN);
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->AI()->AttackStart(m_creature->getVictim());
+            phase2 = false;
+            Light_Bomb_Timer = 7000;
+            Gravity_Bomb_Timer = 11000;
+            Tanctrum_Timer = 38000;
+
+            if (m_pInstance)
+                m_pInstance->SetData(TYPE_XT002, IN_PROGRESS);
+
+        }else Heart_Timer -= diff;
+
+        if(!isHardMode)
+        {
+            if (!phase2 && heart1 && !heart2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
+            {
+                Heart_Timer = 30000;
+                heart2 = true;
+                phase2 = true;
+                add1 = false;
+                add2 = false;
+                add3 = false;
+                add4 = false;
+                add_summon_delay = 5000;
+                DoScriptText(SAY_HEART_OPEN, m_creature);
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                DoCast(m_creature, SPELL_STUN);
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                Creature *Heart = m_creature->SummonCreature(NPC_HEART, 0.0f, 0.0f, 0.0f, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                if(!m_bIsRegularMode)
+                    Heart->SetMaxHealth(7199999);
+
+                if (m_pInstance)
+                {
+                    //m_pInstance->SetData(TYPE_XT002, SPECIAL);
+                    //m_pInstance->SetData(DATA_HEART, Heart->GetGUID());
+                }
+            }
+
+            if (!phase2 && heart1 && heart2 && !heart3 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 25)
+            {
+                Heart_Timer = 30000;
+                heart3 = true;
+                phase2 = true;
+                add1 = false;
+                add2 = false;
+                add3 = false;
+                add4 = false;
+                add_summon_delay = 5000;
+                DoScriptText(SAY_HEART_OPEN, m_creature);
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                DoCast(m_creature, SPELL_STUN);
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                Creature *Heart = m_creature->SummonCreature(NPC_HEART, 0.0f, 0.0f, 0.0f, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                if(!m_bIsRegularMode)
+                    Heart->SetMaxHealth(7199999);
+
+                if (m_pInstance)
+                {
+                    //m_pInstance->SetData(TYPE_XT002, SPECIAL);
+                    //m_pInstance->SetData(DATA_HEART, Heart->GetGUID());
+                }
+            }
+
+            if (phase2 && add_summon_delay < diff)
+            {
+                if (!add1)
+                {
+                    Addcount = 0;
+                    do{
+                        if (Creature* pTemp = m_creature->SummonCreature(NPC_SCRAPBOT, XtAddX[0], XtAddY[0], XtAddZ[0], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                        {
+                            pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                            pTemp->AI()->AttackStart(m_creature->getVictim());
+                            m_lScrapbotsGUIDList.push_back(pTemp->GetGUID());
+                            Addcount++;
+                        }} while(Addcount<3);
+                        Addcount = 0;
+                        do{
+                            if (Creature* pTemp = m_creature->SummonCreature(NPC_BOOMBOT, XtAddX[0], XtAddY[0], XtAddZ[0], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                            {
+                                pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                                pTemp->AI()->AttackStart(m_creature->getVictim());
+                                m_lBoombotsGUIDList.push_back(pTemp->GetGUID());
+                                Addcount++;
+                            }} while(Addcount<1);
+                            add1 = true;
+                            add_summon_delay = 4000;
+                }
+                if (!add2 && add1)
+                {
+                    Addcount = 0;
+                    do{
+                        if (Creature* pTemp = m_creature->SummonCreature(NPC_SCRAPBOT, XtAddX[1], XtAddY[1], XtAddZ[1], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                        {
+                            pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                            pTemp->AI()->AttackStart(m_creature->getVictim());
+                            m_lScrapbotsGUIDList.push_back(pTemp->GetGUID());
+                            Addcount++;
+                        }} while(Addcount<3);
+                        Addcount = 0;
+                        do{
+                            if (Creature* pTemp = m_creature->SummonCreature(NPC_BOOMBOT, XtAddX[1], XtAddY[1], XtAddZ[1], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                            {
+                                pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                                pTemp->AI()->AttackStart(m_creature->getVictim());
+                                m_lBoombotsGUIDList.push_back(pTemp->GetGUID());
+                                Addcount++;
+                            }} while(Addcount<1);
+                            add2 = true;
+                            DoScriptText(SAY_ADDS, m_creature);
+                            add_summon_delay = 1000;
+                }
+                if (!add3 && add2 && add1)
+                {
+                    Addcount = 0;
+                    do{
+                        if (Creature* pTemp = m_creature->SummonCreature(NPC_SCRAPBOT, XtAddX[2], XtAddY[2], XtAddZ[2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                        {
+                            pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                            pTemp->AI()->AttackStart(m_creature->getVictim());
+                            m_lScrapbotsGUIDList.push_back(pTemp->GetGUID());
+                            Addcount++;
+                        }} while(Addcount<3);
+                        Addcount = 0;
+                        do{
+                            if (Creature* pTemp = m_creature->SummonCreature(NPC_BOOMBOT, XtAddX[2], XtAddY[2], XtAddZ[2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                            {
+                                pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                                pTemp->AI()->AttackStart(m_creature->getVictim());
+                                m_lBoombotsGUIDList.push_back(pTemp->GetGUID());
+                                Addcount++;
+                            }} while(Addcount<1);
+                            add3 = true;
+                            add_summon_delay = 4000;
+                }
+                if (!add4 && add3 && add2 && add1)
+                {
+                    if (Creature* pTemp = m_creature->SummonCreature(NPC_PUMMELER, XtAddX[3], XtAddY[3], XtAddZ[3], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                        {
+                            pTemp->AddThreat(pTarget,0.0f);
+                            pTemp->AI()->AttackStart(pTarget);
+                            m_lPummelerGUIDList.push_back(pTemp->GetGUID());
+                        }
+                        Addcount = 0;
+                        do{
+                            if (Creature* pTemp = m_creature->SummonCreature(NPC_SCRAPBOT, XtAddX[3], XtAddY[3], XtAddZ[3], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                            {
+                                pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                                pTemp->AI()->AttackStart(m_creature->getVictim());
+                                m_lScrapbotsGUIDList.push_back(pTemp->GetGUID());
+                                Addcount++;
+                            }} while(Addcount<3);
+                            Addcount = 0;
+                            do{
+                                if (Creature* pTemp = m_creature->SummonCreature(NPC_BOOMBOT, XtAddX[3], XtAddY[3], XtAddZ[3], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                                {
+                                    pTemp->AddThreat(m_creature->getVictim(),1000.0f);
+                                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                                    m_lBoombotsGUIDList.push_back(pTemp->GetGUID());
+                                    Addcount++;
+                                }} while(Addcount<1);
+                                add4 = true;
+                                add_summon_delay = 30000;
+                }
+            }else add_summon_delay -= diff;
+        }
+
+        if (!phase2)
+            DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_xt002(Creature* pCreature)
+{
+    return new boss_xt002AI(pCreature);
+}
+
+void AddSC_boss_xt002()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_xt002";
+    NewScript->GetAI = GetAI_boss_xt002;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_pummeler";
+    NewScript->GetAI = &GetAI_mob_pummeler;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_boombot";
+    NewScript->GetAI = &GetAI_mob_boombot;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_xtheart";
+    NewScript->GetAI = &GetAI_mob_xtheart;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_voidzone";
+    NewScript->GetAI = &GetAI_mob_voidzone;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_lifespark";
+    NewScript->GetAI = &GetAI_mob_lifespark;
+    NewScript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/boss_yogg_saron.cpp b/scripts/northrend/ulduar/ulduar/boss_yogg_saron.cpp
new file mode 100644
index 0000000..6c16f2f
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/boss_yogg_saron.cpp
@@ -0,0 +1,3044 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: boss_yogg_saron
+SD%Complete: 90%
+SDComment:  sanity, improve keepers, timers
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+enum
+{
+    //yells
+    //sara
+    SAY_INTRO1                  = -1603307,
+    SAY_INTRO2                  = -1603308,
+    SAY_AGGRO                   = -1603300,
+    SAY_HELP1                   = -1603301,
+    SAY_HELP2                   = -1603302,
+    SAY_SPECIAL1                = -1603305,
+    SAY_SPECIAL2                = -1603306,
+    SAY_KILL1                   = -1603303,
+    SAY_KILL2                   = -1603304,
+    SAY_WIPE                    = -1603309,
+
+    //yogg
+    SAY_PHASE2                  = -1603321,
+    SAY_VISION                  = -1603322,
+    SAY_PHASE3                  = -1603323,
+    SAY_SLAY1                   = -1603324,
+    SAY_SLAY2                   = -1603325,
+    SAY_DEATH                   = -1603326,
+    SAY_INSANITY1               = -1603327,
+    SAY_INSANITY2               = -1603328,
+
+    //visions
+    //stormwind
+    SAY_GARONA1                 = -1603341,
+    SAY_GARONA2                 = -1603342,
+    SAY_YOGG_V1_1               = -1603343,
+    SAY_YOGG_V1_2               = -1603344,
+    SAY_GARONA3                 = -1603345,
+    SAY_GARONA4                 = -1603346,
+    SAY_YOGG_V1_3               = -1603347,
+
+    //dragons
+    SAY_NELTHARION1             = -1603336,
+    SAY_YSERA                   = -1603337,
+    SAY_NELTHARION2             = -1603338,
+    SAY_MALYGOS                 = -1603339,
+    SAY_YOGG_V2                 = -1603340,
+
+    //lich king
+    SAY_LICH_KING1              = -1603330,
+    SAY_CHAMPION1               = -1603331,
+    SAY_CHAMPION2               = -1603332,
+    SAY_LICH_KING2              = -1603333,
+    SAY_YOGG_V3_1               = -1603334,
+    SAY_YOGG_V3_2               = -1603335,
+
+    //keepers yells
+    SAY_HODIR_ACTIVE            = -1603086,
+    SAY_FREYA_ACTIVE            = -1603009,
+    SAY_THORIM_ACTIVE           = -1603238,
+    SAY_MIMIRON_ACTIVE          = -1603260,
+
+    //vision npc
+    //stormwind
+    NPC_GARONA                  = 33436,
+    NPC_KING_LLANE              = 33437,
+
+    MOB_SUIT_OF_ARMOR           = 33433,
+
+    //dragons
+    NPC_NELTHARION              = 33523,
+    NPC_YSERA                   = 33495,
+    NPC_MALYGOS                 = 33535,
+    NPC_ALEXSTRASZA             = 33536,
+    GO_DRAGON_SOUL              = 194462,
+
+    MOB_RUBY_CONSORT            = 33716,
+    MOB_AZURE_CONSORT           = 33717,
+    MOB_BRONZE_CONSORT          = 33718,
+    MOB_EMERALD_CONSORT         = 33719,
+    MOB_OBSIDIAN_CONSORT        = 33720,
+
+
+    //lich king
+    NPC_LICH_KING               = 33441,
+    NPC_IMMOLATED_CHAMPION      = 33442,
+
+    NPC_VOICE_OF_YOGG_SARON     = 33280,
+    MOB_VISION_TENTACLE         = 33943,
+    // npc hp: 15k on 10 man; 40k on 25 man
+    // npc no: 10
+
+    //spells
+    //phase1
+    SPELL_SARAS_FERVOR          = 63138,
+    SPELL_SARAS_BLESSING        = 63134,
+    SPELL_SARAS_ANGER           = 63147,
+    SPELL_DAMAGE_IMMUNE         = 34311,
+
+    MOB_GUARDIAN_OF_YOGG        = 33136,
+    SPELL_DARK_VOLLEY           = 63038,
+    SPELL_SHADOW_NOVA           = 62714,    //when dies
+    SPELL_SHADOW_NOVA_H         = 65209,
+    SPELL_DOMINATE_MIND         = 63713,
+
+    //phase2
+    SPELL_EMERGE                = 20568,    // from ragnaros
+    SPELL_SHADOWY_BARRIER       = 64775,
+    SPELL_SHADOWY_BARRIER_YOGG  = 63894,
+    SPELL_SANITY                = 63050,
+    SPELL_PHYCHOSIS             = 65301,
+    SPELL_PHYCHOSIS_H           = 63795,
+    SPELL_MALADY_OF_THE_MIND    = 63830,
+    SPELL_BRAIN_LINK            = 63802,
+    SPELL_DEATH_RAY             = 63891,    //summons 4 death orbs
+    MOB_DEATH_ORB               = 33882,
+    SPELL_DEATH_RAY_AURA        = 63883,
+    SPELL_DEATH_RAY_VISUAL      = 63886,
+
+    // portals
+    MOB_DESCEND_INTO_MADNESS    = 34072,
+    SPELL_LUNATIC_GAZE          = 64167,    //affects players which take the portal to madness
+    NPC_LAUGHING_SKULL          = 33990,
+
+    // brain's chamber
+    MOB_BRAIN_OF_YOGG_SARON     = 33890,
+    SPELL_SHATTERED_ILLUSION    = 64173,
+    SPELL_INDUCE_MADNESS        = 64059,
+
+
+    // tentacules
+    MOB_CRUSHER_TENTACLE        = 33966,
+    SPELL_ERUPT                 = 64144,    //also used by the corruptor tentacle
+    SPELL_DIMINISH_POWER        = 64145,
+    SPELL_FOCUSED_ANGER         = 57689,
+
+    MOB_CONSTRICTOR_TENTACLE    = 33983,
+    SPELL_SQUEEZE               = 64125,
+    SPELL_SQUEEZE_H             = 64126,
+
+    MOB_CORRUPTOR_TENTACLE      = 33985,
+    SPELL_APATHY                = 64156,
+    SPELL_BLACK_PLAGUE          = 64153,
+    SPELL_CURSE_OF_DOOM         = 64157,
+    SPELL_DRAINING_POISON       = 64152,
+
+    // phase 3
+    SPELL_LUNATIC_GAZE_YOGG     = 64163,
+    SPELL_SHADOW_BEACON         = 64465,
+    SPELL_EMPOWERING_SHADOWS    = 64468,
+    SPELL_EMPOWERING_SHADOWS_H  = 64486,
+    SPELL_DEAFENING_ROAR        = 64189,    //only cast on 25 player with 0-3 keepes active
+
+    MOB_IMMORTAL_GUARDIAN       = 33988,
+    SPELL_EMPOWERED             = 65294,    //starts with 9 stacks and loses 1 stak at 10% hp
+
+    SPELL_BERSERK               = 64166,    //26662, extinguish all life
+
+    // keepers
+    KEEPER_FREYA                = 33410,
+    SPELL_RESILIENCE_OF_NATURE  = 62670,
+    MOB_SANITY_WELL             = 33991,
+    SPELL_SANITY_WELL           = 64169,    // regen sanity
+
+    KEEPER_HODIR                = 33411,
+    SPELL_FORTITUDE_OF_FROST    = 62650,
+    SPELL_HODIRS_PROTECTIVE_GAZE= 64174,    // saves players from killing blows ~25secs cd
+
+    KEEPER_MIMIRON              = 33412,
+    SPELL_SPEED_OF_INVENTION    = 62671,
+    SPELL_DESTABILIZATION_MATRIX= 65210,    // cast in phase 2 on the tentacules
+
+    KEEPER_THORIM               = 33413,
+    SPELL_FURY_OF_THE_STORM     = 62702,
+    SPELL_TITANIC_STORM         = 64171,    // used in phase 3 to kill guardians
+};
+
+//Positional defines 
+struct LocationsXY
+{
+    float x, y, z, o;
+    uint32 id;
+};
+static LocationsXY SummonLoc[]=
+{
+    {1951.097412f,-25.42042f, 326.162598f},
+    {1970.677490f,-0.211162f, 325.478638f},
+    {2001.049805f,-4.201718f, 325.751831f},
+    {2009.346924f,-26.001806f,325.603271f},
+    {1998.081665f,-46.625187f,325.551605f}, 
+    {1962.782715f,-51.363148f,325.458160f},
+    {1988.847778f,-71.143738f,328.647614f},
+    {2024.004150f,-40.749989f,327.876617f},
+    {2018.806885f,-3.451158f,327.593933f},
+    {1978.651001f,18.373478f,328.420532f},
+    {1940.641602f,1.761525f, 327.921661f},
+    {1941.203735f,-52.999535f,327.246948f},
+};
+
+static LocationsXY SanityWellLoc[]=
+{
+    {1901.237915f, -46.305782f, 331.960754f}, 
+    {1900.753052f,  -2.259287f, 332.061249f}, 
+    {1991.020996f,  43.943943f, 331.746979f},
+    {2044.219482f, -21.878244f, 329.776855f},
+    {1986.226807f, -95.087761f, 330.253998f},
+};
+
+static LocationsXY KeepersLoc[]=
+{
+    {2036.859863f,  -74.113884f, 338.415222f, 2.488684f}, //thorim
+    {1938.328247f,  -90.742043f, 338.459442f, 0.992500f}, //hodir
+    {2036.107056f,  25.702380f,  338.415192f, 4.019527f}, // freya
+    {1939.021240f,  43.221031f,  338.460663f, 5.214388f}, // mimiron
+};
+
+static LocationsXY TeleportLoc[]=
+{
+    {1941.587402f, 43.526680f,  239.666336f},    // stormwind
+    {2055.460938f, -25.619570f, 239.721176f},    // dragons
+    {1941.131226f, -94.654694f, 239.989639f},    // icecrown
+    {1951.097f, -25.420f, 326.162f},             // yogg
+};
+
+static LocationsXY YoggPortalLoc[]=
+{
+    {1959.765137f, -20.697853f, 325.352966f},   
+    {1973.407837f,  -6.656567f, 324.889526f},  
+    {1990.271851f, -47.992981f, 324.959991f}, 
+    {1978.893433f, -49.858326f, 324.777618f},
+    {1967.471924f, -46.298458f, 324.840759f},
+    {1959.654297f, -39.954502f, 324.997253f},
+    {1956.343872f, -25.642859f, 325.188354f},
+    {1985.072021f,  -2.515451f, 325.20010f},
+    {1993.541626f, -10.527716f, 324.889587f}, 
+    {2003.674316f, -23.050785f, 325.384064f}, 
+};
+
+static LocationsXY MadnessPortalLoc[]=
+{
+    {2001.015f,   4.185f, 242.747f},    
+    {1999.690f, -54.931f, 242.418f},    
+    {1946.898f, -25.769f, 242.169f},    
+};
+// vison pos
+//Positional defines 
+struct VisionLocXY
+{
+    float x, y, z, o;
+    uint32 id;
+};
+// dragons
+const float PosYsera[4] = {2114.504f, -16.118f, 242.646f, 3.91f};
+const float PosMalygos[4] = {2113.388f, -34.381f, 242.646f, 2.26f};
+const float PosNeltharion[4] = {2117.588f, -25.318f,  242.646f, 3.15f};
+const float PosAlexstrasza[4] = {2091.679f, -25.289f, 242.646f, 6.282f};
+const float PosVoiceDragon[3] = {2104.555f, -25.635f, 242.646f};
+const float DisplayDragons[10] = {2718, 2718, 2717, 2717, 12869, 12869, 1687, 1687, 2719, 2719};
+
+static VisionLocXY DragonLoc[]=
+{
+    {2071.951660f,   1.881840f, 239.794922f, 5.590341f},
+    {2093.910156f,  19.939915f, 239.766830f, 4.962034f},
+    {2114.737061f,  20.441664f, 239.757309f, 4.259104f},
+    {2136.709473f,   4.874056f, 239.718658f, 3.889961f},
+    {2147.894287f, -12.416141f, 239.757980f, 3.210588f},
+    {2148.479004f, -37.655373f, 239.720169f, 3.033874f},
+    {2136.296631f, -56.800838f, 239.754654f, 2.287745f},
+    {2114.370117f, -68.110947f, 239.721100f, 1.789017f},
+    {2093.946289f, -67.447899f, 239.720734f, 1.305995f},
+    {2071.001709f, -54.414040f, 239.719345f, 0.528450f},
+};
+
+// stormwind
+const float PosGarona[4] = {1935.398926f, 54.017738f, 240.376465f, 2.008213f};
+const float PosKing[4] = {1930.465670f, 62.674065f, 242.376373f, 5.196925f};
+const float PosVoiceStormwind[3] = {1927.326f, 68.120f, 242.376f}; 
+
+static VisionLocXY KeepLoc[]=
+{
+    {1930.854370f, 39.910034f, 239.666443f, 1.641476f},
+    {1909.771240f, 45.685230f, 239.666443f, 0.962106f},
+    {1898.966309f, 64.644989f, 239.666443f, 0.157073f},
+    {1904.273926f, 85.369118f, 239.666443f, 5.662714f},
+    {1923.474487f, 96.419815f, 239.666443f, 4.826267f},
+    {1944.612061f, 91.062439f, 239.666443f, 4.076213f},
+    {1955.231079f, 71.870926f, 239.666443f, 3.255475f},
+    {1949.701416f, 51.040390f, 239.666443f, 2.481856f},
+};
+
+// lich king
+const float PosLichKing[4] = {1910.499268f,-147.709961f,239.989639f, 0.943203f};
+const float PosChampion[4] = {1915.371094f,-139.934219f,239.989639f, 4.159409f};
+const float PosVoiceIcecrown[3] = {1914.332f, -139.317f, 239.989f}; 
+
+static VisionLocXY IcecrownLoc[]=
+{
+    {1952.521606f, -137.052094f, 239.989716f, 2.513270f},
+    {1946.220337f, -130.236008f, 239.989716f, 5.387829f},
+    {1942.029541f, -136.833328f, 239.989716f, 0.192416f},
+    {1896.965210f, -104.922951f, 239.989716f, 5.647007f},
+    {1904.356079f, -113.879349f, 239.989716f, 2.163766f},
+    {1907.664795f, -106.186508f, 239.989716f, 2.976653f},
+    {1919.831421f, -131.184784f, 239.989716f, 4.213656f},
+    {1919.120728f, -145.960281f, 239.989716f, 1.908511f},
+    {1907.462891f, -139.149307f, 239.989716f, 0.176708f},
+};
+
+#define REQUEST_HELP    "Help me fight Yogg-Saron!"
+#define DENY_HELP       "I don't need your help."
+
+// location of the minds eye:
+// X: 1981.422974 Y: -22.442831 Z: 236.104813
+
+// transfer from brain
+//  X: 1951.097412 Y: -25.420420 Z: 326.162598 Orientation: 0.131792
+// brain room portal loc: 
+// sara -> type_flags = 108; original
+
+uint8 m_uiKeepersAlive;
+
+struct MANGOS_DLL_DECL boss_yogg_saronAI : public ScriptedAI
+{
+    boss_yogg_saronAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        //pCreature->setFaction(35);
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        SetCombatMovement(false);
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    bool isPhase3;
+    bool isPhase2;
+    uint32 berserkTimer;
+    uint32 sanityTimer;
+
+    uint32 lunaticGazaTimer;
+    uint32 shadowBeaconTimer;
+    uint32 empoweringShadowsTimer;
+    uint32 summonTimer;
+    uint32 deafeningRoarTimer;
+
+    Creature *pGuardian;
+    std::list<Creature*> lGuardianList;
+
+    std::list<uint64> m_lGuardGUIDList;
+
+    void Reset()
+    {
+        isPhase3 = false;
+        isPhase2 = false;
+        sanityTimer = 10000;
+        m_uiKeepersAlive = 0;
+        //m_creature->setFaction(35);
+        m_creature->SetVisibility(VISIBILITY_OFF);
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+
+        lGuardianList.clear();
+        m_lGuardGUIDList.clear();
+
+        if(m_pInstance) m_pInstance->SetData(TYPE_YOGGSARON, NOT_STARTED);
+
+        if(m_creature->HasAura(SPELL_SHADOWY_BARRIER_YOGG))
+            m_creature->RemoveAurasDueToSpell(SPELL_SHADOWY_BARRIER_YOGG);
+    }
+
+    void Aggro(Unit *who) 
+    {
+        //if(m_pInstance) m_pInstance->SetData(TYPE_YOGGSARON, IN_PROGRESS);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(irand(0,1))
+            DoScriptText(SAY_SLAY1, m_creature);
+        else
+            DoScriptText(SAY_SLAY2, m_creature);
+    }
+
+    void JustDied(Unit *killer)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+        m_lGuardGUIDList.clear();
+        if(m_pInstance) 
+        {
+            m_pInstance->SetData(TYPE_YOGGSARON, DONE);
+
+            if(m_uiKeepersAlive == 0)
+                m_pInstance->SetData(TYPE_YOGGSARON_HARD, DONE);
+        }
+
+        GetCreatureListWithEntryInGrid(lGuardianList, m_creature, MOB_IMMORTAL_GUARDIAN, DEFAULT_VISIBILITY_INSTANCE);
+
+        if (!lGuardianList.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lGuardianList.begin(); iter != lGuardianList.end(); ++iter)
+            {
+                if ((*iter) && !(*iter)->isAlive())
+                    (*iter)->ForcedDespawn();
+            }
+        }
+    }
+
+    void StartSecondPhase()
+    {
+        m_creature->SetVisibility(VISIBILITY_ON);
+        //DoCast(m_creature, SPELL_EMERGE); 
+        m_creature->setFaction(14);
+        isPhase2 = true;
+        DoCast(m_creature, SPELL_SHADOWY_BARRIER_YOGG);
+    }
+
+    void StartThirdPhase(uint32 bsrkTimer)
+    {
+        DoScriptText(SAY_PHASE3, m_creature);
+        m_creature->RemoveAurasDueToSpell(SPELL_SHADOWY_BARRIER_YOGG);
+        m_creature->SetHealth(m_creature->GetMaxHealth() * 0.3);
+        berserkTimer = bsrkTimer;
+        lunaticGazaTimer        = 20000;
+        shadowBeaconTimer       = 15000;
+        empoweringShadowsTimer  = 60000;
+        summonTimer             = 40000;
+        deafeningRoarTimer      = 30000;
+        isPhase3 = true;
+    }
+
+    void CastShatterIllusion()
+    {
+        //DoCast(m_creature, SPELL_SHATTERED_ILLUSION); // spell is broken -> is cast on players and should be cast on Yogg & tentacles
+    }
+
+    Creature* SelectRandomGuardian(float fRange)
+    {
+        std::list<Creature* > lGuardiansList;
+        GetCreatureListWithEntryInGrid(lGuardiansList, m_creature, MOB_IMMORTAL_GUARDIAN, fRange);
+
+        //This should not appear!
+        if (lGuardiansList.empty()){
+            empoweringShadowsTimer = 30000;
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lGuardiansList.begin();
+        advance(iter, urand(0, lGuardiansList.size()-1));
+
+        return *iter;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(isPhase3 || isPhase2)
+        {
+            if (sanityTimer < uiDiff)
+            {
+                DoCast(m_creature, SPELL_SANITY);
+                sanityTimer = 20000;
+            }else sanityTimer -= uiDiff;
+        }
+
+        if(isPhase3)
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            {
+                if(m_pInstance) 
+                    m_pInstance->SetData(TYPE_YOGGSARON, FAIL);
+                Reset();
+                return;
+            }
+            if (summonTimer < uiDiff)
+            {
+                uint8 i = urand(0, 11);
+                if(Creature *pTemp = m_creature->SummonCreature(MOB_IMMORTAL_GUARDIAN, SummonLoc[i].x, SummonLoc[i].y, SummonLoc[i].z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                {
+                    if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    {
+                        pTemp->AddThreat(pTarget,0.0f);
+                        pTemp->AI()->AttackStart(pTarget);
+                        pTemp->SetInCombatWithZone();
+                        m_lGuardGUIDList.push_back(pTemp->GetGUID());
+                    }
+                }
+                summonTimer = 40000;
+            }else summonTimer -= uiDiff;
+
+            if (lunaticGazaTimer < uiDiff)
+            {
+                DoCast(m_creature, SPELL_LUNATIC_GAZE_YOGG);
+                lunaticGazaTimer = 30000;
+            }else lunaticGazaTimer -= uiDiff;
+
+            if (empoweringShadowsTimer < uiDiff)
+            {
+                if (pGuardian = SelectRandomGuardian(80.0f))
+                    DoCast(pGuardian, m_bIsRegularMode ? SPELL_EMPOWERING_SHADOWS : SPELL_EMPOWERING_SHADOWS_H);
+                empoweringShadowsTimer = 60000;
+            }else empoweringShadowsTimer -= uiDiff;
+
+            if (deafeningRoarTimer < uiDiff)
+            {
+                if(!m_bIsRegularMode && m_uiKeepersAlive < 4)
+                    DoCast(m_creature, SPELL_DEAFENING_ROAR);
+                deafeningRoarTimer = 30000;
+            }else deafeningRoarTimer -= uiDiff;
+
+            if (berserkTimer < uiDiff)
+            {
+                DoCast(m_creature, SPELL_BERSERK);
+                berserkTimer = 300000;
+            }else berserkTimer -= uiDiff;
+
+            DoMeleeAttackIfReady();
+        }
+    }
+};
+
+struct MANGOS_DLL_DECL mob_madness_portalAI : public ScriptedAI
+{
+    mob_madness_portalAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint8 m_uiDestination;
+    uint32 m_uiCheckTimer;
+
+    void Reset()
+    {
+        m_uiDestination = 10;
+        m_uiCheckTimer = 500;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_pInstance)
+        {
+            if(m_pInstance->GetData(TYPE_VISION1) == IN_PROGRESS)
+                m_uiDestination = 0;
+
+            if(m_pInstance->GetData(TYPE_VISION2) == IN_PROGRESS)
+                m_uiDestination = 1;
+
+            if(m_pInstance->GetData(TYPE_VISION3) == IN_PROGRESS)
+                m_uiDestination = 2;
+        }
+
+        if(m_creature->GetPositionZ() < 245.0f)
+            m_uiDestination = 3;
+
+        if(m_uiCheckTimer < uiDiff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                    {
+                        i->getSource()->TeleportTo(i->getSource()->GetMapId(), TeleportLoc[m_uiDestination].x, TeleportLoc[m_uiDestination].y, TeleportLoc[m_uiDestination].z, i->getSource()->GetOrientation());
+                        if(m_uiDestination < 3)
+                            m_creature->ForcedDespawn();
+                            //m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                    }
+                }
+            } 
+            m_uiCheckTimer = 500;
+        }else m_uiCheckTimer -= uiDiff;
+    }
+};
+
+struct MANGOS_DLL_DECL boss_brain_of_yogg_saronAI : public ScriptedAI
+{
+    boss_brain_of_yogg_saronAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 berserkTimer;
+    uint8 vision;
+    uint8 m_uiVisionPhase;
+    uint32 m_uiSpeechTimer;
+    uint32 madnessTimer;
+    uint32 tentacleCheckTimer;
+    bool isStormWindVision;
+    bool isDragonVision;
+    bool isLichKingVision;
+
+    bool isOver;
+    bool isVisionFinished;
+
+    Creature *LichKing;
+    Creature *Champion;
+    Creature *Garona;
+    Creature *KingLlane;
+    Creature *Neltharion;
+    Creature *Malygos;
+    Creature *Ysera;
+    Creature *VoiceOfYogg;
+
+    std::list<Creature*> lPortals;
+    std::list<uint64> PlayerList;
+
+    void Reset()
+    {
+        isStormWindVision   = false;
+        isDragonVision      = false;
+        isLichKingVision    = false;
+        isOver              = false;
+
+        m_uiVisionPhase     = 0;
+        m_uiSpeechTimer     = 1000;
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+
+        if(m_pInstance) 
+        {
+            m_pInstance->SetData(TYPE_VISION1, NOT_STARTED);
+            m_pInstance->SetData(TYPE_VISION2, NOT_STARTED);
+            m_pInstance->SetData(TYPE_VISION3, NOT_STARTED);
+            m_pInstance->SetData(TYPE_YOGG_BRAIN, NOT_STARTED);
+        }
+
+        lPortals.clear();
+        PlayerList.clear();
+    }
+
+    void Aggro(Unit *who) 
+    {
+        // fix how the creature looks! it should be positioned upper, but the melee can still reach him. Strange...
+        //StartVisions(2, 600000);    //for debug only!
+        m_creature->GetMotionMaster()->MoveIdle();
+        m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), 255.011f, 0.0f);
+        m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), 255.011f, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        // player list
+        if (m_creature->IsHostileTo(pWho) && !ListContains(PlayerList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 80, true) && m_creature->IsWithinLOSInMap(pWho))
+            PlayerList.push_back(pWho->GetGUID());
+    }
+
+    bool ListContains(std::list<uint64> &plist, uint64 element)
+    {
+        if (plist.empty())
+            return false;
+
+        std::list<uint64>::iterator i;
+        for (i = plist.begin(); i!=plist.end(); ++i)
+        {
+            if ((*i) == element)
+                return true;
+        }
+        return false;
+    }
+
+    void KillPlayers()
+    {
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (PlayerList.isEmpty())
+                return;
+
+            for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+            {
+                if (i->getSource()->isAlive() && m_creature->IsWithinLOSInMap(i->getSource()) && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 200.0f)
+                    //i->getSource()->TeleportTo(pTemp->GetMapId(), TeleportLoc[3].x, TeleportLoc[3].y, TeleportLoc[3].z, pTemp->GetOrientation());
+                    i->getSource()->DealDamage(i->getSource(), i->getSource()->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            }
+        } 
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= 30)
+            uiDamage = 0;
+
+        if(uiDamage > 0 && m_creature->IsWithinDistInMap(done_by, 35))
+        {
+            if (Creature* pYogg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGGSARON))))
+            {
+                if(pYogg->isAlive())
+                    ((boss_yogg_saronAI*)pYogg->AI())->CastShatterIllusion();
+            }
+        }
+    }
+
+    void SummonPortals()
+    {
+        for(uint8 i = 0; i < 3; i++)
+            m_creature->SummonCreature(MOB_DESCEND_INTO_MADNESS, MadnessPortalLoc[i].x, MadnessPortalLoc[i].y, MadnessPortalLoc[i].z, 0, TEMPSUMMON_TIMED_DESPAWN, 60000);
+    }
+
+    void StartVisions(uint8 v, uint32 bsrkTimer)
+    {
+        berserkTimer = bsrkTimer;
+        vision = v;
+        PlayerList.clear();
+        DoCast(m_creature, SPELL_INDUCE_MADNESS);
+        m_uiVisionPhase     = 0;
+        m_uiSpeechTimer     = 1000;
+        tentacleCheckTimer  = 1000;
+        madnessTimer        = 60000;
+        isVisionFinished    = false;
+        switch(vision)
+        {
+        case 1:
+            isStormWindVision = true;
+            break;
+        case 2:
+            isDragonVision = true;
+            break;
+        case 3:
+            isLichKingVision = true;
+            break;
+        }
+    }
+
+    bool IsThereAnyAdd(WorldObject *source)
+    {
+        if(GetClosestCreatureWithEntry(source, MOB_VISION_TENTACLE, 80.0f))
+            return true;
+
+        return false;
+    }
+
+    void SelfDestruct()
+    {
+        m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(isStormWindVision)
+        {
+            if(m_uiSpeechTimer < uiDiff)
+            {
+                switch(m_uiVisionPhase)
+                {
+                case 0:
+                    Garona = m_creature->SummonCreature(NPC_GARONA, PosGarona[0], PosGarona[1], PosGarona[2], PosGarona[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    KingLlane = m_creature->SummonCreature(NPC_KING_LLANE, PosKing[0], PosKing[1], PosKing[2], PosKing[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    VoiceOfYogg = m_creature->SummonCreature(NPC_VOICE_OF_YOGG_SARON, PosVoiceStormwind[0], PosVoiceStormwind[1], PosVoiceStormwind[2], 0, TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    VoiceOfYogg->SetVisibility(VISIBILITY_OFF);
+                    for(uint8 i = 0; i < 8; i++)
+                    {
+                        if(Creature *pTemp = m_creature->SummonCreature(MOB_VISION_TENTACLE, KeepLoc[i].x, KeepLoc[i].y, KeepLoc[i].z, KeepLoc[i].o, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 80000))
+                        {
+                            pTemp->SetDisplayId(28621);
+                            pTemp->SetMaxHealth(m_bIsRegularMode ? 15000 : 40000);
+                            pTemp->setFaction(7); 
+                        }
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 1000;
+                    break;
+                case 1:
+                    DoScriptText(SAY_GARONA1, Garona);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 12000;
+                    break;
+                case 2:
+                    DoScriptText(SAY_GARONA2, Garona);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 12000;
+                    break;
+                case 3:
+                    DoScriptText(SAY_YOGG_V1_1, VoiceOfYogg);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 4000;
+                    break;
+                case 4:
+                    DoScriptText(SAY_YOGG_V1_2, VoiceOfYogg);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 4000;
+                    break;
+                case 5:
+                    DoScriptText(SAY_GARONA3, KingLlane);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 6000;
+                    break;
+                case 6:
+                    Garona->GetMotionMaster()->MovePoint(0, 1931.348f, 61.033f, 241.709f);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 6000;
+                    break;
+                case 7:
+                    DoScriptText(SAY_GARONA4, Garona);
+                    KingLlane->SetStandState(UNIT_STAND_STATE_DEAD);
+                    KingLlane->SetHealth(0);
+                    Garona->Attack(KingLlane, true);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 6000;
+                    break;
+                case 8:
+                    Garona->AttackStop();
+                    DoScriptText(SAY_YOGG_V1_3, VoiceOfYogg);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 8000;
+                    break;
+                case 9:
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                        SummonPortals();
+                    }
+                    isVisionFinished = true;
+                    isStormWindVision = false;
+                    m_uiSpeechTimer = 10000;
+                    break;
+                default:
+                    m_uiSpeechTimer = 100000;
+                }
+            }else m_uiSpeechTimer -= uiDiff;
+
+            if (tentacleCheckTimer < uiDiff && !isVisionFinished)
+            {
+                if(!IsThereAnyAdd(VoiceOfYogg))
+                {
+                    if(m_pInstance) 
+                        m_pInstance->SetData(TYPE_VISION1, DONE);
+
+                    SummonPortals();
+                    tentacleCheckTimer = 300000;
+                }
+                else
+                    tentacleCheckTimer = 1000;
+            }else tentacleCheckTimer -= uiDiff;
+
+            if (madnessTimer < uiDiff)
+            {
+                KillPlayers();
+                madnessTimer = 300000;
+            }else madnessTimer -= uiDiff;
+        }
+        if(isDragonVision)
+        {
+            if(m_uiSpeechTimer < uiDiff)
+            {
+                switch(m_uiVisionPhase)
+                {
+                case 0:
+                    m_creature->SummonCreature(NPC_ALEXSTRASZA, PosAlexstrasza[0], PosAlexstrasza[1], PosAlexstrasza[2], PosAlexstrasza[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    Neltharion = m_creature->SummonCreature(NPC_NELTHARION, PosNeltharion[0], PosNeltharion[1], PosNeltharion[2], PosNeltharion[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    Malygos = m_creature->SummonCreature(NPC_MALYGOS, PosMalygos[0], PosMalygos[1], PosMalygos[2], PosMalygos[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    Ysera = m_creature->SummonCreature(NPC_YSERA, PosYsera[0], PosYsera[1], PosYsera[2], PosYsera[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    //m_creature->SummonGameobject(GO_DRAGON_SOUL, PosVoiceDragon[0], PosVoiceDragon[1], PosVoiceDragon[2], 0, 60000);
+                    VoiceOfYogg = m_creature->SummonCreature(NPC_VOICE_OF_YOGG_SARON, PosVoiceDragon[0], PosVoiceDragon[1], PosVoiceDragon[2], 0, TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    VoiceOfYogg->SetVisibility(VISIBILITY_OFF);
+                    for(uint8 i = 0; i < 10; i++)
+                    {
+                        if(Creature *pTemp = m_creature->SummonCreature(MOB_VISION_TENTACLE, DragonLoc[i].x, DragonLoc[i].y, DragonLoc[i].z, DragonLoc[i].o, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 80000))
+                        {
+                            pTemp->SetDisplayId(DisplayDragons[i]);
+                            pTemp->SetMaxHealth(m_bIsRegularMode ? 15000 : 40000);
+                            pTemp->setFaction(7);
+                        }
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 1000;
+                    break;
+                case 1:
+                    DoScriptText(SAY_NELTHARION1, Neltharion);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION2, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 10000;
+                    break;
+                case 2:
+                    DoScriptText(SAY_YSERA, Ysera);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION2, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 7000;
+                    break;
+                case 3:
+                    DoScriptText(SAY_NELTHARION2, Neltharion);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION2, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 6000;
+                    break;
+                case 4:
+                    DoScriptText(SAY_MALYGOS, Malygos);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION2, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 9000;
+                    break;
+                case 5:
+                    DoScriptText(SAY_YOGG_V2, VoiceOfYogg);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION2, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 10000;
+                    break;
+                case 6:
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION2, DONE);
+
+                        SummonPortals();
+                    }
+                    isVisionFinished = true;
+                    isDragonVision = false;
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 20000;
+                    break;
+                default:
+                    m_uiSpeechTimer = 100000;
+                }
+            }else m_uiSpeechTimer -= uiDiff;
+
+            if (tentacleCheckTimer < uiDiff && !isVisionFinished)
+            {
+                if(!IsThereAnyAdd(VoiceOfYogg))
+                {
+                    if(m_pInstance) 
+                        m_pInstance->SetData(TYPE_VISION2, DONE);
+
+                    SummonPortals();
+                    tentacleCheckTimer = 300000;
+                }
+                else
+                    tentacleCheckTimer = 1000;
+            }else tentacleCheckTimer -= uiDiff;
+
+            if (madnessTimer < uiDiff)
+            {
+                KillPlayers();
+                madnessTimer = 300000;
+            }else madnessTimer -= uiDiff;
+        }
+        if(isLichKingVision)
+        {
+            if(m_uiSpeechTimer < uiDiff)
+            {
+                switch(m_uiVisionPhase)
+                {
+                case 0:
+                    LichKing = m_creature->SummonCreature(NPC_LICH_KING, PosLichKing[0], PosLichKing[1], PosLichKing[2], PosLichKing[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    Champion = m_creature->SummonCreature(NPC_IMMOLATED_CHAMPION, PosChampion[0], PosChampion[1], PosChampion[2], PosChampion[3], TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    VoiceOfYogg = m_creature->SummonCreature(NPC_VOICE_OF_YOGG_SARON, PosVoiceIcecrown[0], PosVoiceIcecrown[1], PosVoiceIcecrown[2], 0, TEMPSUMMON_TIMED_DESPAWN, 60000);
+                    VoiceOfYogg->SetVisibility(VISIBILITY_OFF);
+                    for(uint8 i = 0; i < 9; i++)
+                    {
+                        if(Creature *pTemp = m_creature->SummonCreature(MOB_VISION_TENTACLE, IcecrownLoc[i].x, IcecrownLoc[i].y, IcecrownLoc[i].z, IcecrownLoc[i].o, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 80000))
+                        {
+                            pTemp->SetMaxHealth(m_bIsRegularMode ? 15000 : 40000);
+                            pTemp->SetDisplayId(25627);
+                            pTemp->setFaction(7);
+                        }
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 1000;
+                    break;
+                case 1:
+                    Champion->SetStandFlags(UNIT_STAND_STATE_KNEEL);
+                    LichKing->CastSpell(Champion, 54142, false);
+                    DoScriptText(SAY_LICH_KING1, LichKing);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 5000;
+                    break;
+                case 2:
+                    DoScriptText(SAY_CHAMPION1, Champion);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 8000;
+                    break;
+                case 3:
+                    DoScriptText(SAY_CHAMPION2, Champion);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 8000;
+                    break;
+                case 4:
+                    DoScriptText(SAY_LICH_KING2, LichKing);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 7000;
+                    break;
+                case 5:
+                    DoScriptText(SAY_YOGG_V3_1, VoiceOfYogg);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 5000;
+                    break;
+                case 6:
+                    DoScriptText(SAY_YOGG_V3_2, VoiceOfYogg);
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                        SummonPortals();
+                    }
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 10000;
+                    break;
+                case 7:
+                    if(!IsThereAnyAdd(VoiceOfYogg))
+                    {
+                        if(m_pInstance) 
+                            m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                        SummonPortals();
+                    }
+                    isVisionFinished = true;
+                    isLichKingVision = false;
+                    ++m_uiVisionPhase;
+                    m_uiSpeechTimer = 20000;
+                    break;
+                default:
+                    m_uiSpeechTimer = 100000;
+                }
+            }else m_uiSpeechTimer -= uiDiff;
+
+            if (tentacleCheckTimer < uiDiff && !isVisionFinished)
+            {
+                if(!IsThereAnyAdd(VoiceOfYogg))
+                {
+                    if(m_pInstance) 
+                        m_pInstance->SetData(TYPE_VISION3, DONE);
+
+                    SummonPortals();
+                    tentacleCheckTimer = 300000;
+                }
+                else
+                    tentacleCheckTimer = 1000;
+            }else tentacleCheckTimer -= uiDiff;
+
+            if (madnessTimer < uiDiff)
+            {
+                KillPlayers();
+                madnessTimer = 300000;
+            }else madnessTimer -= uiDiff;
+        }
+
+        if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= 30 && !isOver)
+        {
+            if (Creature* pYogg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGGSARON))))
+            {
+                pYogg->setFaction(14);
+                pYogg->SetVisibility(VISIBILITY_ON);
+                ((boss_yogg_saronAI*)pYogg->AI())->StartThirdPhase(berserkTimer - uiDiff);
+                isOver = true;
+            }
+            if(m_pInstance) 
+                m_pInstance->SetData(TYPE_YOGG_BRAIN, DONE);
+        }
+
+        if (berserkTimer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_BERSERK);
+            berserkTimer = 300000;
+        }else berserkTimer -= uiDiff;
+    }
+};
+
+struct MANGOS_DLL_DECL boss_saraAI : public ScriptedAI
+{
+    boss_saraAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->ApplySpellImmune(SPELL_DARK_VOLLEY, IMMUNITY_DAMAGE, SPELL_SCHOOL_MASK_SHADOW, true);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint8 phase;
+    uint32 berserkTimer;
+
+    // intro
+    bool m_bIsIntro;
+    uint8 m_uiIntro_Phase;
+    uint32 m_uiSpeech_Timer;
+    bool isIntroDone;
+    bool isFactionSet;
+
+    // phase 1
+    uint32 phaseYellTimer;
+    uint32 summonTimer;
+    uint32 sarasFervorTimer;
+    uint32 sarasBlessingTimer;
+    uint32 sarasAngerTimer;
+    uint32 guardCheckTimer;
+    Creature *pGuardian;
+    std::list<Creature*> lGuardianList;
+    std::list<uint64> m_lGuardGUIDList;
+    std::list<uint64> m_lTentacleGUIDList;
+    std::list<Creature*> lPortals;
+
+    // transition
+    bool isOutro;
+    uint32 OutroTimer;
+    uint32 Step;
+
+    // phase 2
+    uint32 sanityTimer;
+    uint32 psychosisTimer;
+    uint32 maladyTimer;
+    uint32 brainLinkTimer;
+    uint32 deathRayTimer;
+    uint32 descentTimer;
+    uint32 waitTimer;
+    uint8 vision;
+    uint8 maxPlayers;
+
+    std::list<uint64> FriendlyList;
+    std::list<uint64> PlayerList;
+
+
+    void Reset()
+    {
+        // intro
+        phase               = 0;
+        berserkTimer        = 900000;   // 15 min
+        m_bIsIntro          = false;
+        m_uiIntro_Phase     = 0;
+        m_uiSpeech_Timer    = 1000;
+        isIntroDone         = false;
+        isFactionSet        = false;
+
+        // phase 1
+        phaseYellTimer      = 30000;
+        summonTimer         = 10000 + urand (1000, 5000);
+        sarasFervorTimer    = urand(10000, 15000);
+        sarasBlessingTimer  = urand(15000, 20000);
+        sarasAngerTimer     = urand(20000, 25000);
+        guardCheckTimer     = 1000;
+
+        // transition
+        isOutro             = false;
+        OutroTimer          = 10000;
+        Step                = 1;
+
+        // phase 2
+        sanityTimer         = 10000;
+        psychosisTimer      = 15000;     
+        maladyTimer         = 20000;
+        brainLinkTimer      = 25000;
+        deathRayTimer       = 30000;
+        descentTimer        = 90000;
+        vision              = 0;
+        lPortals.clear();
+        maxPlayers          = m_bIsRegularMode ? 4 : 10;
+
+        FriendlyList.clear();
+        PlayerList.clear();
+        m_lGuardGUIDList.clear();
+        m_lTentacleGUIDList.clear();
+
+        if(m_creature->HasAura(SPELL_SHADOWY_BARRIER))
+            m_creature->RemoveAurasDueToSpell(SPELL_SHADOWY_BARRIER);
+
+        m_creature->SetDisplayId(29117);
+        m_creature->setFaction(35);
+        m_creature->SetMaxHealth(199999);
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+
+        // reset
+        if (Creature *pHodirImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_HODIR_IMAGE))))
+        {
+            if(pHodirImage->isAlive())
+                pHodirImage->SetVisibility(VISIBILITY_ON);
+        }
+        if (Creature *pFreyaImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_FREYA_IMAGE))))
+        {
+            if(pFreyaImage->isAlive())
+                pFreyaImage->SetVisibility(VISIBILITY_ON);
+        }
+        if (Creature *pThorimImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_THORIM_IMAGE))))
+        {
+            if(pThorimImage->isAlive())
+                pThorimImage->SetVisibility(VISIBILITY_ON);
+        }
+        if (Creature *pMimironImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON_IMAGE))))
+        {
+            if(pMimironImage->isAlive())
+                pMimironImage->SetVisibility(VISIBILITY_ON);
+        }
+
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_YOGGSARON, NOT_STARTED);
+    }
+
+    void Aggro(Unit *who) 
+    { }
+
+    void JustDied(Unit *killer)
+    {
+        if(m_pInstance) m_pInstance->SetData(TYPE_YOGGSARON, DONE);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        if(phase == 2)
+        {
+            if(irand(0,1))
+                DoScriptText(SAY_KILL1, m_creature);
+            else
+                DoScriptText(SAY_KILL2, m_creature);
+        }
+    }
+
+    void SummonPortals()
+    {
+        uint8 maxPortals = m_bIsRegularMode ? 4 : 10;
+        for(uint8 i = 0; i < maxPortals; i++)
+            m_creature->SummonCreature(MOB_DESCEND_INTO_MADNESS, YoggPortalLoc[i].x, YoggPortalLoc[i].y, YoggPortalLoc[i].z, 0, TEMPSUMMON_TIMED_DESPAWN, 60000);
+    }
+
+    void SetDestination(uint8 location)
+    {
+        switch (location)
+        {
+            case 0:
+                if(m_pInstance)
+                    m_pInstance->SetData(TYPE_VISION1, IN_PROGRESS);
+                break;
+            case 1:
+                if(m_pInstance)
+                    m_pInstance->SetData(TYPE_VISION2, IN_PROGRESS);
+                break;
+            case 2:
+                if(m_pInstance)
+                    m_pInstance->SetData(TYPE_VISION3, IN_PROGRESS);
+                break;
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > m_creature->GetHealth())
+        {
+            isOutro = true;
+            m_creature->SetHealth(m_creature->GetMaxHealth());
+            uiDamage = 0;
+        }
+    }
+
+    void SpellHit(Unit *caster, const SpellEntry *spell)
+    {
+        uint32 spellId = m_bIsRegularMode ? SPELL_SHADOW_NOVA : SPELL_SHADOW_NOVA_H;
+        uint32 maxHealth = m_bIsRegularMode ? 21994 : 27500;
+        if(spell->Id == spellId && caster->GetEntry() == MOB_GUARDIAN_OF_YOGG)
+        {
+            if(m_creature->GetHealth() > maxHealth)
+                m_creature->DealDamage(m_creature, m_bIsRegularMode ? urand(20000, 21994) : urand(25000, 27500), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_SHADOW, NULL, false);
+            else
+            {
+                isOutro = true;
+                m_creature->SetHealth(m_creature->GetMaxHealth());
+            }
+        }
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        if (pWho->isTargetableForAttack() && pWho->isInAccessablePlaceFor(m_creature) && phase == 0 &&
+            !m_bIsIntro && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 110) && m_creature->IsWithinLOSInMap(pWho))
+            m_bIsIntro = true;
+
+        if (pWho->isTargetableForAttack() && pWho->isInAccessablePlaceFor(m_creature) && phase == 0 &&
+            isIntroDone && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 40) && m_creature->IsWithinLOSInMap(pWho))
+        {
+            if(m_pInstance) 
+                m_pInstance->SetData(TYPE_YOGGSARON, IN_PROGRESS);
+
+            if (Creature *pHodirImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_HODIR_IMAGE))))
+            {
+                if(pHodirImage->isAlive())
+                    pHodirImage->SetVisibility(VISIBILITY_OFF);
+            }
+            if (Creature *pFreyaImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_FREYA_IMAGE))))
+            {
+                if(pFreyaImage->isAlive())
+                    pFreyaImage->SetVisibility(VISIBILITY_OFF);
+            }
+            if (Creature *pThorimImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_THORIM_IMAGE))))
+            {
+                if(pThorimImage->isAlive())
+                    pThorimImage->SetVisibility(VISIBILITY_OFF);
+            }
+            if (Creature *pMimironImage = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_MIMIRON_IMAGE))))
+            {
+                if(pMimironImage->isAlive())
+                    pMimironImage->SetVisibility(VISIBILITY_OFF);
+            }
+
+            DoScriptText(SAY_AGGRO, m_creature);
+            phase = 1;
+        }
+
+        // friendly list
+        if (!m_creature->IsHostileTo(pWho) && !ListContains(FriendlyList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 80, true) && phase == 1)
+            FriendlyList.push_back(pWho->GetGUID());
+
+        // player list
+        if (m_creature->IsHostileTo(pWho) && !ListContains(PlayerList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 80, true) && m_creature->IsWithinLOSInMap(pWho) && phase == 2)
+            PlayerList.push_back(pWho->GetGUID());
+
+        if(phase == 1)
+        {
+            if(pWho->getFaction() == 1 || pWho->getFaction() == 3 || pWho->getFaction() == 4 || pWho->getFaction() == 115 || pWho->getFaction() == 1629
+                && phase == 1 && !isOutro && !isFactionSet)
+            {
+                isFactionSet = true;
+                m_creature->setFaction(1);
+            }
+
+            if(pWho->getFaction() == 2 || pWho->getFaction() == 5 || pWho->getFaction() == 6 || pWho->getFaction() == 116 || pWho->getFaction() == 1610
+                && phase == 1 && !isOutro && !isFactionSet)
+            {
+                isFactionSet = true;
+                m_creature->setFaction(2);
+            }
+        }
+        else if(phase == 2 || phase == 3)
+            m_creature->setFaction(14);
+    }
+
+    void EventReset()
+    {
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_YOGGSARON, FAIL);
+
+        if (Creature* pYogg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGGSARON))))
+        {
+            if(pYogg->isAlive())
+                ((boss_yogg_saronAI*)pYogg->AI())->Reset();
+        }
+        if (Creature* pYoggBrain = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGG_BRAIN))))
+        {
+            if(pYoggBrain->isAlive())
+                ((boss_brain_of_yogg_saronAI*)pYoggBrain->AI())->Reset();
+        }
+        Reset();
+    }
+
+    Creature* SelectRandomGuardian(float fRange)
+    {
+        std::list<Creature* > lGuardiansList;
+        GetCreatureListWithEntryInGrid(lGuardiansList, m_creature, MOB_GUARDIAN_OF_YOGG, fRange);
+
+        //This should not appear!
+        if (lGuardiansList.empty()){
+            sarasAngerTimer = 30000;
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lGuardiansList.begin();
+        advance(iter, urand(0, lGuardiansList.size()-1));
+
+        return *iter;
+    }
+
+    uint64 SelectRandomPlayer(std::list<uint64> UnitList)
+    {
+        //This should not appear!
+        if (UnitList.empty())
+        {
+            sarasFervorTimer = 30000;
+            sarasBlessingTimer = 30000;
+            return NULL;
+        }
+
+        std::list<uint64>::iterator iter = UnitList.begin();
+        advance(iter, urand(0, UnitList.size()-1));
+
+        return *iter;
+    }
+
+    bool ListContains(std::list<uint64> &plist, uint64 element)
+    {
+        if (plist.empty())
+            return false;
+
+        std::list<uint64>::iterator i;
+        for (i = plist.begin(); i!=plist.end(); ++i)
+        {
+            if ((*i) == element)
+                return true;
+        }
+        return false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsIntro)
+        {
+            if(m_uiSpeech_Timer < uiDiff)
+            {
+                switch(m_uiIntro_Phase)
+                {
+                case 0:
+                    DoScriptText(SAY_INTRO1, m_creature);
+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
+                    m_creature->GetMotionMaster()->MoveIdle();
+                    SetCombatMovement(false);
+                    m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), 329.397f, 5.9f);
+                    m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), 329.397f, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 8000;
+                    break;
+                case 1:
+                    // m_creature->setFaction(14);
+                    DoScriptText(SAY_INTRO2, m_creature);
+                    DoCast(m_creature, SPELL_DAMAGE_IMMUNE);
+                    ++m_uiIntro_Phase;
+                    m_uiSpeech_Timer = 8000;
+                    break;
+                case 2:
+                    m_bIsIntro = false;
+                    isIntroDone = true;
+                    m_uiSpeech_Timer = 12000;
+                    break;
+                default:
+                    m_uiSpeech_Timer = 100000;
+                }
+            }else m_uiSpeech_Timer -= uiDiff;
+        }
+
+        if(phase == 1)
+        {
+            if(!isOutro)
+            {
+                if (Creature* pYogg = GetClosestCreatureWithEntry(m_creature, NPC_YOGGSARON, 150.0f))
+                {
+                    if(!pYogg->getVictim() || !pYogg->SelectHostileTarget())
+                    {
+                        EventReset();
+                        DoScriptText(SAY_WIPE, m_creature);
+                    }
+                }
+
+                if (phaseYellTimer < uiDiff)
+                {
+                    switch(urand(0, 1))
+                    {
+                    case 0: DoScriptText(SAY_HELP1, m_creature); break;
+                    case 1: DoScriptText(SAY_HELP2, m_creature); break;
+                    }
+                    phaseYellTimer = 30000;
+                }else phaseYellTimer -= uiDiff;
+
+                if (summonTimer < uiDiff)
+                {
+                    uint8 i = urand(0, 11);
+                    if(Creature *pTemp = m_creature->SummonCreature(MOB_GUARDIAN_OF_YOGG, SummonLoc[i].x, SummonLoc[i].y, SummonLoc[i].z, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 30000)) 
+                    {
+                        Unit *pPlayer = Unit::GetUnit((*m_creature),(SelectRandomPlayer(FriendlyList)));
+                        if (pPlayer && pPlayer->isAlive() && m_creature->GetDistance(pPlayer) < 100)
+                        {
+                            pTemp->AddThreat(pPlayer,100.0f);
+                            pTemp->AI()->AttackStart(pPlayer);
+                            pTemp->SetInCombatWithZone();
+                            m_lGuardGUIDList.push_back(pTemp->GetGUID());
+                        }
+                    }
+                    summonTimer = urand(15000, 20000);
+                }else summonTimer -= uiDiff;
+
+                if (sarasFervorTimer < uiDiff)
+                {
+                    Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer(FriendlyList)));
+                    if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 100)
+                        DoCast(pTemp, SPELL_SARAS_FERVOR);
+                    sarasFervorTimer = urand(20000, 30000);
+                }else sarasFervorTimer -= uiDiff;
+
+                if (sarasBlessingTimer < uiDiff)
+                {
+                    Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer(FriendlyList)));
+                    if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 100)
+                        DoCast(pTemp, SPELL_SARAS_BLESSING); //remove for debug!
+                        sarasBlessingTimer = urand(20000, 30000);
+                }else sarasBlessingTimer -= uiDiff;
+
+                if (sarasAngerTimer < uiDiff)
+                {
+                    if (pGuardian = SelectRandomGuardian(80.0f))
+                        DoCast(pGuardian, SPELL_SARAS_ANGER);
+                    sarasAngerTimer = urand(20000, 30000);
+                }else sarasAngerTimer -= uiDiff;
+            }
+            if(isOutro)
+            {
+                switch(Step)
+                {
+                case 1:
+                    m_creature->SetHealth(m_creature->GetMaxHealth());
+                    //m_creature->RemoveAllAuras();
+                    //m_creature->DeleteThreatList();
+                    m_creature->CombatStop(true);
+                    m_creature->InterruptNonMeleeSpells(false);
+                    ++Step;
+                    OutroTimer = 5000;
+                    break;
+                case 3:
+                    DoScriptText(SAY_PHASE2, m_creature);
+                    ++Step;
+                    OutroTimer = 15000;
+                    break;
+                case 5:
+                    Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer(FriendlyList)));
+                    if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 100)
+                    {
+                        m_creature->AddThreat(pTemp, 100.0f);
+                        m_creature->AI()->AttackStart(pTemp);
+                    }
+                    m_creature->setFaction(14);
+                    m_creature->SetDisplayId(24991);
+                    DoCast(m_creature, SPELL_SHADOWY_BARRIER);
+                    m_creature->RemoveAurasDueToSpell(SPELL_DAMAGE_IMMUNE);
+                    m_creature->SetHealth(m_creature->GetMaxHealth());
+                    m_creature->GetMap()->CreatureRelocation(m_creature, m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  10, 5.9f);
+                    m_creature->SendMonsterMove(m_creature->GetPositionX(), m_creature->GetPositionY(), m_creature->GetPositionZ() +  10, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
+                    if (Creature* pYogg = GetClosestCreatureWithEntry(m_creature, NPC_YOGGSARON, 150.0f))
+                    {
+                        pYogg->CastSpell(pYogg, SPELL_SHADOWY_BARRIER_YOGG, false);
+                        ((boss_yogg_saronAI*)pYogg->AI())->StartSecondPhase();
+                    }
+                    phaseYellTimer = 30000 + urand(5000, 10000);
+                    summonTimer = 1000;
+                    waitTimer = 20000;
+                    phase = 2;
+                    ++Step;
+                    OutroTimer = 3000;
+                    break;
+                }
+            }
+            else return;
+
+            if (OutroTimer <= uiDiff)
+            {
+                ++Step;
+                OutroTimer = 330000;
+            } OutroTimer -= uiDiff;
+        }
+        if(phase == 2)
+        {    
+            if (Creature* pYogg = GetClosestCreatureWithEntry(m_creature, NPC_YOGGSARON, 150.0f))
+            {
+                if(!pYogg->getVictim() || !pYogg->SelectHostileTarget())
+                    EventReset();
+            }
+
+            if(m_pInstance && m_pInstance->GetData(TYPE_YOGGSARON == FAIL))
+                EventReset();
+
+            if (phaseYellTimer < uiDiff)
+            {
+                switch(urand(0, 1))
+                {
+                case 0: DoScriptText(SAY_SPECIAL1, m_creature); break;
+                case 1: DoScriptText(SAY_SPECIAL2, m_creature); break;
+                }
+                phaseYellTimer = 30000 + urand(5000, 10000);
+            }else phaseYellTimer -= uiDiff;
+
+            if (psychosisTimer < uiDiff)
+            {
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, m_bIsRegularMode ? SPELL_PHYCHOSIS : SPELL_PHYCHOSIS_H);
+                psychosisTimer = urand(15000, 20000);
+            }else psychosisTimer -= uiDiff;
+
+            if (maladyTimer < uiDiff)
+            {
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, SPELL_MALADY_OF_THE_MIND);
+                maladyTimer = urand(20000, 25000);
+            }else maladyTimer -= uiDiff;
+
+            if (brainLinkTimer < uiDiff)
+            {
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, SPELL_BRAIN_LINK);
+                brainLinkTimer = urand(25000, 30000);
+            }else brainLinkTimer -= uiDiff;
+
+            if (deathRayTimer < uiDiff)
+            {
+                uint8 i = urand(0, 7);
+                for(uint8 j = 0; j < i+4; j++)
+                    m_creature->SummonCreature(MOB_DEATH_ORB, SummonLoc[j].x, SummonLoc[j].y, SummonLoc[j].z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                DoCast(m_creature, SPELL_DEATH_RAY);
+                deathRayTimer = 30000;
+            }else deathRayTimer -= uiDiff;
+
+            if (descentTimer < uiDiff)
+            {
+                if(vision < 3)
+                {
+                    if (Creature* pYogg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGGSARON))))
+                        DoScriptText(SAY_VISION, pYogg);
+					/*
+                    for (uint8 i = 0; i < maxPlayers; i++)
+                    {
+                        Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer(PlayerList)));
+                        if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 100)
+                            ((Player*)(pTemp))->TeleportTo(pTemp->GetMapId(), TeleportLoc[vision].x, TeleportLoc[vision].y, TeleportLoc[vision].z, pTemp->GetOrientation());
+                    }
+                    */
+                    SummonPortals();
+                    SetDestination(vision);
+                    if (Creature* pYoggBrain = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGG_BRAIN))))
+                    {
+                        if(pYoggBrain->isAlive())
+                            ((boss_brain_of_yogg_saronAI*)pYoggBrain->AI())->StartVisions(vision + 1, berserkTimer - uiDiff);
+                        vision += 1;
+                    }
+
+                }
+                else
+                    berserkTimer = 1000;
+                descentTimer = 90000;
+            }else descentTimer -= uiDiff;
+
+            if (summonTimer < uiDiff)
+            {
+                uint8 i = urand(0, 11);
+                switch(urand(0, 2))
+                {
+                case 0:
+                    if(Creature *pTemp = m_creature->SummonCreature(MOB_CONSTRICTOR_TENTACLE, SummonLoc[i].x, SummonLoc[i].y, SummonLoc[i].z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                        {
+                            pTemp->AddThreat(pTarget,0.0f);
+                            pTemp->AI()->AttackStart(pTarget);
+                            m_lTentacleGUIDList.push_back(pTemp->GetGUID());
+                        }
+                    }
+                    break;
+                case 1:
+                    if(Creature *pTemp = m_creature->SummonCreature(MOB_CRUSHER_TENTACLE, SummonLoc[i].x, SummonLoc[i].y, SummonLoc[i].z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                        {
+                            pTemp->AddThreat(pTarget,0.0f);
+                            pTemp->AI()->AttackStart(pTarget);
+                            m_lTentacleGUIDList.push_back(pTemp->GetGUID());
+                        }
+                    }
+                    break;
+                case 2:
+                    if(Creature *pTemp = m_creature->SummonCreature(MOB_CORRUPTOR_TENTACLE, SummonLoc[i].x, SummonLoc[i].y, SummonLoc[i].z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                    {
+                        if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                        {
+                            pTemp->AddThreat(pTarget,0.0f);
+                            pTemp->AI()->AttackStart(pTarget);
+                            m_lTentacleGUIDList.push_back(pTemp->GetGUID());
+                        }
+                    }
+                    break;
+                }
+                summonTimer = urand(10000, 15000);
+            }else summonTimer -= uiDiff;
+
+            if (berserkTimer < uiDiff)
+            {
+                DoCast(m_creature, SPELL_BERSERK);
+                berserkTimer = 300000;
+            }else berserkTimer -= uiDiff;
+
+            if(m_pInstance && m_pInstance->GetData(TYPE_YOGG_BRAIN == DONE))
+            {
+                m_creature->SetVisibility(VISIBILITY_OFF);
+                waitTimer = 10000;
+                phase = 3;
+            }
+        }
+        if(phase == 3)
+        {    
+            if (Creature* pYogg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGGSARON))))
+            {
+                if(!pYogg->getVictim() || !pYogg->SelectHostileTarget())
+                    EventReset();
+            }
+
+            if(m_pInstance && m_pInstance->GetData(TYPE_YOGGSARON == DONE))
+            {
+                if (Creature* pYoggBrain = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_YOGG_BRAIN))))
+                {
+                    if(pYoggBrain->isAlive())
+                        ((boss_brain_of_yogg_saronAI*)pYoggBrain->AI())->SelfDestruct();
+                }
+                m_creature->ForcedDespawn();
+            }
+        }
+    }
+};
+
+/*
+*   Keepers
+*/
+struct MANGOS_DLL_DECL keeper_hodirAI : public ScriptedAI
+{
+    keeper_hodirAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    uint32 hodirProtectivGazeTimer;
+    std::list<uint64> FriendlyList;
+
+    void Reset()
+    {
+        hodirProtectivGazeTimer = 30000;
+        FriendlyList.clear();
+        DoCast(m_creature, SPELL_FORTITUDE_OF_FROST);
+    }
+
+    void MoveInLineOfSight(Unit* pWho)
+    {
+        // friendly list
+        if (!m_creature->IsHostileTo(pWho) && !ListContains(FriendlyList, pWho->GetGUID()) && pWho->GetTypeId() == TYPEID_PLAYER && m_creature->IsWithinDistInMap(pWho, 100, true))
+            FriendlyList.push_back(pWho->GetGUID());
+    }
+
+    uint64 SelectRandomPlayer()
+    {
+        //This should not appear!
+        if (FriendlyList.empty()){
+            EnterEvadeMode();
+            return NULL;
+        }
+
+        std::list<uint64>::iterator iter = FriendlyList.begin();
+        advance(iter, urand(0, FriendlyList.size()-1));
+
+        return *iter;
+    }
+
+    bool ListContains(std::list<uint64> &plist, uint64 element)
+    {
+        if (plist.empty())
+            return false;
+
+        std::list<uint64>::iterator i;
+        for (i = plist.begin(); i!=plist.end(); ++i)
+        {
+            if ((*i) == element)
+                return true;
+        }
+        return false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_pInstance && m_pInstance->GetData(TYPE_YOGGSARON == IN_PROGRESS))
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+
+            if (hodirProtectivGazeTimer < uiDiff)
+            {
+                Unit *pTemp = Unit::GetUnit((*m_creature),(SelectRandomPlayer()));
+                if (pTemp && pTemp->isAlive() && m_creature->GetDistance(pTemp) < 100)
+                {
+                    DoCast(pTemp, SPELL_HODIRS_PROTECTIVE_GAZE);
+                }
+                hodirProtectivGazeTimer = 30000 + urand(10000,30000);
+            }else hodirProtectivGazeTimer -= uiDiff;
+        }
+
+        if(m_pInstance && (m_pInstance->GetData(TYPE_YOGGSARON) == DONE || m_pInstance->GetData(TYPE_YOGGSARON) == FAIL))
+            m_creature->ForcedDespawn();
+    }
+};
+
+struct MANGOS_DLL_DECL keeper_freyaAI : public ScriptedAI
+{
+    keeper_freyaAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    uint32 sanityWellTimer;
+
+    void Reset()
+    {
+        sanityWellTimer = 30000;
+        DoCast(m_creature, SPELL_RESILIENCE_OF_NATURE);
+
+        for(uint8 i = 0; i < 5; i++)
+            m_creature->SummonCreature(MOB_SANITY_WELL, SanityWellLoc[i].x, SanityWellLoc[i].y, SanityWellLoc[i].z, 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_pInstance && m_pInstance->GetData(TYPE_YOGGSARON == IN_PROGRESS))
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+        }
+
+        if(m_pInstance && (m_pInstance->GetData(TYPE_YOGGSARON) == DONE || m_pInstance->GetData(TYPE_YOGGSARON) == FAIL))
+            m_creature->ForcedDespawn();
+    }
+};
+
+struct MANGOS_DLL_DECL keeper_thorimAI : public ScriptedAI
+{
+    keeper_thorimAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    uint32 titanicStormTimer;
+    Creature *pGuardian;
+    std::list<Creature*> lGuardianList;
+
+
+    void Reset()
+    {
+        titanicStormTimer = 30000;
+        DoCast(m_creature, SPELL_FURY_OF_THE_STORM);
+    }
+
+    Creature* SelectRandomGuardian(float fRange)
+    {
+        std::list<Creature* > lGuardiansList;
+        GetCreatureListWithEntryInGrid(lGuardiansList, m_creature, MOB_IMMORTAL_GUARDIAN, fRange);
+
+        //This should not appear!
+        if (lGuardiansList.empty()){
+            titanicStormTimer = 30000;
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lGuardiansList.begin();
+        advance(iter, urand(0, lGuardiansList.size()-1));
+
+        return *iter;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_pInstance && m_pInstance->GetData(TYPE_YOGGSARON == IN_PROGRESS))
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+
+            if (titanicStormTimer < uiDiff)
+            {
+                if (pGuardian = SelectRandomGuardian(80.0f))
+                    DoCast(pGuardian, SPELL_TITANIC_STORM);
+                titanicStormTimer = 30000 + urand(10000,30000);
+            }else titanicStormTimer -= uiDiff;
+        }
+
+        if(m_pInstance && (m_pInstance->GetData(TYPE_YOGGSARON) == DONE || m_pInstance->GetData(TYPE_YOGGSARON) == FAIL))
+            m_creature->ForcedDespawn();
+    }
+};
+
+struct MANGOS_DLL_DECL keeper_mimironAI : public ScriptedAI
+{
+    keeper_mimironAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    uint32 destabilizationMatrixTimer;
+    Creature *pTentacle;
+    std::list<Creature*> lCrusherTentacleList;
+    std::list<Creature*> lCorruptorTentacleList;
+
+    void Reset()
+    {
+        destabilizationMatrixTimer = 30000;
+        DoCast(m_creature, SPELL_SPEED_OF_INVENTION);
+    }
+
+    Creature* SelectRandomCrusherTentacle(float fRange)
+    {
+        std::list<Creature* > lCrusherTentacleList;
+        GetCreatureListWithEntryInGrid(lCrusherTentacleList, m_creature, MOB_CRUSHER_TENTACLE, fRange);
+
+        //This should not appear!
+        if (lCrusherTentacleList.empty()){
+            destabilizationMatrixTimer = 30000;
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lCrusherTentacleList.begin();
+        advance(iter, urand(0, lCrusherTentacleList.size()-1));
+
+        return *iter;
+    }
+
+    Creature* SelectRandomCorruptorTentacle(float fRange)
+    {
+        std::list<Creature* > lCorruptorTentacleList;
+        GetCreatureListWithEntryInGrid(lCorruptorTentacleList, m_creature, MOB_CORRUPTOR_TENTACLE, fRange);
+
+        //This should not appear!
+        if (lCorruptorTentacleList.empty()){
+            destabilizationMatrixTimer = 30000;
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lCorruptorTentacleList.begin();
+        advance(iter, urand(0, lCorruptorTentacleList.size()-1));
+
+        return *iter;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_pInstance && m_pInstance->GetData(TYPE_YOGGSARON == IN_PROGRESS))
+        {
+            if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+                return;
+
+            if (destabilizationMatrixTimer < uiDiff)
+            {
+                switch(urand(0, 1))
+                {
+                case 0: 
+                    if(pTentacle = SelectRandomCorruptorTentacle(80.0f))
+                        DoCast(pTentacle, SPELL_DESTABILIZATION_MATRIX);
+                    break;
+                case 1: 
+                    if(pTentacle = SelectRandomCrusherTentacle(80.0f))
+                        DoCast(pTentacle, SPELL_DESTABILIZATION_MATRIX);
+                    break;
+                }
+                destabilizationMatrixTimer = 30000 + urand(10000,30000);
+            }else destabilizationMatrixTimer -= uiDiff;
+        }
+
+        if(m_pInstance && (m_pInstance->GetData(TYPE_YOGGSARON) == DONE || m_pInstance->GetData(TYPE_YOGGSARON) == FAIL))
+            m_creature->ForcedDespawn();
+    }
+};
+
+/*
+*   Keepers images -> used to separate hard/normal mode
+*/
+struct MANGOS_DLL_DECL hodir_imageAI : public ScriptedAI
+{
+    hodir_imageAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SetCombatMovement(false);
+        pCreature->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    void Reset() { }
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+    }
+};
+
+bool GossipHello_hodir_image(Player* pPlayer, Creature* pCreature)
+{
+    ScriptedInstance *m_pInstance = (ScriptedInstance *) pCreature->GetInstanceData();
+
+    //if(m_pInstance && m_pInstance->GetData(TYPE_HODIR) == DONE && m_pInstance->GetData(TYPE_FREYA) == DONE && m_pInstance->GetData(TYPE_THORIM) == DONE && m_pInstance->GetData(TYPE_MIMIRON) == DONE)
+    // hodir doesn't save! fix it!!!
+    if(m_pInstance /*&& m_pInstance->GetData(TYPE_HODIR) == DONE*/)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, REQUEST_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, DENY_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_hodir_image(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+    {
+        if(!GetClosestCreatureWithEntry(pCreature, KEEPER_HODIR, 200.0f))
+        {
+            if(Creature *pHodir = pCreature->SummonCreature(KEEPER_HODIR, KeepersLoc[1].x, KeepersLoc[1].y, KeepersLoc[1].z, KeepersLoc[1].o, TEMPSUMMON_MANUAL_DESPAWN, 30000))
+            {
+                pHodir->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.7f);
+                DoScriptText(SAY_HODIR_ACTIVE, pHodir);
+            }
+        }
+        m_uiKeepersAlive++;
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+struct MANGOS_DLL_DECL freya_imageAI : public ScriptedAI
+{
+    freya_imageAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    void Reset() { }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+    }
+};
+
+bool GossipHello_freya_image(Player* pPlayer, Creature* pCreature)
+{
+    ScriptedInstance *m_pInstance = (ScriptedInstance *) pCreature->GetInstanceData();
+
+    if(m_pInstance && m_pInstance->GetData(TYPE_FREYA) == DONE)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, REQUEST_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, DENY_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_freya_image(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+    {
+        if(!GetClosestCreatureWithEntry(pCreature, KEEPER_FREYA, 200.0f))
+        {
+            if(Creature *pFreya = pCreature->SummonCreature(KEEPER_FREYA, KeepersLoc[2].x, KeepersLoc[2].y, KeepersLoc[2].z, KeepersLoc[2].o, TEMPSUMMON_MANUAL_DESPAWN, 30000))
+                DoScriptText(SAY_FREYA_ACTIVE, pFreya);  
+        }
+        m_uiKeepersAlive++;
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+struct MANGOS_DLL_DECL mimiron_imageAI : public ScriptedAI
+{
+    mimiron_imageAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    void Reset() { }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+    }
+};
+
+bool GossipHello_mimiron_image(Player* pPlayer, Creature* pCreature)
+{
+    ScriptedInstance *m_pInstance = (ScriptedInstance *) pCreature->GetInstanceData();
+
+    if(m_pInstance && m_pInstance->GetData(TYPE_MIMIRON) == DONE)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, REQUEST_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, DENY_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_mimiron_image(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+    {
+        if(!GetClosestCreatureWithEntry(pCreature, KEEPER_MIMIRON, 200.0f))
+        {
+            if(Creature *pMimiron = pCreature->SummonCreature(KEEPER_MIMIRON, KeepersLoc[3].x, KeepersLoc[3].y, KeepersLoc[3].z, KeepersLoc[3].o, TEMPSUMMON_MANUAL_DESPAWN, 30000))
+                DoScriptText(SAY_MIMIRON_ACTIVE, pMimiron);
+        }
+        m_uiKeepersAlive++;
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+struct MANGOS_DLL_DECL thorim_imageAI : public ScriptedAI
+{
+    thorim_imageAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    void Reset() {}
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+    }
+};
+
+bool GossipHello_thorim_image(Player* pPlayer, Creature* pCreature)
+{
+    ScriptedInstance *m_pInstance = (ScriptedInstance *) pCreature->GetInstanceData();
+
+    if(m_pInstance && m_pInstance->GetData(TYPE_THORIM) == DONE)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, REQUEST_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, DENY_HELP, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_thorim_image(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+    {
+        if(!GetClosestCreatureWithEntry(pCreature, KEEPER_THORIM, 200.0f))
+        {
+            if(Creature *pThorim = pCreature->SummonCreature(KEEPER_THORIM, KeepersLoc[0].x, KeepersLoc[0].y, KeepersLoc[0].z, KeepersLoc[0].o, TEMPSUMMON_MANUAL_DESPAWN, 30000))
+            {
+                pThorim->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.7f);
+                DoScriptText(SAY_THORIM_ACTIVE, pThorim);
+            }
+        }
+        m_uiKeepersAlive++;
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+2)
+    {
+        pCreature->SetVisibility(VISIBILITY_OFF);
+        pPlayer->CLOSE_GOSSIP_MENU();
+    }
+    return true;
+}
+
+/*
+*   Guardians
+*/
+class MANGOS_DLL_DECL EmpoweredAura : public Aura
+{
+public:
+    EmpoweredAura(const SpellEntry *spell, SpellEffectIndex eff, int32 *bp, Unit *target, Unit *caster) : Aura(spell, eff, bp, target, caster, NULL)
+    {}
+};
+struct MANGOS_DLL_DECL mob_immortal_guardianAI : public ScriptedAI
+{
+    mob_immortal_guardianAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        if(pCreature->isAlive())
+        {
+            sp = (SpellEntry *)GetSpellStore()->LookupEntry(SPELL_EMPOWERED);
+            bp = 8;
+            if(!pCreature->HasAura(SPELL_EMPOWERED, EFFECT_INDEX_0))
+                pCreature->AddAura(new EmpoweredAura(sp, EFFECT_INDEX_0, &bp, pCreature, pCreature));
+            pCreature->GetAura(SPELL_EMPOWERED, EFFECT_INDEX_0)->SetStackAmount(9);
+        }
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    SpellEntry const *sp;
+    int32 bp;
+
+    uint32 healthCheckTimer;
+    uint8 stack;
+    uint8 hp;
+
+    void Reset()
+    {
+        healthCheckTimer = 1000;
+        stack = 0;
+        hp = 90;
+
+        if(m_creature->isAlive())
+        {
+            if(!m_creature->HasAura(SPELL_EMPOWERED, EFFECT_INDEX_0))
+                m_creature->AddAura(new EmpoweredAura(sp, EFFECT_INDEX_0, &bp, m_creature, m_creature));
+            m_creature->GetAura(SPELL_EMPOWERED, EFFECT_INDEX_0)->SetStackAmount(9);
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= 1)
+            uiDamage = 0;
+    }
+
+    void SpellHit(Unit *caster, const SpellEntry *spell)
+    {
+        if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= 1)
+        {
+            if(spell->Id == SPELL_TITANIC_STORM && caster->GetEntry() == KEEPER_THORIM)
+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+    }
+
+    void Aggro(Unit *who) 
+    {
+        if(!m_creature->HasAura(SPELL_EMPOWERED, EFFECT_INDEX_0))
+            m_creature->AddAura(new EmpoweredAura(sp, EFFECT_INDEX_0, &bp, m_creature, m_creature));
+        m_creature->GetAura(SPELL_EMPOWERED, EFFECT_INDEX_0)->SetStackAmount(9);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(hp >= 10)
+        {
+            if (healthCheckTimer < uiDiff)
+            {
+                if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() <= hp)
+                {
+                    if(Aura *aura = m_creature->GetAura(SPELL_EMPOWERED, EFFECT_INDEX_0))
+                    {
+                        stack = aura->GetStackAmount();
+                        m_creature->GetAura(SPELL_EMPOWERED, EFFECT_INDEX_0)->SetStackAmount(stack - 1);
+                        hp -= 10;
+                    }
+                }
+                healthCheckTimer = 1000;
+            }else healthCheckTimer -= uiDiff;
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_guardian_of_yogg_saronAI : public ScriptedAI
+{
+    mob_guardian_of_yogg_saronAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 darkVolleyTimer;
+    uint32 selfKillTimer;
+    uint32 dominateMindTimer;
+    bool mustDie;
+    bool hasCasted;
+
+    void Reset()
+    {
+        darkVolleyTimer = 10000;
+        dominateMindTimer = 30000;
+        mustDie = false;
+        hasCasted = false;
+    }
+
+    void SpellHit(Unit *caster, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_SARAS_ANGER)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+            {
+                if(pTarget->GetTypeId() == TYPEID_PLAYER)
+                {
+                    m_creature->AddThreat(pTarget,100.0f);
+                    m_creature->AI()->AttackStart(pTarget);
+                }
+            }
+        }
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > m_creature->GetHealth() && !hasCasted)
+        {
+            m_creature->SetHealth(m_creature->GetMaxHealth());
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_SHADOW_NOVA : SPELL_SHADOW_NOVA_H);
+            uiDamage = 0;
+            selfKillTimer = 500;
+            mustDie = true;
+            hasCasted = true;
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (darkVolleyTimer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_DARK_VOLLEY);
+            darkVolleyTimer = 15000;
+        }else darkVolleyTimer -= uiDiff;
+
+        if (dominateMindTimer < uiDiff)
+        {
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, SPELL_DOMINATE_MIND);
+            dominateMindTimer = 30000;
+        }else dominateMindTimer -= uiDiff;
+
+        if (selfKillTimer < uiDiff && mustDie)
+        {
+            m_creature->DealDamage(m_creature, m_creature->GetMaxHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            selfKillTimer = 15000;
+        }else selfKillTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+/*
+*   Tentacules
+*/
+struct MANGOS_DLL_DECL mob_corruptor_tentacleAI : public ScriptedAI
+{
+    mob_corruptor_tentacleAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 eruptTimer;
+    bool hasErupted;
+    uint32 spellTimer;
+
+    void Reset()
+    {
+        eruptTimer = 100;
+        hasErupted = false;
+        spellTimer = 10000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (eruptTimer < uiDiff && !hasErupted)
+        {
+            DoCast(m_creature, SPELL_ERUPT);
+            hasErupted = true;
+        }else eruptTimer -= uiDiff;
+
+        if (spellTimer < uiDiff)
+        {
+            switch(urand(0, 3))
+            {
+            case 0:
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, SPELL_BLACK_PLAGUE);
+                break;
+            case 1:
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, SPELL_APATHY);
+                break;
+            case 2:
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, SPELL_CURSE_OF_DOOM);
+                break;
+            case 3:
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    DoCast(pTarget, SPELL_DRAINING_POISON);
+                break;
+            }
+            spellTimer = 10000;
+        }else spellTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_constrictor_tentacleAI : public ScriptedAI
+{
+    mob_constrictor_tentacleAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 squeezeTimer;
+
+    void Reset()
+    {
+        squeezeTimer = 10000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (squeezeTimer < uiDiff)
+        {
+            // broken spell
+            //if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+            //DoCast(pTarget, m_bIsRegularMode ? SPELL_SQUEEZE : SPELL_SQUEEZE_H);
+            squeezeTimer = 15000;
+        }else squeezeTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_crusher_tentacleAI : public ScriptedAI
+{
+    mob_crusher_tentacleAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    bool m_bIsRegularMode;
+    ScriptedInstance *m_pInstance;
+
+    uint32 eruptTimer;
+    bool hasErupted;
+    uint32 diminishPowerTimer;
+
+    void Reset()
+    {
+        eruptTimer = 100;
+        hasErupted = false;
+        diminishPowerTimer = 10000;
+    }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > 0)
+            DoCast(m_creature, SPELL_FOCUSED_ANGER);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (eruptTimer < uiDiff && !hasErupted)
+        {
+            DoCast(m_creature, SPELL_ERUPT);
+            hasErupted = true;
+        }else eruptTimer -= uiDiff;
+
+        if (diminishPowerTimer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_DIMINISH_POWER);
+            diminishPowerTimer = 10000 + urand(1000, 5000);
+        }else diminishPowerTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_vision_tentacleAI : public ScriptedAI
+{
+    mob_vision_tentacleAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SetCombatMovement(false);
+        Reset();
+    }
+    ScriptedInstance *m_pInstance;
+
+    void Reset()
+    {  }
+
+    void DamageTaken(Unit *done_by, uint32 &uiDamage)
+    {
+        if(uiDamage > 0 && m_creature->GetDisplayId() != 28813)
+            m_creature->SetDisplayId(28813);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+/*
+*   Other
+*/
+struct MANGOS_DLL_DECL mob_death_orbAI : public ScriptedAI
+{
+    mob_death_orbAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    uint32 checkTimer;
+
+    void Reset()
+    {
+        checkTimer = 1000;
+        DoCast(m_creature, SPELL_DEATH_RAY_AURA);
+        DoCast(m_creature, SPELL_DEATH_RAY_VISUAL);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (checkTimer < uiDiff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                        i->getSource()->DealDamage(i->getSource(), 10000, NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                }
+            } 
+            checkTimer = 1000;
+        }
+        else checkTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL mob_sanity_wellAI : public ScriptedAI
+{
+    mob_sanity_wellAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        SetCombatMovement(false);
+        Reset();
+    }
+
+    ScriptedInstance *m_pInstance;
+
+    uint32 checkTimer;
+    uint8 stack;
+
+    void Reset()
+    {
+        checkTimer = 2000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (checkTimer < uiDiff)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                {
+                    if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                    {
+                        // reduce sanity
+                        if(i->getSource()->HasAura(SPELL_SANITY, EFFECT_INDEX_0))
+                        {
+                            if(Aura *aura = i->getSource()->GetAura(SPELL_EMPOWERED, EFFECT_INDEX_0))
+                            {
+                                stack = aura->GetStackAmount();
+                                i->getSource()->GetAura(SPELL_EMPOWERED, EFFECT_INDEX_0)->SetStackAmount(stack - 1);
+                            }
+                        }
+                    }
+                }
+            } 
+            checkTimer = 2000;
+        }
+        else checkTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_yogg_saron(Creature* pCreature)
+{
+    return new boss_yogg_saronAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_sara(Creature* pCreature)
+{
+    return new boss_saraAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_madness_portal(Creature* pCreature)
+{
+    return new mob_madness_portalAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_brain_of_yogg_saron(Creature* pCreature)
+{
+    return new boss_brain_of_yogg_saronAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_corruptor_tentacle(Creature* pCreature)
+{
+    return new mob_corruptor_tentacleAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_constrictor_tentacle(Creature* pCreature)
+{
+    return new mob_constrictor_tentacleAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_crusher_tentacle(Creature* pCreature)
+{
+    return new mob_crusher_tentacleAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_vision_tentacle(Creature* pCreature)
+{
+    return new mob_vision_tentacleAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_guardian_of_yogg_saron(Creature* pCreature)
+{
+    return new mob_guardian_of_yogg_saronAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_immortal_guardian(Creature* pCreature)
+{
+    return new mob_immortal_guardianAI(pCreature);
+}
+
+CreatureAI* GetAI_keeper_hodir(Creature* pCreature)
+{
+    return new keeper_hodirAI(pCreature);
+}
+
+CreatureAI* GetAI_keeper_freya(Creature* pCreature)
+{
+    return new keeper_freyaAI(pCreature);
+}
+
+CreatureAI* GetAI_keeper_thorim(Creature* pCreature)
+{
+    return new keeper_thorimAI(pCreature);
+}
+
+CreatureAI* GetAI_keeper_mimiron(Creature* pCreature)
+{
+    return new keeper_mimironAI(pCreature);
+}
+
+CreatureAI* GetAI_hodir_image(Creature* pCreature)
+{
+    return new hodir_imageAI(pCreature);
+}
+
+CreatureAI* GetAI_freya_image(Creature* pCreature)
+{
+    return new freya_imageAI(pCreature);
+}
+
+CreatureAI* GetAI_thorim_image(Creature* pCreature)
+{
+    return new thorim_imageAI(pCreature);
+}
+
+CreatureAI* GetAI_mimiron_image(Creature* pCreature)
+{
+    return new mimiron_imageAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_death_orb(Creature* pCreature)
+{
+    return new mob_death_orbAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_sanity_well(Creature* pCreature)
+{
+    return new mob_sanity_wellAI(pCreature);
+}
+
+
+void AddSC_boss_yogg_saron()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_yogg_saron";
+    newscript->GetAI = &GetAI_boss_yogg_saron;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_sara";
+    newscript->GetAI = &GetAI_boss_sara;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_madness_portal";
+    newscript->GetAI = &GetAI_mob_madness_portal;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "boss_brain_of_yogg_saron";
+    newscript->GetAI = &GetAI_boss_brain_of_yogg_saron;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_corruptor_tentacle";
+    newscript->GetAI = &GetAI_mob_corruptor_tentacle;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_constrictor_tentacle";
+    newscript->GetAI = &GetAI_mob_constrictor_tentacle;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_crusher_tentacle";
+    newscript->GetAI = &GetAI_mob_crusher_tentacle;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_vision_tentacle";
+    newscript->GetAI = &GetAI_mob_vision_tentacle;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_guardian_of_yogg_saron";
+    newscript->GetAI = &GetAI_mob_guardian_of_yogg_saron;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_immortal_guardian";
+    newscript->GetAI = &GetAI_mob_immortal_guardian;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "keeper_hodir";
+    newscript->GetAI = &GetAI_keeper_hodir;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "keeper_freya";
+    newscript->GetAI = &GetAI_keeper_freya;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "keeper_thorim";
+    newscript->GetAI = &GetAI_keeper_thorim;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "keeper_mimiron";
+    newscript->GetAI = &GetAI_keeper_mimiron;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "hodir_image";
+    newscript->GetAI = &GetAI_hodir_image;
+    newscript->pGossipHello = &GossipHello_hodir_image;
+    newscript->pGossipSelect = &GossipSelect_hodir_image;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "freya_image";
+    newscript->GetAI = &GetAI_freya_image;
+    newscript->pGossipHello = &GossipHello_freya_image;
+    newscript->pGossipSelect = &GossipSelect_freya_image;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "thorim_image";
+    newscript->GetAI = &GetAI_thorim_image;
+    newscript->pGossipHello = &GossipHello_thorim_image;
+    newscript->pGossipSelect = &GossipSelect_thorim_image;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mimiron_image";
+    newscript->GetAI = &GetAI_mimiron_image;
+    newscript->pGossipHello = &GossipHello_mimiron_image;
+    newscript->pGossipSelect = &GossipSelect_mimiron_image;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_death_orb";
+    newscript->GetAI = &GetAI_mob_death_orb;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_sanity_well";
+    newscript->GetAI = &GetAI_mob_sanity_well;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/ulduar/ulduar/instance_ulduar.cpp b/scripts/northrend/ulduar/ulduar/instance_ulduar.cpp
index 2d87479..f3a46a2 100644
--- a/scripts/northrend/ulduar/ulduar/instance_ulduar.cpp
+++ b/scripts/northrend/ulduar/ulduar/instance_ulduar.cpp
@@ -1,4 +1,4 @@
-/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
@@ -24,17 +24,57 @@ EndScriptData */
 #include "precompiled.h"
 #include "ulduar.h"
 
+bool GOHello_go_red_button(Player* pPlayer, GameObject* pGo)
+{
+    ScriptedInstance* pInstance = (ScriptedInstance*)pGo->GetInstanceData();
+
+    if (!pInstance)
+        return false;
+
+    if(pGo->GetEntry() == G0_MIMIRON_BUTTON)
+        pInstance->SetData(TYPE_MIMIRON, SPECIAL);
+
+    return false;
+}
+
+bool GOHello_go_door_lever(Player* pPlayer, GameObject* pGo)
+{
+    ScriptedInstance* pInstance = (ScriptedInstance*)pGo->GetInstanceData();
+
+    if (!pInstance)
+        return false;
+
+    if(pGo->GetEntry() == GO_DOOR_LEVER)
+        pInstance->SetData(TYPE_THORIM, SPECIAL);
+
+    return false;
+}
+
+
 struct MANGOS_DLL_DECL instance_ulduar : public ScriptedInstance
 {
-    instance_ulduar(Map* pMap) : ScriptedInstance(pMap) { Initialize(); }
+    instance_ulduar(Map* pMap) : ScriptedInstance(pMap) 
+    { 
+        Regular = pMap->IsRegularDifficulty();
+        Initialize(); 
+    }
+
+    bool Regular;
 
     uint32 m_auiEncounter[MAX_ENCOUNTER];
     std::string m_strInstData;
+    uint32 mHardBoss[9];
+    uint32 mMiniBoss[6];
+    uint32 mVision[3];
+
+    uint32 m_uiDoorCheckTimer;
+    bool hasChecked;
 
     uint64 m_uiLeviathanGUID;
     uint64 m_uiIgnisGUID;
     uint64 m_uiRazorscaleGUID;
     uint64 m_uiXT002GUID;
+    uint64 m_uiXTheartGUID;
     uint64 m_auiAssemblyGUIDs[3];
     uint64 m_uiKologarnGUID;
     uint64 m_uiAuriayaGUID;
@@ -45,13 +85,106 @@ struct MANGOS_DLL_DECL instance_ulduar : public ScriptedInstance
     uint64 m_uiVezaxGUID;
     uint64 m_uiYoggSaronGUID;
     uint64 m_uiAlgalonGUID;
+    uint64 m_uiRightArmGUID;
+    uint64 m_uiLeftArmGUID;
+    uint64 m_uiSentryGUID1;
+    uint64 m_uiSentryGUID2;
+    uint64 m_uiSentryGUID3;
+    uint64 m_uiSentryGUID4;
+    uint64 m_uiFeralDefenderGUID;
+    uint64 m_uiElderBrightleafGUID;
+    uint64 m_uiElderStonebarkGUID;
+    uint64 m_uiElderIronbrachGUID;
+    uint64 m_uiSaroniteAnimusGUID;
+    uint64 m_uiRunicColossusGUID;
+    uint64 m_uiRuneGiantGUID;
+    uint64 m_uiLeviathanMkGUID;
+    uint64 m_uiVx001GUID;
+    uint64 m_uiAerialUnitGUID;
+    uint64 m_uiHodirImageGUID;
+    uint64 m_uiFreyaImageGUID;
+    uint64 m_uiThorimImageGUID;
+    uint64 m_uiMimironImageGUID;
+    uint64 m_uiSaraGUID;
+    uint64 m_uiYoggBrainGUID;
+
+    //doors & objects
+    // The siege
+    uint64 m_uiShieldWallGUID;
+    uint64 m_uiLeviathanGateGUID;
+    uint64 m_uiXT002GateGUID;
+    // Archivum
+    uint64 m_uiIronCouncilDoorGUID;
+    uint64 m_uiArchivumDoorGUID;
+    uint64 m_uiArchivumConsoleGUID;
+    uint64 m_uiUniverseFloorArchivumGUID;
+    // Celestial planetarium
+    uint64 m_uiCelestialDoorGUID;
+    uint64 m_uiCelestialConsoleGUID;
+    uint64 m_uiUniverseFloorCelestialGUID;
+    uint64 m_uiAzerothGlobeGUID;
+    // Kologarn
+    uint64 m_uiShatteredHallsDoorGUID;
+    uint64 m_uiKologarnBridgeGUID;
+    // Hodir
+    uint64 m_uiHodirEnterDoorGUID;
+    uint64 m_uiHodirWallGUID;
+    uint64 m_uiHodirExitDoorGUID;
+    // Mimiron
+    uint64 m_uiMimironButtonGUID;
+    uint64 m_uiMimironDoor1GUID;
+    uint64 m_uiMimironDoor2GUID;
+    uint64 m_uiMimironDoor3GUID;
+    uint64 m_uiMimironElevatorGUID;
+    uint64 m_uiMimironTelGUID[9];
+    // Thorim
+    uint64 m_uiArenaEnterDoorGUID;
+    uint64 m_uiArenaExitDoorGUID;
+    uint64 m_uiHallwayDoorGUID;
+    uint64 m_uiThorimEnterDoorGUID;
+    uint64 m_uiThorimLeverGUID;
+    // Prison
+    uint64 m_uiAncientGateGUID;
+    uint64 m_uiVezaxGateGUID;
+    uint64 m_uiYoggGateGUID;
+    uint64 m_uiBrainDoor1GUID;
+    uint64 m_uiBrainDoor2GUID;
+    uint64 m_uiBrainDoor3GUID;
+
+    // chests
+    uint64 m_uiKologarnLootGUID;
+    uint64 m_uiHodirLootGUID;
+    uint64 m_uiHodirRareLootGUID;
+    uint64 m_uiThorimLootGUID;
+    uint64 m_uiThorimRareLootGUID;
+    uint64 m_uiFreyaLootGUID;
+    uint64 m_uiFreyaRareLootGUID;
+    uint64 m_uiMimironLootGUID;
+    uint64 m_uiMimironRareLootGUID;
+    uint64 m_uiAlagonLootGUID;
 
     void Initialize()
     {
+        for(uint8 i = 0; i < 9; i++)
+            mHardBoss[i] = NOT_STARTED;
+
+        for(uint8 i = 0; i < 6; i++)
+            mMiniBoss[i] = NOT_STARTED;
+
+        for(uint8 i = 0; i < 9; i++)
+            m_uiMimironTelGUID[i] = 0;
+
+        for(uint8 i = 0; i < 3; i++)
+            mVision[i] = 0;
+
+        m_uiDoorCheckTimer      = 1000;
+        hasChecked              = false;
+
         m_uiLeviathanGUID       = 0;
         m_uiIgnisGUID           = 0;
         m_uiRazorscaleGUID      = 0;
         m_uiXT002GUID           = 0;
+        m_uiXTheartGUID         = 0;
         m_uiKologarnGUID        = 0;
         m_uiAuriayaGUID         = 0;
         m_uiMimironGUID         = 0;
@@ -61,6 +194,83 @@ struct MANGOS_DLL_DECL instance_ulduar : public ScriptedInstance
         m_uiVezaxGUID           = 0;
         m_uiYoggSaronGUID       = 0;
         m_uiAlgalonGUID         = 0;
+        m_uiRightArmGUID		= 0;
+        m_uiLeftArmGUID			= 0;
+        m_uiFeralDefenderGUID	= 0;
+        m_uiSentryGUID1			= 0;
+        m_uiSentryGUID2			= 0;
+        m_uiSentryGUID3			= 0;
+        m_uiSentryGUID4			= 0;
+        m_uiElderBrightleafGUID = 0;
+        m_uiElderStonebarkGUID  = 0;
+        m_uiElderIronbrachGUID  = 0;
+        m_uiSaroniteAnimusGUID  = 0;
+        m_uiRunicColossusGUID   = 0;
+        m_uiRuneGiantGUID       = 0;
+        m_uiLeviathanMkGUID     = 0;
+        m_uiVx001GUID           = 0;
+        m_uiAerialUnitGUID      = 0;
+        m_uiHodirImageGUID      = 0;
+        m_uiFreyaImageGUID      = 0;
+        m_uiThorimImageGUID     = 0;
+        m_uiMimironImageGUID    = 0;
+        m_uiSaraGUID            = 0;
+        m_uiYoggBrainGUID       = 0;
+
+        // loot
+        m_uiKologarnLootGUID	= 0;
+        m_uiHodirLootGUID       = 0;
+        m_uiHodirRareLootGUID   = 0;
+        m_uiThorimLootGUID      = 0;
+        m_uiThorimRareLootGUID  = 0;
+        m_uiFreyaLootGUID       = 0;
+        m_uiFreyaRareLootGUID   = 0;
+        m_uiMimironLootGUID     = 0;
+        m_uiMimironRareLootGUID = 0;
+        m_uiAlagonLootGUID      = 0;
+
+        // doors
+        // The siege
+        m_uiShieldWallGUID      = 0;
+        m_uiLeviathanGateGUID   = 0;
+        m_uiXT002GateGUID       = 0;
+        // Archivum
+        m_uiIronCouncilDoorGUID = 0;
+        m_uiArchivumDoorGUID    = 0;
+        m_uiArchivumConsoleGUID = 0;
+        m_uiUniverseFloorArchivumGUID = 0;
+        // Celestial planetarium
+        m_uiCelestialDoorGUID   = 0;
+        m_uiCelestialConsoleGUID = 0;
+        m_uiUniverseFloorCelestialGUID = 0;
+        m_uiAzerothGlobeGUID    = 0;
+        // Kologarn
+        m_uiShatteredHallsDoorGUID = 0;
+        m_uiKologarnBridgeGUID  = 0;
+        // Hodir
+        m_uiHodirEnterDoorGUID  = 0;
+        m_uiHodirWallGUID       = 0;
+        m_uiHodirExitDoorGUID   = 0;
+        // Mimiron
+        m_uiMimironButtonGUID   = 0;
+        m_uiMimironDoor1GUID    = 0;
+        m_uiMimironDoor2GUID    = 0;
+        m_uiMimironDoor3GUID    = 0;
+        m_uiMimironElevatorGUID = 0;
+        // Thorim
+        m_uiArenaEnterDoorGUID  = 0;
+        m_uiArenaExitDoorGUID   = 0;
+        m_uiHallwayDoorGUID     = 0;
+        m_uiThorimEnterDoorGUID = 0;
+        m_uiThorimLeverGUID     = 0;
+        // Prison
+        m_uiAncientGateGUID     = 0;
+        m_uiVezaxGateGUID       = 0;
+        m_uiYoggGateGUID        = 0;
+        m_uiBrainDoor1GUID      = 0;
+        m_uiBrainDoor2GUID      = 0;
+        m_uiBrainDoor3GUID      = 0;
+
 
         memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
         memset(&m_auiAssemblyGUIDs, 0, sizeof(m_auiAssemblyGUIDs));
@@ -81,87 +291,669 @@ struct MANGOS_DLL_DECL instance_ulduar : public ScriptedInstance
     {
         switch(pCreature->GetEntry())
         {
-            case NPC_LEVIATHAN:
-                m_uiLeviathanGUID = pCreature->GetGUID();
-                break;
-            case NPC_IGNIS:
-                m_uiIgnisGUID = pCreature->GetGUID();
-                break;
-            case NPC_RAZORSCALE:
-                m_uiRazorscaleGUID = pCreature->GetGUID();
-                break;
-            case NPC_XT002:
-                m_uiXT002GUID = pCreature->GetGUID();
-                break;
+        case NPC_LEVIATHAN:
+            m_uiLeviathanGUID = pCreature->GetGUID();
+            break;
+        case NPC_IGNIS:
+            m_uiIgnisGUID = pCreature->GetGUID();
+            break;
+        case NPC_RAZORSCALE:
+            m_uiRazorscaleGUID = pCreature->GetGUID();
+            break;
+        case NPC_XT002:
+            m_uiXT002GUID = pCreature->GetGUID();
+            break;
+        case NPC_HEART:
+            m_uiXTheartGUID = pCreature->GetGUID();
+            break;
 
             // Assembly of Iron
-            case NPC_STEELBREAKER:
-                m_auiAssemblyGUIDs[0] = pCreature->GetGUID();
-                break;
-            case NPC_MOLGEIM:
-                m_auiAssemblyGUIDs[1] = pCreature->GetGUID();
-                break;
-            case NPC_BRUNDIR:
-                m_auiAssemblyGUIDs[2] = pCreature->GetGUID();
-                break;
-
-            case NPC_KOLOGARN:
-                m_uiKologarnGUID = pCreature->GetGUID();
-                break;
-            case NPC_AURIAYA:
-                m_uiAuriayaGUID = pCreature->GetGUID();
-                break;
-            case NPC_MIMIRON:
-                m_uiMimironGUID = pCreature->GetGUID();
-                break;
-            case NPC_HODIR:
-                m_uiHodirGUID = pCreature->GetGUID();
-                break;
-            case NPC_THORIM:
-                m_uiThorimGUID = pCreature->GetGUID();
-                break;
-            case NPC_FREYA:
-                m_uiFreyaGUID = pCreature->GetGUID();
-                break;
-            case NPC_VEZAX:
-                m_uiVezaxGUID = pCreature->GetGUID();
-                break;
-            case NPC_YOGGSARON:
-                m_uiYoggSaronGUID = pCreature->GetGUID();
-                break;
-            case NPC_ALGALON:
-                m_uiAlgalonGUID = pCreature->GetGUID();
-                break;
+        case NPC_STEELBREAKER:
+            m_auiAssemblyGUIDs[0] = pCreature->GetGUID();
+            break;
+        case NPC_MOLGEIM:
+            m_auiAssemblyGUIDs[1] = pCreature->GetGUID();
+            break;
+        case NPC_BRUNDIR:
+            m_auiAssemblyGUIDs[2] = pCreature->GetGUID();
+            break;
+
+        case NPC_KOLOGARN:
+            m_uiKologarnGUID = pCreature->GetGUID();
+            break;
+        case NPC_RIGHT_ARM:
+            m_uiRightArmGUID = pCreature->GetGUID();
+            break;
+        case NPC_LEFT_ARM:
+            m_uiLeftArmGUID = pCreature->GetGUID();
+            break;
+        case NPC_AURIAYA:
+            m_uiAuriayaGUID = pCreature->GetGUID();
+            break;
+        case NPC_SANCTUM_SENTRY:
+            if (m_uiSentryGUID1 == 0)
+                m_uiSentryGUID1 = pCreature->GetGUID();
+            else if (m_uiSentryGUID2 == 0)
+                m_uiSentryGUID2 = pCreature->GetGUID();
+            else if (m_uiSentryGUID3 == 0)
+                m_uiSentryGUID3 = pCreature->GetGUID();
+            else if (m_uiSentryGUID4 == 0)
+                m_uiSentryGUID4 = pCreature->GetGUID();
+            break;
+        case NPC_FERAL_DEFENDER:
+            m_uiFeralDefenderGUID = pCreature->GetGUID();
+            break;
+        case NPC_MIMIRON:
+            m_uiMimironGUID = pCreature->GetGUID();
+            break;
+        case NPC_LEVIATHAN_MK:
+            m_uiLeviathanMkGUID = pCreature->GetGUID();
+            break;
+        case NPC_VX001:
+            m_uiVx001GUID = pCreature->GetGUID();
+            break;
+        case NPC_AERIAL_UNIT:
+            m_uiAerialUnitGUID = pCreature->GetGUID();
+            break;
+        case NPC_HODIR:
+            m_uiHodirGUID = pCreature->GetGUID();
+            break;
+        case NPC_THORIM:
+            m_uiThorimGUID = pCreature->GetGUID();
+            break;
+        case NPC_RUNIC_COLOSSUS:
+            m_uiRunicColossusGUID = pCreature->GetGUID();
+            break;
+        case NPC_ANCIENT_RUNE_GIANT:
+            m_uiRuneGiantGUID = pCreature->GetGUID();
+            break;
+        case NPC_FREYA:
+            m_uiFreyaGUID = pCreature->GetGUID();
+            break;
+        case NPC_BRIGHTLEAF:
+            m_uiElderBrightleafGUID = pCreature->GetGUID();
+            break;
+        case NPC_IRONBRACH:
+            m_uiElderIronbrachGUID = pCreature->GetGUID();
+            break;
+        case NPC_STONEBARK:
+            m_uiElderStonebarkGUID = pCreature->GetGUID();
+            break;
+        case NPC_VEZAX:
+            m_uiVezaxGUID = pCreature->GetGUID();
+            //pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE); // must fix this!
+            break;
+        case NPC_ANIMUS:
+            m_uiSaroniteAnimusGUID = pCreature->GetGUID();
+            break;
+        case NPC_YOGGSARON:
+            m_uiYoggSaronGUID = pCreature->GetGUID();
+            break;
+        case NPC_SARA:
+            m_uiSaraGUID = pCreature->GetGUID();
+            break;
+        case NPC_YOGG_BRAIN:
+            m_uiYoggBrainGUID = pCreature->GetGUID();
+            break;
+        case NPC_ALGALON:
+            m_uiAlgalonGUID = pCreature->GetGUID();
+            break;
+        case HODIR_IMAGE:
+            m_uiHodirImageGUID = pCreature->GetGUID();
+            break;
+        case FREYA_IMAGE:
+            m_uiFreyaImageGUID = pCreature->GetGUID();
+            break;
+        case THORIM_IMAGE:
+            m_uiThorimImageGUID = pCreature->GetGUID();
+            break;
+        case MIMIRON_IMAGE:
+            m_uiMimironImageGUID = pCreature->GetGUID();
+            break;
+        }
+    }
+
+    void OnObjectCreate(GameObject *pGo)
+    {
+        switch(pGo->GetEntry())
+        {
+            // doors & other
+            // The siege
+        case GO_SHIELD_WALL:
+            m_uiShieldWallGUID = pGo->GetGUID();
+            break;
+        case GO_LEVIATHAN_GATE:
+            m_uiLeviathanGateGUID = pGo->GetGUID();
+            if(m_auiEncounter[0])
+                pGo->SetGoState(GO_STATE_ACTIVE);
+            break;
+        case GO_XT002_GATE:
+            pGo->SetGoState(GO_STATE_READY);
+            m_uiXT002GateGUID = pGo->GetGUID();
+            break;
+
+            // Archivum
+        case GO_IRON_ENTRANCE_DOOR:
+            m_uiIronCouncilDoorGUID = pGo->GetGUID();
+            break;
+        case GO_ARCHIVUM_DOOR:
+            m_uiArchivumDoorGUID = pGo->GetGUID();
+            if(m_auiEncounter[4])
+                pGo->SetGoState(GO_STATE_ACTIVE);
+            break;
+        case GO_ARCHIVUM_CONSOLE:
+            m_uiArchivumConsoleGUID = pGo->GetGUID();
+            break;
+        case GO_UNIVERSE_FLOOR_ARCHIVUM:
+            m_uiUniverseFloorArchivumGUID = pGo->GetGUID();
+            break;
+            // Celestial Planetarium
+        case GO_CELESTIAL_ACCES:
+            m_uiCelestialConsoleGUID = pGo->GetGUID();
+            break;
+        case GO_CELESTIAL_DOOR:
+            m_uiCelestialDoorGUID = pGo->GetGUID();
+            break;
+        case GO_UNIVERSE_FLOOR_CELESTIAL:
+            m_uiUniverseFloorCelestialGUID = pGo->GetGUID();
+            break;
+        case GO_AZEROTH_GLOBE:
+            m_uiAzerothGlobeGUID = pGo->GetGUID();
+            break;
+            // Shattered Hallway
+        case GO_KOLOGARN_BRIDGE:
+            m_uiKologarnBridgeGUID = pGo->GetGUID();
+            if(m_auiEncounter[5] == DONE)
+                pGo->SetGoState(GO_STATE_ACTIVE);
+            else
+                pGo->SetGoState(GO_STATE_READY);
+            break;
+        case GO_SHATTERED_DOOR:
+            m_uiShatteredHallsDoorGUID = pGo->GetGUID();
+            break;
+
+            // The keepers
+            // Hodir
+        case GO_HODIR_EXIT:
+            m_uiHodirExitDoorGUID = pGo->GetGUID();
+            if(m_auiEncounter[8])
+                pGo->SetGoState(GO_STATE_ACTIVE);
+            break;
+        case GO_HODIR_ICE_WALL:
+            m_uiHodirWallGUID = pGo->GetGUID();
+            if(m_auiEncounter[8])
+                pGo->SetGoState(GO_STATE_ACTIVE);
+            break;
+        case GO_HODIR_ENTER:
+            m_uiHodirEnterDoorGUID = pGo->GetGUID();
+            break;
+            // Mimiron
+        case G0_MIMIRON_BUTTON:
+            m_uiMimironButtonGUID = pGo->GetGUID();
+            if (m_auiEncounter[7] == NOT_STARTED)
+                pGo->RemoveFlag(GAMEOBJECT_FLAGS, GO_FLAG_UNK1);
+            break;
+        case GO_MIMIRON_DOOR_1:
+            m_uiMimironDoor1GUID = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_DOOR_2:
+            m_uiMimironDoor2GUID = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_DOOR_3:
+            m_uiMimironDoor3GUID = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_ELEVATOR:
+            m_uiMimironElevatorGUID = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL1:
+            m_uiMimironTelGUID[0] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL2:
+            m_uiMimironTelGUID[1] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL3:
+            m_uiMimironTelGUID[2] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL4:
+            m_uiMimironTelGUID[3] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL5:
+            m_uiMimironTelGUID[4] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL6:
+            m_uiMimironTelGUID[5] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL7:
+            m_uiMimironTelGUID[6] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL8:
+            m_uiMimironTelGUID[7] = pGo->GetGUID();
+            break;
+        case GO_MIMIRON_TEL9:
+            m_uiMimironTelGUID[8] = pGo->GetGUID();
+            break;
+            // Thorim
+        case GO_DARK_IRON_PORTCULIS:
+            m_uiArenaExitDoorGUID = pGo->GetGUID();
+            break;
+        case GO_RUNED_STONE_DOOR:
+            m_uiHallwayDoorGUID = pGo->GetGUID();
+            break;
+        case GO_THORIM_STONE_DOOR:
+            m_uiThorimEnterDoorGUID = pGo->GetGUID();
+            break;
+        case GO_LIGHTNING_FIELD:
+            m_uiArenaEnterDoorGUID = pGo->GetGUID();
+            break;
+        case GO_DOOR_LEVER:
+            m_uiThorimLeverGUID = pGo->GetGUID();
+            break;
+
+            // Prison
+        case GO_ANCIENT_GATE:
+            m_uiAncientGateGUID = pGo->GetGUID();
+            OpenMadnessDoor();
+            break;
+        case GO_VEZAX_GATE:
+            m_uiVezaxGateGUID = pGo->GetGUID();
+            if(m_auiEncounter[11])
+                pGo->SetGoState(GO_STATE_ACTIVE);
+            break;
+        case GO_YOGG_GATE:
+            m_uiYoggGateGUID = pGo->GetGUID();
+            break;
+        case GO_BRAIN_DOOR1:
+            m_uiBrainDoor1GUID = pGo->GetGUID();
+            break;
+        case GO_BRAIN_DOOR2:
+            m_uiBrainDoor2GUID = pGo->GetGUID();
+            break;
+        case GO_BRAIN_DOOR3:
+            m_uiBrainDoor3GUID = pGo->GetGUID();
+            break;
+
+            // loot
+            // Kologarn
+        case GO_CACHE_OF_LIVING_STONE:
+            if(Regular)
+                m_uiKologarnLootGUID = pGo->GetGUID();
+            break;
+        case GO_CACHE_OF_LIVING_STONE_H:
+            if(!Regular)
+                m_uiKologarnLootGUID = pGo->GetGUID();
+            break;
+            
+            // Hodir
+        case GO_CACHE_OF_WINTER:
+            if(Regular)
+                m_uiHodirLootGUID = pGo->GetGUID();
+            break;
+        case GO_CACHE_OF_WINTER_H:
+            if(!Regular)
+                m_uiHodirLootGUID = pGo->GetGUID();
+            break;
+            // Hodir rare
+        case GO_CACHE_OF_RARE_WINTER:
+            if(Regular)
+                m_uiHodirRareLootGUID = pGo->GetGUID();
+            break;
+        case GO_CACHE_OF_RARE_WINTER_H:
+            if(!Regular)
+                m_uiHodirRareLootGUID = pGo->GetGUID();
+            break;
+
+            // Freya
+        case GO_FREYA_GIFT:
+            if(Regular)
+                m_uiFreyaLootGUID = pGo->GetGUID();
+            break;
+        case GO_FREYA_GIFT_H:
+            if(!Regular)
+                m_uiFreyaLootGUID = pGo->GetGUID();
+            break;
+            // Freya rare
+        case GO_FREYA_GIFT_RARE:   
+            if(Regular)
+                m_uiFreyaRareLootGUID = pGo->GetGUID();
+            break;
+        case GO_FREYA_GIFT_RARE_H: 
+            if(!Regular)
+                m_uiFreyaRareLootGUID = pGo->GetGUID();
+            break;
+
+            // Thorim
+        case GO_CACHE_OF_STORMS:
+            if(Regular)
+                m_uiThorimLootGUID = pGo->GetGUID();
+            break;
+        case GO_CACHE_OF_STORMS_H:
+            if(!Regular)
+                m_uiThorimLootGUID = pGo->GetGUID();
+            break;
+            // Thorim rare
+        case GO_CACHE_OF_RARE_STORMS:
+            if(Regular)
+                m_uiThorimRareLootGUID = pGo->GetGUID();
+            break;
+        case GO_CACHE_OF_RARE_STORMS_H:
+            if(!Regular)
+                m_uiThorimRareLootGUID = pGo->GetGUID();
+            break;
+
+            // Mimiron
+        case GO_CACHE_OF_INOVATION:
+            if(Regular)
+                m_uiMimironLootGUID = pGo->GetGUID();
+            break;
+        case GO_CACHE_OF_INOVATION_H:
+            if(!Regular)
+                m_uiMimironLootGUID = pGo->GetGUID();
+            break;
+            // Mimiron rare
+        case GO_FREYA_GIFT1:    // fix id
+            if(Regular)
+                m_uiMimironRareLootGUID = pGo->GetGUID();
+            break;
+        case GO_FREYA_GIFT5:    // fix id
+            if(!Regular)
+                m_uiMimironRareLootGUID = pGo->GetGUID();
+            break;
+
+            // Alagon
+        case GO_GIFT_OF_OBSERVER:
+            if(Regular)
+                m_uiAlagonLootGUID = pGo->GetGUID();
+            break;
+        case GO_GIFT_OF_OBSERVER_H:
+            if(!Regular)
+                m_uiAlagonLootGUID = pGo->GetGUID();
+            break;
         }
     }
 
-    /*void OnObjectCreate(GameObject *pGo)
+    void Update (uint32 diff)
+    {
+        if (m_uiDoorCheckTimer <= diff && !hasChecked)
+        {
+            OpenMadnessDoor();
+            m_uiDoorCheckTimer = 1000;//remove stress from core
+        } else m_uiDoorCheckTimer -= diff;
+    }
+
+    void OpenDoor(uint64 guid)
     {
-    }*/
+        if(!guid) return;
+        GameObject* pGo = instance->GetGameObject(guid);
+        if(pGo) pGo->SetGoState(GO_STATE_ACTIVE);
+    }
+
+    void CloseDoor(uint64 guid)
+    {
+        if(!guid) return;
+        GameObject* pGo = instance->GetGameObject(guid);
+        if(pGo) pGo->SetGoState(GO_STATE_READY);
+    }
+
+    void OpenMadnessDoor()
+    {
+        if(m_auiEncounter[7] == DONE && m_auiEncounter[8] == DONE && m_auiEncounter[9] == DONE && m_auiEncounter[10] == DONE)
+        {
+            if(Creature *pVezax = instance->GetCreature(m_uiVezaxGUID))
+                pVezax->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            OpenDoor(m_uiAncientGateGUID);
+            hasChecked = true;
+        }
+    }
 
     void SetData(uint32 uiType, uint32 uiData)
     {
         switch(uiType)
         {
-            case TYPE_LEVIATHAN:
-            case TYPE_IGNIS:
-            case TYPE_RAZORSCALE:
-            case TYPE_XT002:
-            case TYPE_ASSEMBLY:
-            case TYPE_KOLOGARN:
-            case TYPE_AURIAYA:
-            case TYPE_MIMIRON:
-            case TYPE_HODIR:
-            case TYPE_THORIM:
-            case TYPE_FREYA:
-            case TYPE_VEZAX:
-            case TYPE_YOGGSARON:
-            case TYPE_ALGALON:
-                m_auiEncounter[uiType] = uiData;
-                break;
+        case TYPE_LEVIATHAN:
+            m_auiEncounter[0] = uiData;
+            if (uiData == IN_PROGRESS)
+                CloseDoor(m_uiShieldWallGUID);
+            else
+                OpenDoor(m_uiShieldWallGUID);
+            if (uiData == DONE)
+            {
+                OpenDoor(m_uiXT002GateGUID);
+                DoUseDoorOrButton(m_uiLeviathanGateGUID);
+            }
+            break;
+        case TYPE_IGNIS:
+            m_auiEncounter[1] = uiData;
+            break;
+        case TYPE_RAZORSCALE:
+            m_auiEncounter[2] = uiData;
+            break;
+        case TYPE_XT002:
+            m_auiEncounter[3] = uiData;
+            if (uiData == IN_PROGRESS)
+                CloseDoor(m_uiXT002GateGUID);
+            else
+                OpenDoor(m_uiXT002GateGUID);
+            break;
+        case TYPE_ASSEMBLY:
+            m_auiEncounter[4] = uiData;
+            if (uiData == IN_PROGRESS)
+                CloseDoor(m_uiIronCouncilDoorGUID);
+            else
+                OpenDoor(m_uiIronCouncilDoorGUID);
+            if (uiData == DONE)
+            {
+                DoUseDoorOrButton(m_uiArchivumDoorGUID);
+                CheckIronCouncil();
+            }
+            break;
+        case TYPE_KOLOGARN:
+            m_auiEncounter[5] = uiData;
+            if (uiData == IN_PROGRESS)
+                CloseDoor(m_uiShatteredHallsDoorGUID);
+            else
+                OpenDoor(m_uiShatteredHallsDoorGUID);
+            if (uiData == DONE)
+            {
+                DoRespawnGameObject(m_uiKologarnLootGUID, 30*MINUTE);
+                CheckIronCouncil();
+                if (GameObject* pBridge = instance->GetGameObject(m_uiKologarnBridgeGUID))
+                    pBridge->SetGoState(GO_STATE_READY);
+            }
+            break;
+        case TYPE_AURIAYA:
+            m_auiEncounter[6] = uiData;
+            if (uiData == DONE)
+                CheckIronCouncil();
+            break;
+
+            // Keepers
+        case TYPE_MIMIRON:
+            m_auiEncounter[7] = uiData;
+            if (uiData == IN_PROGRESS)
+            {
+                CloseDoor(m_uiMimironDoor1GUID);
+                CloseDoor(m_uiMimironDoor2GUID);
+                CloseDoor(m_uiMimironDoor3GUID);
+            }
+            else
+            {
+                OpenDoor(m_uiMimironDoor1GUID);
+                OpenDoor(m_uiMimironDoor2GUID);
+                OpenDoor(m_uiMimironDoor3GUID);
+            }
+            if (uiData == DONE)
+            {
+                DoRespawnGameObject(m_uiMimironLootGUID, 30*MINUTE);
+                OpenMadnessDoor();
+            }
+            if (uiData == NOT_STARTED)
+                OpenDoor(m_uiMimironButtonGUID);
+            break;
+        case TYPE_HODIR:
+            m_auiEncounter[8] = uiData;
+            if (uiData == IN_PROGRESS)
+                CloseDoor(m_uiHodirEnterDoorGUID);
+            else
+                OpenDoor(m_uiHodirEnterDoorGUID);
+            if (uiData == DONE)
+            {
+                DoUseDoorOrButton(m_uiHodirWallGUID);
+                DoUseDoorOrButton(m_uiHodirExitDoorGUID);
+                DoRespawnGameObject(m_uiHodirLootGUID, 30*MINUTE);
+                OpenMadnessDoor();
+            }    
+            break;
+        case TYPE_THORIM:
+            m_auiEncounter[9] = uiData;   
+            if (uiData == IN_PROGRESS)
+            {
+                CloseDoor(m_uiArenaEnterDoorGUID);
+                DoUseDoorOrButton(m_uiArenaExitDoorGUID);
+            }
+            else
+                OpenDoor(m_uiArenaEnterDoorGUID);
+            if (uiData == DONE)
+            {
+                DoRespawnGameObject(m_uiThorimLootGUID, 30*MINUTE);
+                OpenMadnessDoor();
+            }
+            break;
+        case TYPE_FREYA:
+            m_auiEncounter[10] = uiData;
+            if (uiData == DONE)
+            {
+                DoRespawnGameObject(m_uiFreyaLootGUID, 30*MINUTE);
+                OpenMadnessDoor();
+            }
+            break;
+
+            // Prison
+        case TYPE_VEZAX:
+            m_auiEncounter[11] = uiData;
+            if (uiData == DONE)
+                DoUseDoorOrButton(m_uiVezaxGateGUID);
+            break;
+        case TYPE_YOGGSARON:
+            m_auiEncounter[12] = uiData;
+            if (uiData == IN_PROGRESS)
+                CloseDoor(m_uiYoggGateGUID);
+            else
+                OpenDoor(m_uiYoggGateGUID);
+            if (uiData == DONE)
+                OpenDoor(m_uiCelestialDoorGUID);
+            break;
+
+            // Celestial Planetarium
+        case TYPE_ALGALON:
+            m_auiEncounter[13] = uiData;
+            if (uiData == DONE)
+            {
+                DoRespawnGameObject(m_uiAlagonLootGUID, 30*MINUTE);
+                OpenDoor(m_uiCelestialDoorGUID);
+            }
+            if (uiData == IN_PROGRESS)
+            {
+                OpenDoor(m_uiUniverseFloorCelestialGUID);
+                CloseDoor(m_uiCelestialDoorGUID);
+            }
+            else
+                CloseDoor(m_uiUniverseFloorCelestialGUID);
+            break;
+
+            // Hard modes
+        case TYPE_LEVIATHAN_HARD:
+            mHardBoss[0] = uiData;  // todo: add extra loot
+            break;
+        case TYPE_XT002_HARD:
+            mHardBoss[1] = uiData;  // todo: add extra loot
+            break;
+        case TYPE_HODIR_HARD:
+            mHardBoss[4] = uiData;
+            if(uiData == DONE)
+                DoRespawnGameObject(m_uiHodirRareLootGUID, 30*MINUTE);
+            break;
+        case TYPE_ASSEMBLY_HARD:
+            mHardBoss[2] = uiData;  // todo: add extra loot
+            break;
+        case TYPE_FREYA_HARD:
+            mHardBoss[6] = uiData;  // todo: add extra loot
+            break;
+        case TYPE_THORIM_HARD:
+            mHardBoss[5] = uiData;  // todo: add extra loot
+            break;
+        case TYPE_MIMIRON_HARD:
+            mHardBoss[3] = uiData;  // todo: add extra loot
+            break;
+        case TYPE_VEZAX_HARD:
+            mHardBoss[7] = uiData;  // todo: add extra loot
+            break;
+        case TYPE_YOGGSARON_HARD:
+            mHardBoss[8] = uiData;  // todo: add extra loot
+            break;
+
+
+            // mini boss
+        case TYPE_RUNIC_COLOSSUS:
+            mMiniBoss[0] = uiData;
+            if (uiData == DONE)
+                OpenDoor(m_uiHallwayDoorGUID);
+            else
+                CloseDoor(m_uiHallwayDoorGUID);
+            break;
+        case TYPE_RUNE_GIANT:
+            mMiniBoss[1] = uiData;
+            if (uiData == DONE)
+                OpenDoor(m_uiThorimEnterDoorGUID);
+            else
+                CloseDoor(m_uiThorimEnterDoorGUID);
+            break;
+        case TYPE_LEVIATHAN_MK:
+            mMiniBoss[2] = uiData;
+            if (uiData == DONE)
+                CloseDoor(m_uiMimironElevatorGUID);
+            break;
+        case TYPE_VX001:
+            mMiniBoss[3] = uiData;
+            if (uiData == SPECIAL)
+                OpenDoor(m_uiMimironElevatorGUID);
+            if (uiData == DONE)     // just for animation :)
+            {
+                for(uint8 i = 0; i < 9; i++)
+                    DoUseDoorOrButton(m_uiMimironTelGUID[i]);
+            }
+            break;
+        case TYPE_AERIAL_UNIT:
+            mMiniBoss[4] = uiData;
+            break;
+        case TYPE_YOGG_BRAIN:
+            mMiniBoss[5] = uiData;
+            break;
+
+            //visions
+        case TYPE_VISION1:
+            mVision[0] = uiData;
+            if (uiData == DONE)
+                OpenDoor(m_uiBrainDoor3GUID);
+            else
+                CloseDoor(m_uiBrainDoor3GUID);
+            break;
+        case TYPE_VISION2:
+            mVision[1] = uiData;
+            if (uiData == DONE)
+                OpenDoor(m_uiBrainDoor1GUID);
+            else
+                CloseDoor(m_uiBrainDoor1GUID);
+            break;
+        case TYPE_VISION3:
+            mVision[2] = uiData;
+            if (uiData == DONE)
+                OpenDoor(m_uiBrainDoor2GUID);
+            else
+                CloseDoor(m_uiBrainDoor2GUID);
+            break;
         }
 
-        if (uiData == DONE)
+        if (uiData == DONE || uiData == SPECIAL || uiData == FAIL)
         {
             OUT_SAVE_INST_DATA;
 
@@ -181,40 +973,94 @@ struct MANGOS_DLL_DECL instance_ulduar : public ScriptedInstance
     {
         switch(uiData)
         {
-            case TYPE_LEVIATHAN:
-                return m_uiLeviathanGUID;
-            case TYPE_IGNIS:
-                return m_uiIgnisGUID;
-            case TYPE_RAZORSCALE:
-                return m_uiRazorscaleGUID;
-            case TYPE_XT002:
-                return m_uiXT002GUID;
-            case TYPE_KOLOGARN:
-                return m_uiKologarnGUID;
-            case TYPE_AURIAYA:
-                return m_uiAuriayaGUID;
-            case TYPE_MIMIRON:
-                return m_uiMimironGUID;
-            case TYPE_HODIR:
-                return m_uiMimironGUID;
-            case TYPE_THORIM:
-                return m_uiThorimGUID;
-            case TYPE_FREYA:
-                return m_uiFreyaGUID;
-            case TYPE_VEZAX:
-                return m_uiVezaxGUID;
-            case TYPE_YOGGSARON:
-                return m_uiYoggSaronGUID;
-            case TYPE_ALGALON:
-                return m_uiAlgalonGUID;
+        case DATA_LEVIATHAN:
+            return m_uiLeviathanGUID;
+        case DATA_IGNIS:
+            return m_uiIgnisGUID;
+        case DATA_RAZORSCALE:
+            return m_uiRazorscaleGUID;
+        case DATA_XT002:
+            return m_uiXT002GUID;
+        case DATA_HEART:
+            return m_uiXTheartGUID;
+        case DATA_KOLOGARN:
+            return m_uiKologarnGUID;
+        case DATA_LEFT_ARM:
+            return m_uiLeftArmGUID;
+        case DATA_RIGHT_ARM:
+            return m_uiRightArmGUID;
+        case DATA_AURIAYA:
+            return m_uiAuriayaGUID;
+        case DATA_SENTRY_1:
+            return m_uiSentryGUID1;
+        case DATA_SENTRY_2:
+            return m_uiSentryGUID2;
+        case DATA_SENTRY_3:
+            return m_uiSentryGUID3;
+        case DATA_SENTRY_4:
+            return m_uiSentryGUID4;
+        case DATA_FERAL_DEFENDER:
+            return m_uiFeralDefenderGUID;
+        case DATA_MIMIRON:
+            return m_uiMimironGUID;
+        case DATA_LEVIATHAN_MK:
+            return m_uiLeviathanMkGUID;
+        case DATA_VX001:
+            return m_uiVx001GUID;
+        case DATA_AERIAL_UNIT:
+            return m_uiAerialUnitGUID;
+        case DATA_HODIR:
+            return m_uiMimironGUID;
+        case DATA_THORIM:
+            return m_uiThorimGUID;
+        case DATA_RUNE_GIANT:
+            return m_uiRuneGiantGUID;
+        case DATA_RUNIC_COLOSSUS:
+            return m_uiRunicColossusGUID;
+        case DATA_FREYA:
+            return m_uiFreyaGUID;
+        case DATA_BRIGHTLEAF:
+            return m_uiElderBrightleafGUID;
+        case DATA_IRONBRACH:
+            return m_uiElderIronbrachGUID;
+        case DATA_STONEBARK:
+            return m_uiElderStonebarkGUID;
+        case DATA_VEZAX:
+            return m_uiVezaxGUID;
+        case DATA_MADNESS_DOOR:
+            return m_uiAncientGateGUID;
+        case DATA_ANIMUS:
+            return m_uiSaroniteAnimusGUID;
+        case DATA_YOGGSARON:
+            return m_uiYoggSaronGUID;
+        case DATA_SARA:
+            return m_uiSaraGUID;
+        case DATA_YOGG_BRAIN:
+            return m_uiYoggBrainGUID;
+        case DATA_ALGALON:
+            return m_uiAlgalonGUID;
+        case DATA_HODIR_IMAGE:
+            return m_uiHodirImageGUID;
+        case DATA_FREYA_IMAGE:
+            return m_uiFreyaImageGUID;
+        case DATA_THORIM_IMAGE:
+            return m_uiThorimImageGUID;
+        case DATA_MIMIRON_IMAGE:
+            return m_uiMimironImageGUID;
 
             // Assembly of Iron
-            case DATA_STEELBREAKER:
-                return m_auiAssemblyGUIDs[0];
-            case DATA_MOLGEIM:
-                return m_auiAssemblyGUIDs[1];
-            case DATA_BRUNDIR:
-                return m_auiAssemblyGUIDs[2];
+        case DATA_STEELBREAKER:
+            return m_auiAssemblyGUIDs[0];
+        case DATA_MOLGEIM:
+            return m_auiAssemblyGUIDs[1];
+        case DATA_BRUNDIR:
+            return m_auiAssemblyGUIDs[2];
+
+        case DATA_RED_BUTTON:
+            return m_uiMimironButtonGUID;
+
+        case DATA_THORIM_LEVER:
+            return m_uiThorimLeverGUID;
         }
 
         return 0;
@@ -224,21 +1070,62 @@ struct MANGOS_DLL_DECL instance_ulduar : public ScriptedInstance
     {
         switch(uiType)
         {
-            case TYPE_LEVIATHAN:
-            case TYPE_IGNIS:
-            case TYPE_RAZORSCALE:
-            case TYPE_XT002:
-            case TYPE_ASSEMBLY:
-            case TYPE_KOLOGARN:
-            case TYPE_AURIAYA:
-            case TYPE_MIMIRON:
-            case TYPE_HODIR:
-            case TYPE_THORIM:
-            case TYPE_FREYA:
-            case TYPE_VEZAX:
-            case TYPE_YOGGSARON:
-            case TYPE_ALGALON:
-                return m_auiEncounter[uiType];
+        case TYPE_LEVIATHAN:
+        case TYPE_IGNIS:
+        case TYPE_RAZORSCALE:
+        case TYPE_XT002:
+        case TYPE_ASSEMBLY:
+        case TYPE_KOLOGARN:
+        case TYPE_AURIAYA:
+        case TYPE_MIMIRON:
+        case TYPE_HODIR:
+        case TYPE_THORIM:
+        case TYPE_FREYA:
+        case TYPE_VEZAX:
+        case TYPE_YOGGSARON:
+        case TYPE_ALGALON:
+            return m_auiEncounter[uiType];
+
+        // hard modes
+        case TYPE_LEVIATHAN_HARD:
+            return mHardBoss[0];
+        case TYPE_XT002_HARD:
+            return mHardBoss[1];
+        case TYPE_ASSEMBLY_HARD:
+            return mHardBoss[2];
+        case TYPE_MIMIRON_HARD:
+            return mHardBoss[3];
+        case TYPE_HODIR_HARD:
+            return mHardBoss[4];
+        case TYPE_THORIM_HARD:
+            return mHardBoss[5];
+        case TYPE_FREYA_HARD:
+            return mHardBoss[6];
+        case TYPE_VEZAX_HARD:
+            return mHardBoss[7];
+        case TYPE_YOGGSARON_HARD:
+            return mHardBoss[8];
+
+            // mini boss
+        case TYPE_RUNE_GIANT:
+            return mMiniBoss[1];
+        case TYPE_RUNIC_COLOSSUS:
+            return mMiniBoss[0];
+        case TYPE_LEVIATHAN_MK:
+            return mMiniBoss[2];
+        case TYPE_VX001:
+            return mMiniBoss[3];
+        case TYPE_AERIAL_UNIT:
+            return mMiniBoss[4];
+        case TYPE_YOGG_BRAIN:
+            return mMiniBoss[5];
+
+        case TYPE_VISION1:
+            return mVision[0];
+        case TYPE_VISION2:
+            return mVision[1];
+        case TYPE_VISION3:
+            return mVision[2];
         }
 
         return 0;
@@ -271,6 +1158,13 @@ struct MANGOS_DLL_DECL instance_ulduar : public ScriptedInstance
 
         OUT_LOAD_INST_DATA_COMPLETE;
     }
+
+    void CheckIronCouncil()
+    {
+        // check if the other bosses in the antechamber are dead
+        if(m_auiEncounter[4] == DONE && m_auiEncounter[5] == DONE && m_auiEncounter[6] == DONE)
+            DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEV_IRON_COUNCIL : ACHIEV_IRON_COUNCIL_H);
+    }
 };
 
 InstanceData* GetInstanceData_instance_ulduar(Map* pMap)
@@ -285,4 +1179,14 @@ void AddSC_instance_ulduar()
     newscript->Name = "instance_ulduar";
     newscript->GetInstanceData = &GetInstanceData_instance_ulduar;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "go_red_button";
+    newscript->pGOHello = &GOHello_go_red_button;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "go_door_lever";
+    newscript->pGOHello = &GOHello_go_door_lever;
+    newscript->RegisterSelf();
 }
diff --git a/scripts/northrend/ulduar/ulduar/ulduar.cpp b/scripts/northrend/ulduar/ulduar/ulduar.cpp
new file mode 100644
index 0000000..2a5913a
--- /dev/null
+++ b/scripts/northrend/ulduar/ulduar/ulduar.cpp
@@ -0,0 +1,158 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: Ulduar teleport
+SD%Complete:
+SDComment:
+SDCategory: Ulduar
+EndScriptData */
+
+#include "precompiled.h"
+#include "ulduar.h"
+
+/*
+The teleporter appears to be active and stable.
+
+- Expedition Base Camp
+- Formation Grounds
+- Colossal Forge
+- Scrapyard
+- Antechamber of Ulduar
+- Shattered Walkway
+- Conservatory of Life
+- Spark of Imagination
+- Prison of Yogg-Saron
+*/
+
+#define BASE_CAMP    200
+#define GROUNDS      201
+#define FORGE        202
+#define SCRAPYARD    203
+#define ANTECHAMBER  204
+#define WALKWAY      205
+#define CONSERVATORY 206
+#define SPARK        207
+#define PRISON       208
+
+// spells
+#define SPELL_TELEPORT_BASE_CAMP    64014
+#define SPELL_TELEPORT_GROUNDS      64032
+#define SPELL_TELEPORT_FORGE        64028
+#define SPELL_TELEPORT_SCRAPYARD    64031
+#define SPELL_TELEPORT_ANTECHAMBER  64030
+#define SPELL_TELEPORT_WALKWAY      64029
+#define SPELL_TELEPORT_CONSERVATORY 64024
+#define SPELL_TELEPORT_SPARK        65061
+#define SPELL_TELEPORT_PRISON       65042
+
+
+bool GoHello_ulduar_teleporter( Player *pPlayer, GameObject *pGO )
+{
+    ScriptedInstance *pInstance = (ScriptedInstance *) pGO->GetInstanceData();
+    if(!pInstance) return true;
+
+    // base camp
+    pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Expedition Base Camp", GOSSIP_SENDER_MAIN, BASE_CAMP);
+
+    // formation grounds & colossal forge
+    if(pInstance->GetData(TYPE_IGNIS) == DONE || pInstance->GetData(TYPE_RAZORSCALE) == DONE)
+    {
+        pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Formation Grounds", GOSSIP_SENDER_MAIN, GROUNDS);
+        pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Colossal Forge", GOSSIP_SENDER_MAIN, FORGE);
+
+
+        // scrapyard & antechamber
+        if(pInstance->GetData(TYPE_XT002) == DONE)
+        {
+            pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Scrapyard", GOSSIP_SENDER_MAIN, SCRAPYARD);
+            pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Antechamber of Ulduar", GOSSIP_SENDER_MAIN, ANTECHAMBER);
+        }
+    }
+
+    // shattered walkway
+    if(pInstance->GetData(TYPE_KOLOGARN) == DONE)
+        pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Shattered Walkway", GOSSIP_SENDER_MAIN, WALKWAY);
+
+    // conservatory of life
+    if(pInstance->GetData(TYPE_AURIAYA) == DONE)
+        pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Conservatory of Life", GOSSIP_SENDER_MAIN, CONSERVATORY);
+
+    // spark of imagination
+    if(pInstance->GetData(TYPE_MIMIRON) == DONE)
+        pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Spark of Imagination", GOSSIP_SENDER_MAIN, SPARK);
+
+    // prison of yogg saron
+    if(pInstance->GetData(TYPE_VEZAX) == DONE)
+        pPlayer->ADD_GOSSIP_ITEM(0, "Teleport to the Prison of Yogg-Saron", GOSSIP_SENDER_MAIN, PRISON);
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, pGO->GetGUID());
+
+    return true;
+}
+
+bool GoSelect_ulduar_teleporter( Player *pPlayer, GameObject *pGO, uint32 sender, uint32 action)
+{
+    if(sender != GOSSIP_SENDER_MAIN) return true;
+    if(!pPlayer->getAttackers().empty()) return true;
+
+    ScriptedInstance *pInstance = (ScriptedInstance *) pGO->GetInstanceData();
+    if(!pInstance) return true;
+
+    switch(action)
+    {
+    case BASE_CAMP:
+        //pGO->CastSpell(pPlayer, SPELL_TELEPORT_BASE_CAMP, true);
+        pPlayer->TeleportTo(603, -706.122f, -92.6024f, 429.876f, 0);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case GROUNDS:
+        pPlayer->TeleportTo(603, 131.248f, -35.3802f, 409.804f, 0);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case FORGE:
+        pPlayer->TeleportTo(603, 553.233f, -12.3247f, 409.679f, 0);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case SCRAPYARD:
+        pPlayer->TeleportTo(603, 926.292f, -11.4635f, 418.595f, 0);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case ANTECHAMBER:
+        pPlayer->TeleportTo(603, 1498.09f, -24.246f, 420.967f, 0);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case WALKWAY:
+        pPlayer->TeleportTo(603, 1859.45f, -24.1f, 448.9f, 0); 
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case CONSERVATORY:
+        pPlayer->TeleportTo(603, 2086.27f, -24.3134f, 421.239f, 0);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case SPARK:
+        pPlayer->TeleportTo(603, 2536.87f, 2569.15f, 412.304f, 0);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    case PRISON:
+        pPlayer->TeleportTo(603, 1854.39f, -6.47f, 334.814f, 4.71f);
+        pPlayer->CLOSE_GOSSIP_MENU(); break;
+    }
+
+    return true;
+}
+
+void AddSC_ulduar()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "ulduar_teleporter";
+    newscript->pGOHello = &GoHello_ulduar_teleporter;
+    newscript->pGOGossipSelect = &GoSelect_ulduar_teleporter;
+    newscript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/ulduar/ulduar/ulduar.h b/scripts/northrend/ulduar/ulduar/ulduar.h
index 0524d55..650e641 100644
--- a/scripts/northrend/ulduar/ulduar/ulduar.h
+++ b/scripts/northrend/ulduar/ulduar/ulduar.h
@@ -1,4 +1,4 @@
-/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
 * This program is free software licensed under GPL version 2
 * Please see the included DOCS/LICENSE.TXT for more information */
 
@@ -24,26 +24,202 @@ enum
     TYPE_YOGGSARON              = 12,
     TYPE_ALGALON                = 13,
 
+    //other
+    TYPE_RUNE_GIANT             = 14,
+    TYPE_RUNIC_COLOSSUS         = 15,
+    TYPE_LEVIATHAN_MK           = 16,
+    TYPE_VX001                  = 17,
+    TYPE_AERIAL_UNIT            = 18,
+    TYPE_VISION1                = 19,
+    TYPE_VISION2                = 20,
+    TYPE_VISION3                = 21, 
+    TYPE_YOGG_BRAIN             = 22,
+
+    DATA_LEVIATHAN              = 14,
+    DATA_IGNIS                  = 15,
+    DATA_RAZORSCALE             = 16,
+    DATA_XT002                  = 17,
+    DATA_HEART                  = 50,
+    DATA_KOLOGARN               = 18,
+    DATA_AURIAYA                = 19,
     DATA_STEELBREAKER           = 20,
     DATA_MOLGEIM                = 21,
     DATA_BRUNDIR                = 22,
+    DATA_MIMIRON                = 23,
+    DATA_HODIR                  = 24,
+    DATA_THORIM                 = 25,
+    DATA_FREYA                  = 26,
+    DATA_VEZAX                  = 27,
+    DATA_YOGGSARON              = 28,
+    DATA_ALGALON                = 29,
+    DATA_RIGHT_ARM              = 30,
+    DATA_LEFT_ARM               = 31,
+    DATA_SENTRY_1				= 32,
+    DATA_SENTRY_2				= 33,
+    DATA_SENTRY_3				= 34,
+    DATA_SENTRY_4				= 35,
+    DATA_FERAL_DEFENDER			= 36,
+    DATA_BRIGHTLEAF             = 46,
+    DATA_IRONBRACH              = 47,
+    DATA_STONEBARK              = 48,
+    DATA_ANIMUS                 = 49,
+    DATA_RED_BUTTON             = 53,
+    DATA_RUNIC_COLOSSUS         = 51,
+    DATA_RUNE_GIANT             = 52,
+    DATA_LEVIATHAN_MK           = 54,
+    DATA_VX001                  = 55,
+    DATA_AERIAL_UNIT            = 56,
+    DATA_HODIR_IMAGE            = 57,
+    DATA_FREYA_IMAGE            = 58,
+    DATA_THORIM_IMAGE           = 59,
+    DATA_MIMIRON_IMAGE          = 60,
+    DATA_SARA                   = 61,
+    DATA_YOGG_BRAIN             = 62,
+    DATA_THORIM_LEVER           = 63,
+    DATA_MADNESS_DOOR           = 64,
+
+    TYPE_LEVIATHAN_HARD         = 37,
+    TYPE_XT002_HARD             = 38,
+    TYPE_ASSEMBLY_HARD          = 39,
+    TYPE_MIMIRON_HARD           = 40,
+    TYPE_HODIR_HARD             = 41,
+    TYPE_THORIM_HARD            = 42,
+    TYPE_FREYA_HARD             = 43,
+    TYPE_VEZAX_HARD             = 44,
+    TYPE_YOGGSARON_HARD         = 45,
+
+    // iron council
+    TYPE_BRUNDIR                = 46,
+    TYPE_MOLGEIM                = 47,
+    TYPE_STEELBREAKER           = 48,
+
+    TYPE_LEVIATHAN_TP,
+    TYPE_XT002_TP,
+    TYPE_MIMIRON_TP,
 
     NPC_LEVIATHAN               = 33113,
     NPC_IGNIS                   = 33118,
     NPC_RAZORSCALE              = 33186,
     NPC_XT002                   = 33293,
+    NPC_HEART				    = 33329,
     NPC_STEELBREAKER            = 32867,
     NPC_MOLGEIM                 = 32927,
     NPC_BRUNDIR                 = 32857,
     NPC_KOLOGARN                = 32930,
+    NPC_RIGHT_ARM               = 32934,
+    NPC_LEFT_ARM                = 32933,
     NPC_AURIAYA                 = 33515,
+    NPC_SANCTUM_SENTRY			= 34014,
+    NPC_FERAL_DEFENDER			= 34035,
     NPC_MIMIRON                 = 33350,
+    NPC_LEVIATHAN_MK            = 33432,
+    NPC_VX001                   = 33651,
+    NPC_AERIAL_UNIT             = 33670,
     NPC_HODIR                   = 32845,
     NPC_THORIM                  = 32865,
+    NPC_RUNIC_COLOSSUS          = 32872,
+    NPC_ANCIENT_RUNE_GIANT      = 32873,
     NPC_FREYA                   = 32906,
+    NPC_BRIGHTLEAF              = 32915,
+    NPC_IRONBRACH               = 32913,
+    NPC_STONEBARK               = 32914,
     NPC_VEZAX                   = 33271,
+    NPC_ANIMUS                  = 33524,
     NPC_YOGGSARON               = 33288,
-    NPC_ALGALON                 = 32871
+    NPC_ALGALON                 = 32871,
+    NPC_SARA                    = 33134,
+    NPC_YOGG_BRAIN              = 33890, 
+    // keepers images used to start the encounter
+    THORIM_IMAGE                = 33878,
+    MIMIRON_IMAGE               = 33880,
+    HODIR_IMAGE                 = 33879,
+    FREYA_IMAGE                 = 33876,
+
+    // loot chests
+    // Kologarn
+    GO_KOLOGARN_BRIDGE			= 194232,
+    GO_CACHE_OF_LIVING_STONE    = 195046,
+    GO_CACHE_OF_LIVING_STONE_H	= 195047,
+    // Hodir
+    GO_CACHE_OF_WINTER          = 194307,
+    GO_CACHE_OF_WINTER_H        = 194308, 
+    GO_CACHE_OF_RARE_WINTER     = 194200,
+    GO_CACHE_OF_RARE_WINTER_H   = 194201,
+    // Thorim
+    GO_CACHE_OF_STORMS          = 194312,
+    GO_CACHE_OF_RARE_STORMS     = 194313,
+    GO_CACHE_OF_STORMS_H        = 194314,
+    GO_CACHE_OF_RARE_STORMS_H   = 194315,
+    // Alagon
+    GO_GIFT_OF_OBSERVER_H       = 194821,
+    GO_GIFT_OF_OBSERVER         = 194822,
+    GO_GIFT_OF_OBSERVER_HH      = 194823,
+    // Freya
+    GO_FREYA_GIFT1              = 194324,//rare 25
+    GO_FREYA_GIFT2              = 194325,
+    GO_FREYA_GIFT               = 194326,//10
+    GO_FREYA_GIFT_RARE          = 194327,// rare 10
+    GO_FREYA_GIFT_RARE_H        = 194328,//25
+    GO_FREYA_GIFT5              = 194329,//25
+    GO_FREYA_GIFT6              = 194330,//25
+    GO_FREYA_GIFT_H             = 194331,//25
+    // Mimiron
+    GO_CACHE_OF_INOVATION       = 194789,
+    GO_CACHE_OF_INOVATION_H     = 194956,
+
+
+    // doors
+    // the siege
+    GO_SHIELD_WALL              = 194416,
+    GO_LEVIATHAN_GATE           = 194630,
+    GO_XT002_GATE               = 194631,
+    // archivum
+    GO_SHATTERED_DOOR           = 194553,
+    GO_IRON_ENTRANCE_DOOR       = 194554,
+    GO_ARCHIVUM_DOOR            = 194556,
+    GO_ARCHIVUM_CONSOLE         = 194555,
+    GO_CELESTIAL_ACCES          = 194628,
+    GO_CELESTIAL_DOOR           = 194767,
+    GO_UNIVERSE_FLOOR_ARCHIVUM  = 194715,
+    GO_UNIVERSE_FLOOR_CELESTIAL = 194716,
+    GO_AZEROTH_GLOBE            = 194148,
+    // the keepers
+    // hodir
+    GO_HODIR_EXIT               = 194634,
+    GO_HODIR_ICE_WALL           = 194441,
+    GO_HODIR_ENTER              = 194442,
+    // mimiron
+    G0_MIMIRON_BUTTON           = 194739,
+    GO_MIMIRON_DOOR_1           = 194774,
+    GO_MIMIRON_DOOR_2           = 194775,
+    GO_MIMIRON_DOOR_3           = 194776,
+    GO_MIMIRON_TEL1             = 194741,
+    GO_MIMIRON_TEL2             = 194742,
+    GO_MIMIRON_TEL3             = 194743,
+    GO_MIMIRON_TEL4             = 194744,
+    GO_MIMIRON_TEL5             = 194740,
+    GO_MIMIRON_TEL6             = 194746,
+    GO_MIMIRON_TEL7             = 194747,
+    GO_MIMIRON_TEL8             = 194748,
+    GO_MIMIRON_TEL9             = 194745,
+    GO_MIMIRON_ELEVATOR         = 194749,
+    // Thorim
+    GO_DARK_IRON_PORTCULIS      = 194560,
+    GO_RUNED_STONE_DOOR         = 194557,
+    GO_THORIM_STONE_DOOR        = 194558,
+    GO_LIGHTNING_DOOR           = 194905,
+    GO_LIGHTNING_FIELD          = 194559,
+    GO_DOOR_LEVER               = 194264,
+    //Yogg
+    GO_ANCIENT_GATE             = 194255,
+    GO_VEZAX_GATE               = 194750,
+    GO_YOGG_GATE                = 194773,
+    GO_BRAIN_DOOR1              = 194635,
+    GO_BRAIN_DOOR2              = 194636,
+    GO_BRAIN_DOOR3              = 194637,
+
+    ACHIEV_IRON_COUNCIL         = 2888,
+    ACHIEV_IRON_COUNCIL_H       = 2889,
 };
 
 #endif
diff --git a/sql/Custom_Updates/Mangos/Northrend/UlduarRaid_Mangos.sql b/sql/Custom_Updates/Mangos/Northrend/UlduarRaid_Mangos.sql
new file mode 100644
index 0000000..e3ea13a
--- /dev/null
+++ b/sql/Custom_Updates/Mangos/Northrend/UlduarRaid_Mangos.sql
@@ -0,0 +1,242 @@
+/* ULDUAR */
+
+-- Flame Leviathan
+UPDATE creature_template SET ScriptName = "boss_flame_leviathan" WHERE entry = 33113;
+UPDATE creature_template SET ScriptName = "mob_defense_turret" WHERE entry = 33142;
+
+-- Ignis
+UPDATE creature_template SET mechanic_immune_mask=617299803, scriptname='boss_ignis' WHERE entry=33118;
+UPDATE creature_template SET ScriptName = "mob_iron_construct" WHERE entry = 33121;
+UPDATE creature_template SET minlevel=80, maxlevel=80, faction_h=1925, faction_a=1925, scale=0.5, scriptname='mob_scorch_target' WHERE entry=33221;
+
+-- Razorscale
+UPDATE creature_template SET mechanic_immune_mask=617299803, scriptname='boss_razorscale' WHERE entry=33186;
+UPDATE creature_template SET ScriptName = "mob_dark_rune_watcher" WHERE entry = 33453;
+UPDATE creature_template SET ScriptName = "mob_dark_rune_sentinel" WHERE entry = 33846;
+UPDATE creature_template SET ScriptName = "mob_dark_rune_guardian" WHERE entry = 33388;
+UPDATE creature_template SET ScriptName = "npc_expedition_commander" WHERE entry = 33210;
+UPDATE creature_template SET ScriptName = "mob_devouring_flame_target" WHERE entry in (34189, 34188);
+
+-- XT002
+UPDATE creature_template SET mechanic_immune_mask=617299803, scriptname='boss_xt002' WHERE entry=33293;
+UPDATE creature_template SET ScriptName = "mob_pummeler" WHERE entry = 33344;
+UPDATE creature_template SET speed_run=0.5, faction_a=1925, faction_h=1925, scriptname='mob_boombot' WHERE entry=33346;
+UPDATE creature_template SET speed_run=0.5 WHERE entry=33343;
+UPDATE creature_template SET mechanic_immune_mask=652951551, scriptname='mob_xtheart' WHERE entry=33329;
+UPDATE creature_template SET ScriptName = "mob_voidzone" WHERE entry = 34001;
+UPDATE creature_template SET minhealth = 176400, maxhealth = 176400, minlevel = 80, maxlevel = 80, faction_a = 14, faction_h = 14, ScriptName = "mob_lifespark" WHERE entry = 34004;
+Update creature set spawnMask = 0 where id in (34004);
+
+-- Iron council
+UPDATE creature_template SET mechanic_immune_mask=619395071, scriptname='boss_brundir' WHERE entry=32857;
+UPDATE creature_template SET mechanic_immune_mask=617299803, scriptname='boss_molgeim' WHERE entry=32927;
+UPDATE creature_template SET mechanic_immune_mask=617299803, scriptname='boss_steelbreaker' WHERE entry=32867;
+UPDATE creature_template SET ScriptName = "mob_rune_of_power" WHERE entry = 33705;
+UPDATE creature_template SET ScriptName = "mob_rune_of_summoning" WHERE entry = 33051;
+UPDATE creature_template SET ScriptName = "mob_ulduar_lightning_elemental" WHERE entry = 32958;
+#UPDATE `creature_template` SET `mechanic_immune_mask` = 619397115 WHERE `entry` in (32857, 33694);
+UPDATE `creature_template` SET `mechanic_immune_mask` = 0 WHERE `entry` in (32857, 33694);
+
+-- Kologarn
+DELETE FROM creature WHERE id IN (32933, 32934);
+INSERT INTO creature (id, map, spawnMask, phaseMask, modelid, equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint, curhealth, curmana, DeathState, MovementType) VALUES (32933, 603, 3, 65535, 0, 0, 1799.68, -24.3599, 452.227, 3.14747, 604800, 0, 0, 543855, 0, 0, 0);
+INSERT INTO creature (id, map, spawnMask, phaseMask, modelid, equipment_id, position_x, position_y, position_z, orientation, spawntimesecs, spawndist, currentwaypoint, curhealth, curmana, DeathState, MovementType) VALUES (32934, 603, 3, 65535, 0, 0, 1799.68, -24.3599, 452.227, 3.14747, 604800, 0, 0, 543855, 0, 0, 0);
+UPDATE creature_model_info SET bounding_radius=15, combat_reach=15 WHERE modelid IN (28638, 28822, 28821);
+UPDATE creature_template SET mechanic_immune_mask=617299803, scriptname='boss_kologarn' WHERE entry=32930;
+UPDATE creature_template SET mechanic_immune_mask=652951551, scriptname='boss_right_arm' WHERE entry=32934;
+UPDATE creature_template SET mechanic_immune_mask=652951551, scriptname='boss_left_arm' WHERE entry=32933;
+UPDATE creature_template SET ScriptName = "mob_ulduar_rubble" WHERE entry in (33768, 33809, 33908, 33942);
+update `gameobject` set `position_y` = -35.6824, `position_x` = 1837.59 where `id` in (195047);
+
+-- Auriaya
+UPDATE creature_template SET mechanic_immune_mask=583745371, equipment_id = 103000, scriptname='boss_auriaya' WHERE entry=33515;
+UPDATE creature_template SET mechanic_immune_mask=619395071, scriptname='mob_feral_defender' WHERE entry=34035;
+UPDATE creature_template SET minlevel=80, maxlevel=80, faction_h=14, faction_a=14, scriptname='mob_seeping_feral_essence' WHERE entry=34098;
+UPDATE creature_template SET ScriptName = "mob_sanctum_sentry" WHERE entry = 34014;
+UPDATE `creature_template` SET `mechanic_immune_mask` = 619397115 WHERE `entry` in (33515, 34175);
+delete from creature_equip_template where entry = 103000;
+insert into creature_equip_template values (103000, 45315, 0, 0);
+DELETE FROM `creature_movement` WHERE `id`=94378;
+INSERT INTO `creature_movement` (`id`,`point`,`position_x`,`position_y`,`position_z`,`waittime`,`textid1`,`textid2`,`textid3`,`textid4`,`textid5`,`emote`,`spell`,`wpguid`,`orientation`,`model1`,`model2`) VALUES
+
+#(94378, 4, 1916.56, -69.9669, 417.718, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.2268, 0, 0),	-- after hodir up
+#(94378, 3, 1900.26, -24.0211, 417.722, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1.15909, 0, 0),	-- center kolgoran
+#(94378, 2, 1916.97, 21.1583, 417.748, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.86988, 0, 0),	-- before yogg up
+
+(94378, 1, 1925.012, 30.0067, 411.356, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.69685, 0, 0),	-- before yogg down
+(94378, 2, 1957.04, 49.3067, 411.355, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.37071, 0, 0),	-- after yogg down
+(94378, 3, 1967.38, 51.4931, 417.561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.09545, 0, 0),	-- after yogg up
+(94378, 4, 2013.07, 44.3788, 417.715, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5.71365, 0, 0), 	-- before mimiron up
+(94378, 5, 2021.35, 37.9771, 411.387, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5.25205, 0, 0), 	-- before mimiron down
+(94378, 6, 2046.36, 8.56725, 411.524, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5.203, 0, 0),		-- after mimiron down 
+(94378, 7, 2053.32, -7.1366, 421.78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.85107, 0, 0),		-- before freya up
+(94378, 8, 2052.87, -40.8556, 421.706, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.4223, 0, 0), 	-- after freya up
+(94378, 9, 2045.00, -56.79369, 411.359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.20538, 0, 0),	-- before thorim down
+(94378, 10, 2022.18, -86.5468, 411.355, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3.60096, 0, 0),	-- after thorim down
+(94378, 11, 2012.94, -92.7106, 417.717, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3.28968, 0, 0),	-- after thorim up
+(94378, 12, 1968.83, -101.0946, 417.722, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.662873, 0, 0),-- before hodir up
+(94378, 13, 1958.08, -96.7855, 411.864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.763719, 0, 0),	-- before hodir down
+(94378, 14, 1924.12, -78.5404, 411.488, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.210024, 0, 0),	-- after hodir down
+
+(94378, 15, 1958.08, -96.7855, 411.864, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.763719, 0, 0),	-- before hodir down
+(94378, 16, 1968.83, -101.0946, 417.722, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2.662873, 0, 0),-- before hodir up
+(94378, 17, 2012.94, -92.7106, 417.717, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3.28968, 0, 0),	-- after thorim up
+(94378, 18, 2022.18, -86.5468, 411.355, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3.60096, 0, 0),	-- after thorim down
+(94378, 19, 2045.00, -56.79369, 411.359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.20538, 0, 0),	-- before thorim down
+(94378, 20, 2052.87, -40.8556, 421.706, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.4223, 0, 0), 	-- after freya up
+(94378, 21, 2053.32, -7.1366, 421.78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4.85107, 0, 0),	-- before freya up
+(94378, 22, 2046.36, 8.56725, 411.524, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5.203, 0, 0),		-- after mimiron down
+(94378, 23, 2021.35, 37.9771, 411.387, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5.25205, 0, 0), 	-- before mimiron down
+(94378, 24, 2013.07, 44.3788, 417.715, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5.71365, 0, 0), 	-- before mimiron up
+(94378, 25, 1967.38, 51.4931, 417.561, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.09545, 0, 0),	-- after yogg up
+(94378, 26, 1957.04, 49.3067, 411.355, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.37071, 0, 0);	-- after yogg down
+
+-- Freya
+UPDATE creature_template SET ScriptName = "boss_freya" WHERE entry = 32906;
+UPDATE creature_template SET ScriptName = "boss_elder_brightleaf" WHERE entry = 32915;
+UPDATE creature_template SET ScriptName = "boss_elder_ironbranch" WHERE entry = 32913;
+UPDATE creature_template SET ScriptName = "boss_elder_stonebark" WHERE entry = 32914;
+UPDATE creature_template SET ScriptName = "mob_nature_bomb" WHERE entry = 34129;
+UPDATE creature_template SET ScriptName = "mob_iron_roots" WHERE entry in (33088, 33168);
+
+-- Hodir
+UPDATE creature_template SET ScriptName = "boss_hodir" WHERE entry = 32845;
+UPDATE creature_template SET ScriptName = "mob_snowdrift" WHERE entry = 33174;
+UPDATE creature_template SET ScriptName = "mob_flashFreeze" WHERE entry in (32926, 32938);
+Update creature set spawnMask = 0 where id in (32926, 32938);
+UPDATE creature_template SET ScriptName = "npc_hodir_priest" WHERE entry in (32897, 33326, 32948, 33330);
+UPDATE creature_template SET ScriptName = "npc_hodir_druid" WHERE entry in (33325, 32901, 32941, 33333);
+UPDATE creature_template SET ScriptName = "npc_hodir_shaman" WHERE entry in (33328, 32900, 33332, 32950);
+UPDATE creature_template SET ScriptName = "npc_hodir_mage" WHERE entry in (32893, 33327, 33331, 32946);
+
+-- Mimiron
+UPDATE creature_template SET unit_flags = 0, `AIName` = '', ScriptName = "boss_mimiron" WHERE entry = 33350;
+UPDATE creature_template SET `RegenHealth`= 0, ScriptName = "boss_leviathan_mk" WHERE entry = 33432;
+UPDATE creature_template SET ScriptName = "leviathan_turret" WHERE entry = 34071;
+UPDATE creature_template SET `RegenHealth`= 0, ScriptName = "boss_vx001" WHERE entry = 33651;
+UPDATE creature_template SET `RegenHealth`= 0, ScriptName = "boss_aerial_command_unit" WHERE entry = 33670;
+update creature set position_x = 2784.35, position_y = 2578.03, orientation = 3.2 where id = 33350;
+update creature set position_x = 2794.86, position_y = 2597.83, orientation = 3.57, spawnMask = 3 where id = 33432;
+UPDATE gameobject_template SET ScriptName="go_red_button" WHERE entry = 194739;
+UPDATE creature_template SET ScriptName = "mob_proximity_mine" WHERE entry = 34362;
+UPDATE creature_template SET ScriptName = "mob_bomb_bot" WHERE entry in (33836, 34192);
+UPDATE creature_template SET `faction_A` = 14, `faction_H` = 14, `minlevel` = 80, `maxlevel` = 80, ScriptName = "mob_emergency_bot" WHERE entry = 34147;
+UPDATE creature_template SET `faction_A` = 14, `faction_H` = 14, ScriptName = "mob_frost_bomb" WHERE entry = 34149;
+update `gameobject` set `position_x` = 2734.73 where `id` in (194789, 194956);
+
+-- Thorim
+UPDATE creature_template SET `unit_flags` = 0, ScriptName = "boss_thorim" WHERE entry = 32865;
+UPDATE creature_template SET ScriptName = "boss_runic_colossus" WHERE entry = 32872;
+UPDATE creature_template SET ScriptName = "boss_ancient_rune_giant" WHERE entry = 32873;
+update creature set spawnMask = 3 where id = 32873;
+UPDATE creature_template SET `faction_A` = 14, `faction_H` = 14, ScriptName = "npc_sif" WHERE entry = 33196;
+UPDATE creature_template SET `faction_A` = 14, `faction_H` = 14 WHERE entry = 33138;
+update `gameobject` set `position_y` = -286.67, `position_z` = 419.50 where `id` in (194312, 194313, 194314, 194315);
+UPDATE gameobject_template SET ScriptName="go_door_lever" WHERE entry = 194264;
+delete from gameobject where id = 194264; 
+insert into gameobject VALUES (110010,194264,603,3,65535,2173.276, -252.805, 420.146, 3.027,0,0,0,0,604800,0,1);
+update `creature` set `phaseMask` = 128 where `id` in (32907, 32883); 	-- horde soldiers: phase 128 for aly: 65535
+update `creature` set `phaseMask` = 64 where `id` in (32885, 32908);	-- alliance soldiers: phase 64 for horde
+-- reset pos to some creatures 
+update `creature` set `position_x` = 2222.69 where `guid` = 129413;
+update `creature` set `position_x` = 2222.69 where `guid` = 129412;
+update `creature` set `position_x` = 2227.34 where `guid` = 129856;
+update `creature` set `position_x` = 2227.34 where `guid` = 129857;
+
+update `creature` set `position_y` = -437.73 where `guid` = 129860;
+update `creature` set `position_y` = -437.73 where `guid` = 129861;
+update `creature` set `position_y` = -434.64 where `guid` = 129862;
+update `creature` set `position_y` = -434.64 where `guid` = 129863;
+update `creature` set `position_y` = -434.64 where `guid` = 129391;
+
+-- Vezax
+UPDATE creature_template SET unit_flags = 0, ScriptName = "boss_vezax" WHERE entry = 33271;
+UPDATE creature_template SET MinHealth = 23009250, MaxHealth = 23009250, ScriptName = "boss_vezax" WHERE entry = 33449;
+UPDATE `creature_template` SET `mechanic_immune_mask` = 619397115 WHERE `entry` in (33271, 33449);
+UPDATE creature_template SET ScriptName = "mob_saronite_animus" WHERE entry = 33524;
+UPDATE creature_template SET ScriptName = "mob_saronite_vapor", movementType = 1  WHERE entry = 33488;
+
+-- Yogg
+UPDATE creature_template SET ScriptName = "boss_yogg_saron" WHERE entry = 33288;
+update creature_template set `RegenHealth`= 0, `flags_extra` = 1,`type_flags` = 108, ScriptName = "boss_sara" where entry = 33134;
+update creature set spawnMask = 3, MovementType = 0 where id = 33134;
+update creature_template set `RegenHealth`= 0, ScriptName = "boss_brain_of_yogg_saron" where entry = 33890;
+update creature set `spawntimesecs` = 604800 where `id` = 33134;
+UPDATE creature_template SET ScriptName = "mob_corruptor_tentacle" WHERE entry = 33985;
+UPDATE creature_template SET ScriptName = "mob_constrictor_tentacle" WHERE entry = 33983;
+UPDATE creature_template SET MinHealth = 40000, MaxHealth = 40000, minLevel = 80, maxLevel = 80, ScriptName = "mob_vision_tentacle" WHERE entry = 33943;
+UPDATE creature_template SET MinHealth = 400000, MaxHealth = 400000, ScriptName = "mob_crusher_tentacle" WHERE entry = 33966;
+UPDATE creature_template SET MinHealth = 220000, MaxHealth = 220000, ScriptName = "mob_guardian_of_yogg_saron" WHERE entry = 33136;
+UPDATE creature_template SET ScriptName = "mob_immortal_guardian" WHERE entry = 33988;
+UPDATE creature_template SET `faction_A` = 14, `faction_H` = 14, ScriptName = "mob_death_orb" WHERE entry = 33882;
+UPDATE creature_template SET ScriptName = "mob_sanity_well" WHERE entry = 33991;
+UPDATE creature_template SET scriptname='mob_madness_portal' WHERE `entry`=34072;
+-- Keepers
+UPDATE creature_template SET ScriptName = "keeper_hodir" WHERE entry = 33411;
+UPDATE creature_template SET ScriptName = "keeper_freya" WHERE entry = 33410;
+UPDATE creature_template SET ScriptName = "keeper_thorim" WHERE entry = 33413;
+UPDATE creature_template SET ScriptName = "keeper_mimiron" WHERE entry = 33412;
+-- Keepers images
+UPDATE creature_template SET ScriptName = "hodir_image" WHERE entry = 33879;
+UPDATE creature_template SET ScriptName = "freya_image" WHERE entry = 33876;
+UPDATE creature_template SET ScriptName = "thorim_image" WHERE entry = 33878;
+UPDATE creature_template SET ScriptName = "mimiron_image" WHERE entry = 33880;
+-- insert the brain and keepers imagees into the db
+delete from creature where id in (33890, 33876, 33880, 33879, 33878);
+insert into creature VALUES (800000,33890,603,3,65535,0,0,1981.422,-22.442,255.011,0,604800,0,0,1371428,0,0,0),	-- Brain
+(800001, 33876, 603, 3, 65535,0,0, 1888.782, -3.919, 333.446, 5.91, 604800,0,0, 5647, 0, 0, 0),		-- Freya 
+(800002, 33880, 603, 3, 65535,0,0, 1891.667, 3.103, 333.051, 5.82, 604800,0,0, 5647, 0, 0, 0),		-- Mimiron
+(800003, 33879, 603, 3, 65535,0,0, 1888.782, -45.434, 333.434, 0.26, 604800,0,0, 5647, 0, 0, 0), 	-- Hodir
+(800004, 33878, 603, 3, 65535,0,0, 1891.667, -53.316, 333.031, 0.38, 604800,0,0, 5647, 0, 0, 0); 	-- Thorim
+-- insert doors & portals into the brain room
+delete from gameobject where id in (194635);
+insert into gameobject VALUES (110000,194635,603,3,65535,2022.490,-25.389,261.961,0,0,0,0,0,604800,0,1);
+delete from gameobject where guid = 110001;
+insert into gameobject VALUES (110001,194462,603,3,65535,2104.555, -25.635,242.646,0,0,0,0,0,604800,100,1);
+delete from areatrigger_teleport where id = 10000;
+delete from gameobject_template where entry = 500000;
+#insert into gameobject VALUES (110002,500000,603,3,65535,1999.690, -54.931, 242.418,0,0,0,0,0,604800,100,1);
+#insert into gameobject VALUES (110003,500000,603,3,65535,1946.898, -25.769, 242.169,0,0,0,0,0,604800,100,1);
+
+
+-- Algalon
+UPDATE creature_template SET ScriptName = "boss_algalon" WHERE entry = 32871;
+UPDATE creature_template SET ScriptName = "mob_collapsing_star" WHERE entry = 32955;
+UPDATE creature_template SET ScriptName = "mob_living_constellation" WHERE entry = 33052;
+UPDATE creature_template SET ScriptName = "mob_black_hole" WHERE entry = 32953;
+update creature_template set minhealth = 39099, maxhealth = 39099 where entry = 33089;
+
+-- Teleporter
+UPDATE gameobject_template SET ScriptName="ulduar_teleporter" WHERE entry = 194569;
+-- Destination Locations for Ulduar Teleporter spells
+REPLACE INTO spell_target_position VALUES
+(64014, 603, -706.122, -92.6024, 429.876, 0),      /* Expedition Base Camp */
+(64032, 603, 131.248, -35.3802, 409.804, 0),       /* Formation Grounds */
+(64028, 603, 553.233, -12.3247, 409.679, 0),       /* Colossal Forge */
+(64031, 603, 926.292, -11.4635, 418.595, 3.14159), /* Scrapyard */
+(64030, 603, 1498.09, -24.246, 420.967, 0),        /* Antechamber of Ulduar */
+(64029, 603, 1859.45, -24.1, 448.9, 0),            /* Shattered Walkway */
+(64024, 603, 2086.27, -24.3134, 421.239, 0),       /* Conservatory of Life */
+(65061, 603, 2517.31, 2568.87, 412.299, 0),        /* Spark of Imagination */
+(65042, 603, 1854.73, -11.637, 334.575, 0);        /* Prison of Yogg-Saron */
+
+-- Doors 
+UPDATE gameobject_template SET faction = 114 WHERE entry in (194553, 194554, 194556, 194555, 194148, 194634, 194635, 194905, 194441,
+194442, 194416, 194774, 194775, 194776, 194560, 194557, 194558, 194750, 194910, 194559, 194635, 194636, 194637);
+UPDATE gameobject_template SET faction = 0 WHERE entry in (194255, 194630, 194631);
+-- Doors from the siege && descent into madness: to be added later
+#UPDATE gameobject_template SET faction = 114 WHERE entry in (194255, 194630, 194631);
+
+-- loot chests
+UPDATE gameobject_template SET faction = 0 WHERE entry in (195046, 195047, 194307, 194308, 194200, 194201, 194312, 194313, 194314, 194315, 194821,
+194822, 194823, 194324, 194325, 194326, 194327, 194328, 194329, 194330, 194331, 194789, 194956);
+update gameobject set spawntimesecs = -604800 where id in (195046, 195047, 194307, 194308, 194200, 194201, 194312, 194313, 194314, 194315, 194821,
+194822, 194823, 194324, 194325, 194326, 194327, 194328, 194329, 194330, 194331, 194789, 194956);
+
+-- Iron council loot -->> event fixed. Loot ids removed; Only steelbreaker has loot
+update `creature_template` set `lootid` = 0 where `entry` in (32927, 32857);
+
+-- Mobs
+UPDATE creature_template SET ScriptName = "generic_creature" WHERE entry in (34086, 34085, 34069, 33237, 34234, 33236, 33264, 34164, 34196, 34199, 34198, 
+34190, 34197, 33699, 34134, 34135, 34133, 33430, 33528, 33431, 33527, 33526, 33525, 33355, 33354, 34193, 34183, 32908, 32885, 32907, 32883, 33125, 33110, 32874, 
+32877, 32878, 32904, 32876, 33110, 33822, 33818, 33824, 33823, 33772, 33838, 33819, 33820, 32882, 32875, 33346, 34057, 33228, 32918, 33202, 32919, 32916, 33203);
diff --git a/sql/Custom_Updates/ScriptDev2/Northrend/UlduarRaid_Script.sql b/sql/Custom_Updates/ScriptDev2/Northrend/UlduarRaid_Script.sql
new file mode 100644
index 0000000..1e130e9
--- /dev/null
+++ b/sql/Custom_Updates/ScriptDev2/Northrend/UlduarRaid_Script.sql
@@ -0,0 +1,262 @@
+/* ULDUAR */
+delete from `script_texts` where `entry` between -1603500 and -1603000;
+INSERT INTO `script_texts` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`, `sound`, `type`, `language`, `emote`, `comment`) VALUES 
+-- Leviathan: needs intro & outro
+(-1603201,"Threat assessment routine modified. Current target threat level: zero. Acquiring new target.","","","","","","","","",15521,1,0,0,"Flame Leviathan Slay"),
+(-1603202,"Total systems failure. Defense protocols breached. Leviathan Unit shutting down.","","","","","","","","",15520,1,0,0,"Flame Leviathan Death"),
+(-1603203,"Hostile entities detected. Threat assessment protocol active. Primary target engaged. Time minus thirty seconds to re-evaluation.","","","","","","","","",15506,1,0,0,"Flame Leviathan Aggro"),
+(-1603204,"Threat re-evaluated. Target assessment complete. Changing course.","","","","","","","","",15507,1,0,0,"Flame Leviathan change1"),
+(-1603205,"Pursuit objective modified. Changing course.","","","","","","","","",15508,1,0,0,"Flame Leviathan change2"),
+(-1603206,"Hostile entity stratagem predicted. Rerouting battle function. Changing course.","","","","","","","","",15509,1,0,0,"Flame Leviathan change3"),
+(-1603207,"Unauthorized entity attempting circuit overload. Activating anti-personnel countermeasures.","","","","","","","","",15516,1,0,0,"Flame Leviathan player on top"),
+(-1603208,"System malfunction. Diverting power to support systems.","","","","","","","","",15517,1,0,0,"Flame Leviathan overload1"),
+(-1603209,"Combat matrix overload. Powering do-o-o-own...","","","","","","","","",15518,1,0,0,"Flame Leviathan overload2"),
+(-1603210,"System restart required. Deactivating weapon systems.","","","","","","","","",15519,1,0,0,"Flame Leviathan overload3"),
+(-1603211,"Orbital countermeasures enabled.","","","","","","","","",15510,1,0,0,"Flame Leviathan hard mode"),
+(-1603212,"Alert! Static defense system failure. Orbital countermeasures disabled.","","","","","","","","",15511,1,0,0,"Flame Leviathan towers down"),
+(-1603213,"'Hodir's Fury' online. Acquiring target.","","","","","","","","",15512,1,0,0,"Flame Leviathan frost"),
+(-1603214,"'Mimiron's Inferno' online. Acquiring target.","","","","","","","","",15513,1,0,0,"Flame Leviathan fire"),
+(-1603215,"'Thorim's Hammer' online. Acquiring target.","","","","","","","","",15515,1,0,0,"Flame Leviathan energy"),
+(-1603216,"'Freya's Ward' online. Acquiring target.","","","","","","","","",15514,1,0,0,"Flame Leviathan nature"),
+
+-- Ignis:
+(-1603010, "Insolent whelps! Your blood will temper the weapons used to reclaim this world!", "","","","","","","","",15564, 1, 0, 0, 'IgnisAggro'),
+(-1603011, "Let the inferno consume you!", "","","","","","","","",15567, 1, 0, 0, 'Ignis Scorch1'),
+(-1603012, "BURN! Burn in the makers fire!", "","","","","","","","",15568, 1, 0, 0, 'Ignis scroch2'),
+(-1603013, "I will burn away your impurities!", "","","","","","","","",15566, 1, 0, 0, 'Ignis Slagpot'),
+(-1603014, 'Ignis the Furnace Master begins to cast Flame Jets!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,3,0,0,'EMOTE_FLAME_JETS'),
+(-1603015, "Arise, soldiers of the Iron Crucible! The Makers\' will be done!", "","","","","","","","",15565, 1, 0, 0, 'Ignis summon'),
+(-1603016, "More scraps for the scrapheap!", "","","","","","","","",15569, 1, 0, 0, 'IgnisSlay1'),
+(-1603017, "Your bones will serve as kindling!", "","","","","","","","",15570, 1, 0, 0, 'IgnisSlay2'),
+(-1603018, "Let it be finished!", "","","","","","","","",15571, 1, 0, 0, 'IgnisBerserk'),
+(-1603019, "I. Have. Failed.", "","","","","","","","",15572, 1, 0, 0, 'Ignis death'),
+
+-- razorscale
+(-1603020,'Welcome, champions! All of our attempts at grounding her have failed. We could use a hand in bring her down with these harpoon guns.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15647,'1',NULL,NULL,'razorscale intro - commander'),
+(-1603021,'Give us a moment to prepare to build the turrets.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15543,'1',NULL,NULL,'razor aggro 1 - eng'),
+(-1603022,'Be on the lookout! Mole machines will be surfacing soon with those nasty Iron dwarves aboard!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15544,'1',NULL,NULL,'razor aggro 2 - commander'),
+(-1603023,'Ready to move out, keep those dwarves off of our backs!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15545,'1',NULL,NULL,'razor aggro 3 - eng'),
+(-1603024,'Move! Quickly! She wont remain grounded for long.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15648,'1',NULL,NULL,'razor ground - commander'),
+(-1603025,'Razorscale takes a deep breath...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15547,'1',NULL,NULL,'razor deep breath'),
+(-1603026,'Fires out! Let\'s rebuild those turrets!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15548,'1',NULL,NULL,'razor extinguish fires'),
+
+-- Xt002
+(-1603030,"You are bad... Toys... Very... Baaaaad!","","","","","","","","",15731,1,0,0,"XT-002 Death"),
+(-1603031,"I'm tired of these toys. I don't want to play anymore!","","","","","","","","",15730,1,0,0,"XT-002 Berserk"),
+(-1603032,"Time for a new game! My old toys will fight my new toys!","","","","","","","","",15732,1,0,0,"XT-002 Adds"),
+(-1603033,"I'm ready to play!","","","","","","","","",15726,1,0,0,"XT-002 Heart Closed"),
+(-1603034,"So tired. I will rest for just a moment!","","","","","","","","",15725,1,0,0,"XT-002 Heart Opened"),
+(-1603035,"I guess it doesn't bend that way.","","","","","","","","",15729,1,0,0,"XT-002 Slay 2"),
+(-1603036,"I... I think I broke it.","","","","","","","","",15728,1,0,0,"XT-002 Slay 1"),
+(-1603037,"NO! NO! NO! NO! NO!","","","","","","","","",15727,1,0,0,"XT-002 Tympanic Tantrum"),
+(-1603038,"New toys? For me? I promise I won't break them this time!","","","","","","","","",15724,1,0,0,"XT-002 Aggro"),
+
+-- Iron Council
+-- Molgeim
+(-1603040,"Nothing short of total decimation will suffice!","","","","","","","","",15657,1,0,0,"MolgeimAggro"),
+(-1603041, "The legacy of storms shall not be undone...", "","","","","","","","",15662, 1, 0, 0, "MolgeimDeath1"),
+(-1603042, "What have you gained from my defeat? You are no less doomed, mortals...", "","","","","","","","",15663, 1, 0, 0, 'MolgeimDeath2'),
+(-1603043, "Decipher this!", "","","","","","","","",15660, 1, 0, 0, 'MolgeimDeathRune'),
+(-1603044, "Face the lightning surge!", "","","","","","","","",15661, 1, 0, 0, 'MolgeimSummon'),
+(-1603045, "The world on suffers yet another insignificant loss!", "","","","","","","","",15658, 1, 0, 0, 'MolgeimSlay1'),
+(-1603046, "Death is the price of your arrogance.", "","","","","","","","",15659, 1, 0, 0, 'MolgeimSlay2'),
+(-1603047, "This meeting of the Assembly of Iron is adjourned!", "","","","","","","","",15664, 1, 0, 0, 'MolgeimBerserk'),
+-- Steelbreaker
+(-1603050, "You will not defeat the Assembly of Iron so easily, invaders!", "","","","","","","","",15674, 1, 0, 0, 'SteelAggro'),
+(-1603051, "My death only serves to hasten your demise.", "","","","","","","","",15678, 1, 0, 0, 'SteelDeath1'),
+(-1603052, "Impossible!", "","","","","","","","",15679, 1, 0, 0, 'SteelDeath2'),
+(-1603053, "So fragile and weak!", "","","","","","","","",15675, 1, 0, 0, 'SteelSlay1'),
+(-1603054, "Flesh... such a hindrance.", "","","","","","","","",15676, 1, 0, 0, 'SteelSlay2'),
+(-1603055, "You seek the secrets of Ulduar? Then take them!", "","","","","","","","",15677, 1, 0, 0, 'SteelOverwhelming'),
+(-1603056, "This meeting of the Assembly of Iron is adjourned!", "","","","","","","","",15680, 1, 0, 0, 'SteelBerserk'),
+-- Brudir
+(-1603060, "Whether the world\'s greatest gnats or the world\'s greatest heroes, you\'re still only mortal.", "","","","","","","","",15684, 1, 0, 0, 'BrundirAggro'),
+(-1603061, "Stormcaller Brundir begins to Overload!", "","","","","","","","",0, 3, 0, 0, 'Brundir Overload'),
+(-1603062, "Stand still and stare into the light!", "","","","","","","","",15687, 1, 0, 0, 'BrundirWhirl'),
+(-1603063, "The power of the storm lives on...", "","","","","","","","",15689, 1, 0, 0, 'BrundirDeath1'),
+(-1603064, "You rush headlong into the maw of madness!", "","","","","","","","",15690, 1, 0, 0, 'BrundirDeath2'),
+(-1603065, "A merciful kill!", "","","","","","","","",15685, 1, 0, 0, 'BrundirSlay1'),
+(-1603066, "HAH!", "","","","","","","","",15686, 1, 0, 0, 'BrundirSlay2'),
+(-1603067, "This meeting of the Assembly of Iron is adjourned!", "","","","","","","","",15691, 1, 0, 0, 'BrundirBerserk'),
+(-1603068, "Let the storm clouds rise and rain down death from above!", "","","","","","","","",15688, 1, 0, 0, 'BrundirFly'),
+
+-- Kologarn:
+(-1603150, "None shall pass!", "","","","","","","","",15586, 1, 0, 0, 'KologarnAggro'),
+(-1603151, "OBLIVION!", "","","","","","","","",15591, 1, 0, 0, 'Kologarn shockweave'),
+(-1603152, "I will squeeze the life from you!", "","","","","","","","",15592, 1, 0, 0, 'Kologarn grab'),
+(-1603153, "Just a scratch!", "","","","","","","","",15589, 1, 0, 0, 'left arm lost'),
+(-1603154, "Only a flesh wound!", "","","","","","","","",15590, 1, 0, 0, 'right arm lost'),
+(-1603155, "KOL-THARISH!", "","","","","","","","",15587, 1, 0, 0, 'KologarnSlay1'),
+(-1603156, "YOU FAIL!", "","","","","","","","",15588, 1, 0, 0, 'KologarnSlay2'),
+(-1603157, "I am invincible!", "","","","","","","","",15594, 1, 0, 0, 'KologarnBerserk'),
+(-1603158, "Master, they come...", "","","","","","","","",15593, 1, 0, 0, 'Kologarndeath'),
+
+-- Auriaya:
+(-1603070,"Some things are better left alone!","","","","","","","","",15473,1,0,0,"auriaya aggro"),
+(-1603071,"The secret dies with you!","","","","","","","","",15474,1,0,0,"auriaya Slay 2"),
+(-1603072,"There is no escape!","","","","","","","","",15475,1,0,0,"auriaya Slay 1"),
+(-1603073,"You waste my time!","","","","","","","","",15477,1,0,0,"auriaya berserk"),
+(-1603074,"Auriaya screams in agony.","","","","","","","","",15476,2,0,0,"auriaya death"),
+
+-- Hodir
+(-1603080,"<Furious Roar>","","","","","","","","",15556,2,0,0,"Hodir Frozen Blows"),
+(-1603081,"Winds of the north consume you!","","","","","","","","",15555,1,0,0,"Hodir Flash Freeze"),
+(-1603082,"Welcome to the endless winter.","","","","","","","","",15554,1,0,0,"Hodir Slay 2"),
+(-1603083,"Tragic. To come so far, only to fail.","","","","","","","","",15553,1,0,0,"Hodir Slay 1"),
+(-1603084,"I... I am released from his grasp... at last.","","","","","","","","",15557,1,0,0,"Hodir Death"),
+(-1603085,"You will suffer for this trespass!","","","","","","","","",15552,1,0,0,"Hodir Aggro"),
+(-1603086,"The veil of winter will protect you, champions!","","","","","","","","",15559,1,0,0,"Hodir yogg"),
+(-1603087,"Enough! This ends now!","","","","","","","","",15558,1,0,0,"Hodir berserk"),
+
+-- Freya: 
+(-1603000,"The Conservatory must be protected!","","","","","","","","",15526,1,0,0,"freya aggro"),
+(-1603001,"Elders, grant me your strength!","","","","","","","","",15527,1,0,0,"freya aggro hard"),
+(-1603002,"Eonar, your servant requires aid!","","","","","","","","",15528,1,0,0,"summon conservator"),
+(-1603003,"Children, assist me!","","","","","","","","",15533,1,0,0,"summon trio"),
+(-1603004,"The swarm of the elements shall overtake you!","","","","","","","","",15534,1,0,0,"summon lashers"),
+(-1603005,"Forgive me.","","","","","","","","",15529,1,0,0,"freya slay1"),
+(-1603006,"From your death springs life anew!","","","","","","","","",15530,1,0,0,"freya slay2"),
+(-1603007,"His hold on me dissipates. I can see clearly once more. Thank you, heroes.","","","","","","","","",15531,1,0,0,"freya Death"),
+(-1603008,"You have strayed too far, wasted too much time!","","","","","","","","",15532,1,0,0,"freya berserk"),
+(-1603009,"Eonar, your servant calls for your blessing!","","","","","","","","",15535,1,0,0,"freya yogg"),
+-- Brightleaf
+(-1603160,"Matron, the Conservatory has been breached!","","","","","","","","",15483,1,0,0,"brightleaf aggro"),
+(-1603161,"Fertilizer.","","","","","","","","",15485,1,0,0,"brightleaf slay1"),
+(-1603162,"Your corpse will nourish the soil!","","","","","","","","",15486,1,0,0,"brightleaf slay2"),
+(-1603163,"Matron, one has fallen!","","","","","","","","",15487,1,0,0,"brightleaf dead"),
+-- Ironbranch
+(-1603170,"Mortals have no place here!","","","","","","","","",15493,1,0,0,"ironbranch aggro"),
+(-1603171,"I return you whence you came!","","","","","","","","",15494,1,0,0,"ironbranch slay1"),
+(-1603172,"BEGONE!","","","","","","","","",15495,1,0,0,"ironbranch slay2"),
+(-1603173,"Freya! They come for you.","","","","","","","","",15496,1,0,0,"summon trio"),
+-- Stonebark
+(-1603180,"This place will serve as your graveyard.","","","","","","","","",15500,1,0,0,"stonebark aggro"),
+(-1603181,"<Angry roar>","","","","","","","","",15501,1,0,0,"stonebark slay1"),
+(-1603182,"Such a waste.","","","","","","","","",15502,1,0,0,"stonebark slay2"),
+(-1603183,"Matron, flee! They are ruthless....","","","","","","","","",15503,1,0,0,"stonebark death"),
+
+-- Thorim:
+(-1603221,"Interlopers! You mortals who dare to interfere with my sport will pay... Wait--you...","","","","","","","","",15733,1,0,0,"thorim aggro 1"),
+(-1603222,"I remember you... In the mountains... But you... what is this? Where am--","","","","","","","","",15734,1,0,0,"thorim aggro 2"),
+(-1603223,"Behold the power of the storms and despair!","","","","","","","","",15735,1,0,0,"thorim special 1"),
+(-1603224,"Do not hold back! Destroy them!","","","","","","","","",15736,1,0,0,"thorim special 2"),
+(-1603225,"Have you begun to regret your intrusion?","","","","","","","","",15737,1,0,0,"thorim special 3"),
+(-1603226,"Impertinent whelps! You dare challenge me atop my pedestal! I will crush you myself!","","","","","","","","",15738,1,0,0,"thorim jump"),
+(-1603227,"Can't you at least put up a fight!?","","","","","","","","",15739,1,0,0,"thorim slay1"),
+(-1603228,"Pathetic!","","","","","","","","",15740,1,0,0,"thorim slay2"),
+(-1603229,"My patience has reached its limit!","","","","","","","","",15741,1,0,0,"Thorim berserk"),
+(-1603230,"Failures! Weaklings!","","","","","","","","",15742,1,0,0,"thorim arena wipe"),
+(-1603231,"Stay your arms! I yield!","","","","","","","","",15743,1,0,0,"thorim defeat"),
+(-1603232,"I feel as though I am awakening from a nightmare, but the shadows in this place yet linger.","","","","","","","","",15744,1,0,0,"thorim outro n1"),
+(-1603233,"Sif... was Sif here? Impossible--she died by my brother's hand. A dark nightmare indeed....","","","","","","","","",15745,1,0,0,"thorim outro n2"),
+(-1603234,"I need time to reflect.... I will aid your cause if you should require it. I owe you at least that much. Farewell.","","","","","","","","",15746,1,0,0,"thorim outro n3"),
+(-1603235,"You! Fiend! You are not my beloved! Be gone!","","","","","","","","",15747,1,0,0,"thorim outro hard1"),
+(-1603236,"Behold the hand behind all the evil that has befallen Ulduar! Left my kingdom in ruins, corrupted my brother and slain my wife!","","","","","","","","",15748,1,0,0,"thorim outro hard2"),
+(-1603237,"And now it falls to you, champions, to avenge us all! The task before you is great, but I will lend you my aid as I am able. You must prevail!","","","","","","","","",15749,1,0,0,"thorim outro hard3"),
+(-1603238,"Golganneth, lend me your strengh! Grant my mortal allies the power of thunder!","","","","","","","","",15750,1,0,0,"thorim yogg"),
+-- Sif:
+(-1603185,"Thorim, my lord, why else would these invaders have come into your sanctum but to slay you? They must be stopped!","","","","","","","","",15668,1,0,0,"sif start"),
+(-1603186,"Impossible! Lord Thorim, I will bring your foes a frigid death!","","","","","","","","",15670,1,0,0,"sif event"),
+(-1603187,"These pathetic mortals are harmless, beneath my station. Dispose of them!","","","","","","","","",15669,1,0,0,"sif despawn"),
+
+-- Mimiron:
+(-1603241,"Oh, my! I wasn't expecting company! The workshop is such a mess! How embarrassing!","","","","","","","","",15611,1,0,0,"mimiron aggro"), 
+(-1603242,"Now why would you go and do something like that? Didn't you see the sign that said 'DO NOT PUSH THIS BUTTON!'? How will we finish testing with the self-destruct mechanism active?","","","","","","","","",15629,1,0,0,"mimiron hard mode"),
+(-1603243,"Oh, my! It would seem that we are out of time, my friends!","","","","","","","","",15628,1,0,0,"mimiron berserk"),
+(-1603244,"We haven't much time, friends! You're going to help me test out my latest and greatest creation. Now, before you change your minds, remember, that you kind of owe it to me after the mess you made with the XT-002.","","","","","","","","",15612,1,0,0,"tank active"),
+(-1603245,"MEDIC!","","","","","","","","",15613,1,0,0,"tank kill1"),
+(-1603246,"I can fix that... or, maybe not! Sheesh, what a mess...","","","","","","","","",15614,1,0,0,"tank kill2"),
+(-1603247,"WONDERFUL! Positively marvelous results! Hull integrity at 98.9 percent! Barely a dent! Moving right along.","","","","","","","","",15615,1,0,0,"tank dead"),
+(-1603248,"Behold the VX-001 Anti-personnel Assault Cannon! You might want to take cover.","","","","","","","","",15616,1,0,0,"torso active"),
+(-1603249,"Fascinating. I think they call that a 'clean kill'.","","","","","","","","",15617,1,0,0,"torso kill1"),
+(-1603250,"Note to self: Cannon highly effective against flesh.","","","","","","","","",15618,1,0,0,"torso kill2"),
+(-1603251,"Thank you, friends! Your efforts have yielded some fantastic data! Now, where did I put-- oh, there it is!","","","","","","","","",15619,1,0,0,"torso dead"),
+(-1603252,"Isn't it beautiful? I call it the magnificent aerial command unit!","","","","","","","","",15620,1,0,0,"head active"),
+(-1603253,"Outplayed!","","","","","","","","",15621,1,0,0,"head kill1"),
+(-1603254,"You can do better than that!","","","","","","","","",15622,1,0,0,"head kill2"),
+(-1603255,"Preliminary testing phase complete. Now comes the true test!!","","","","","","","","",15623,1,0,0,"head defeat"),
+(-1603256,"Gaze upon its magnificence! Bask in its glorious, um, glory! I present you... V-07-TR-0N!","","","","","","","","",15624,1,0,0,"robot active"),
+(-1603257,"Prognosis: Negative!","","","","","","","","",15625,1,0,0,"robot kill1"),
+(-1603258,"You're not going to get up from that one, friend.","","","","","","","","",15626,1,0,0,"robot kill2"),	
+(-1603259,"It would appear that I've made a slight miscalculation. I allowed my mind to be corrupted by the fiend in the prison, overriding my primary directive. All systems seem to be functional now. Clear.","","","","","","","","",15627,1,0,0,"robot defeat"),
+(-1603260,"Combat matrix enhanced. Behold wonderous rapidity!","","","","","","","","",15630,1,0,0,"mimiron yogg"),
+
+-- vezax
+(-1603120,'Your destruction will herald a new age of suffering!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15542,'1',NULL,NULL,'vezax aggro'),
+(-1603121,'You thought to stand before the legions of death... and survive?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15543,'1',NULL,NULL,'vezax kill1'),
+(-1603122,'Defiance... a flaw of mortality.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15544,'1',NULL,NULL,'vezax kill2'),
+(-1603123,'The black blood of Yogg-Saron courses through me! I. AM. UNSTOPPABLE!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15545,'1',NULL,NULL,'vezaz surge'),
+(-1603124,'Oh, what horrors await....',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15546,'1',NULL,NULL,'vezax death'),
+(-1603125,'Your defeat was inevitable!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15547,'1',NULL,NULL,'vezax enrage'),
+(-1603126,'Behold, now! Terror, absolute!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15548,'1',NULL,NULL,'vezax hard'),
+
+-- Yogg:
+-- Sara:
+(-1603300,'The time to strike at the head of the beast will soon be upon us! Focus your anger and hatred on his minions!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15775,'1',NULL,NULL,'sara aggro'),
+(-1603301,'Yes! YES! Show them no mercy! Give no pause to your attacks!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15773,'1',NULL,NULL,'sara help1'),
+(-1603302,'Let hatred and rage guide your blows!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15774,'1',NULL,NULL,'sara help2'),
+(-1603303,'Could they have been saved?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15779,'1',NULL,NULL,'sara kill1'),
+(-1603304,'Powerless to act...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15778,'1',NULL,NULL,'sara kill 2'),
+(-1603305,'Tremble, mortals, before the coming of the end!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15777,'1',NULL,NULL,'sara yell1 p2'),
+(-1603306,'Suffocate upon your own hate!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15776,'1',NULL,NULL,'sara yell2 p2'),
+(-1603307,'Aaaaaaaaaaaaaaaaa... Help me!!! Please got to help me!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15771,'1',NULL,NULL,'sara prefight'),
+(-1603308,'What do you want from me? Leave me alone!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15772,'1',NULL,NULL,'sara prefight2'),
+(-1603309,'Weak-minded fools!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15780,'4',NULL,NULL,'sara slay phase1'),
+
+-- Yogg:
+(-1603321,'I am the lucid dream. The monster in your nightmares. The fiend of a thousand faces. Cower before my true form. BOW DOWN BEFORE THE GOD OF DEATH!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15754,'1',NULL,NULL,'yogg p2 intro'),
+(-1603322,'MADNESS WILL CONSUME YOU!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15756,'1',NULL,NULL,'yogg vision'),
+(-1603323,'Look upon the true face of death and know that your end comes soon!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15755,'1',NULL,NULL,'yogg phase 3'),
+(-1603324,'Hoohehehahahaha... AHAHAHAHAHAHA!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15757,'1',NULL,NULL,'yogg slay1'),
+(-1603325,'Eternal suffering awaits!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15758,'1',NULL,NULL,'yogg slay2'),
+(-1603326,'Your fate is sealed. The end of days is finally upon you and ALL who inhabit this miserable little seedling. Uulwi ifis halahs gag erh\'ongg w\'ssh.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15761,'1',NULL,NULL,'yogg death'),
+(-1603327,'Your will is no longer you own...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15759,'4',NULL,NULL,'yogg insanity1'),
+(-1603328,'Destroy them minion, your master commands it!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15760,'4',NULL,NULL,'yogg insanity2'),
+-- Visions:
+-- lich king v3
+(-1603330,'Your resilience is admirable.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15598,'0',NULL,NULL,'v1 lich king1'),
+(-1603331,'Arrrrrrgh!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15470,'1',NULL,NULL,'v1 champ1'),
+(-1603332,'I\'m not afraid of you!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15471,'0',NULL,NULL,'v1 champ2'),
+(-1603333,'I will break you as I broke him.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15599,'0',NULL,NULL,'v1 lich king2'),
+(-1603334,'Yrr n\'lyeth... shuul anagg!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15766,'0',NULL,NULL,'v1 yogg1'),
+(-1603335,'He will learn... no king rules forever; only death is eternal!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15767,'0',NULL,NULL,'v1 yogg2'),
+-- dragons v2
+(-1603336,'It is done... All have been given that which must be given. I now seal the Dragon Soul forever...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15631,'0',NULL,NULL,'v2 neltharion1'),
+(-1603337,'That terrible glow... should that be?',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15784,'0',NULL,NULL,'v2 ysera1'),
+(-1603338,'For it to be as it must, yes.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15632,'0',NULL,NULL,'v2 neltharion2'),
+(-1603339,'It is a weapon like no other. It must be like no other.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15610,'0',NULL,NULL,'v2 malygos1'),
+(-1603340,'His brood learned their lesson before too long, you shall soon learn yours!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15765,'0',NULL,NULL,'v2 yogg1'),
+-- stormwind v1
+(-1603341,'Bad news sire. The clans are united under Blackhand in this assault. They will stand together until Stormwind has fallen.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15538,'0',NULL,NULL,'v3 garona1'),
+(-1603342,'Gul\'dan is bringing up his warlocks by nightfall. Until then, the Blackrock clan will be trying to take the Eastern Wall.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15539,'0',NULL,NULL,'v3 garona2'),
+(-1603343,'A thousand deaths... ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15762,'0',NULL,NULL,'v3 yogg1'),
+(-1603344,'or one murder.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15763,'0',NULL,NULL,'v3 yogg2'),
+(-1603345,'We will hold until the reinforcements come. As long as men with stout hearts are manning the walls and throne Stormwind will hold.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15340,'0',NULL,NULL,'v3 king llane1'),
+(-1603346,'The orc leaders agree with your assessment.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15341,'0',NULL,NULL,'v3 garona3'),
+(-1603347,'Your petty quarrels only make me stronger!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15764,'0',NULL,NULL,'v3 yogg3'),
+
+-- Alagon:
+(-1603140,'Your actions are illogical. All possible results for this encounter have been calculated. The pantheon will receive the observer\'s message regardless outcome.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15386,'1',NULL,NULL,'Agro_algalon the observer'),
+(-1603141,'See your world through my eyes. A universe so vast as to be immeasurable. Incomprehensible even to your greatest minds.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15390,'1',NULL,NULL,'Engaged for the first time algalon'),
+(-1603142,'Witness the fury of cosmos!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15396,'1',NULL,NULL,'BIG BANG 1_Algalon'),
+(-1603143,'Behold the tools of creation!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15397,'1',NULL,NULL,'BIG BANG 2_Algalon\r\n'),
+(-1603144,'Beware!',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15391,'1',NULL,NULL,'Phase2_algalon\r\n'),
+(-1603145,'Loss of life, unavoidable.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15387,'1',NULL,NULL,'Killing a player_alagalon\r\n'),
+(-1603146,'I do what I must.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15388,'1',NULL,NULL,'killing a player2_algalon\r\n'),
+(-1603147,'You are... out of time.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15394,'1',NULL,NULL,'BERSEKER_ALGALON'),
+(-1603148,'The stars come to my aid.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15392,'1',NULL,NULL,'Summoning Collapsing Stars_Algalon1'),
+(-1603149,'I lack the strength to transmit this signal. You must hurry. Find a place of power, close to the skies.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,15403,'1',NULL,NULL,'Summoning Collapsing Stars_Algalon2'),
+(-1603279,"Do not worry about my fate <name>. If the signal is not transmitted in time re-origination will proceed regardless. Save. Your. World.","","","","","","","","",15404,1,0,0,"algalon outro 5"),
+(-1603278,"I've rearranged the reply code. Your planet will be spared. I cannot be certain of my own calculations anymore.","","","","","","","","",15402,1,0,0,"algalon outro 3"),
+(-1603277,"Perhaps it is your imperfection that which grants you free will. That allows you to persevere against cosmically calculated odds. You prevailed where the Titans' own perfect creations have failed.","","","","","","","","",15401,1,0,0,"algalon outro 2"),
+(-1603276,"I have seen worlds bathed in the Makers' flames. Their denizens fading without so much as a whimper. Entire planetary systems born and raised in the time that it takes your mortal hearts to beat once. Yet all throughout, my own heart, devoid of emotion... of empathy. I... have... felt... NOTHING! A million, million lives wasted. Had they all held within them your tenacity? Had they all loved life as you do?","","","","","","","","",15393,1,0,0,"algalon outro1"),
+(-1603275,"Farewell, mortals. Your bravery is admirable, for such flawed creatures.","","","","","","","","",15400,1,0,0,"algalon despwnd 3"),
+(-1603274,"Begin uplink: Reply Code: 'Omega'. Planetary re-origination requested.","","","","","","","","",15399,1,0,0,"algalon despawn 2"),
+(-1603273,"Analysis complete. There is partial corruption in the plane's life-support systems as well as complete corruption in most of the planet's defense mechanisms.","","","","","","","","",15398,1,0,0,"algalon despawn1"),
+(-1603272,"It is in the universe's best interest to re-originate this planet should my analysis find systemic corruption. Do not interfere.","","","","","","","","",15407,1,0,0,"algalon intro3"),
+(-1603271,"Stand back, mortals. I am not here to fight you.","","","","","","","","",15406,1,0,0,"Algalon intro2"),
+(-1603270,"Trans-location complete. Commencing planetary analysis of Azeroth.","","","","","","","","",15405,1,0,0,"Algalon intro1");
+
+-- Archivum dialogue:	TODO:
+-- Brann
+-- Archivum
\ No newline at end of file
diff --git a/system/ScriptLoader.cpp b/system/ScriptLoader.cpp
index 3af30ff..0568472 100644
--- a/system/ScriptLoader.cpp
+++ b/system/ScriptLoader.cpp
@@ -319,7 +319,22 @@ extern void AddSC_boss_maiden_of_grief();                   //Ulduar, halls_of_s
 extern void AddSC_boss_sjonnir();
 extern void AddSC_halls_of_stone();
 extern void AddSC_instance_halls_of_stone();
-extern void AddSC_instance_ulduar();                        //ulduar
+extern void AddSC_boss_algalon();                           //Ulduar
+extern void AddSC_boss_auriaya();
+extern void AddSC_boss_freya();
+extern void AddSC_boss_hodir();
+extern void AddSC_boss_ignis();
+extern void AddSC_boss_iron_council();
+extern void AddSC_boss_kologarn();
+extern void AddSC_boss_leviathan();
+extern void AddSC_boss_mimiron();
+extern void AddSC_boss_razorscale();
+extern void AddSC_boss_thorim();
+extern void AddSC_boss_vezax();
+extern void AddSC_boss_xt002();
+extern void AddSC_boss_yogg_saron();
+extern void AddSC_instance_ulduar();                        
+extern void AddSC_ulduar();
 extern void AddSC_boss_ingvar();                            //utgarde_keep
 extern void AddSC_boss_keleseth();
 extern void AddSC_boss_skarvald_and_dalronn();
@@ -738,7 +753,22 @@ void AddScripts()
     AddSC_boss_sjonnir();
     AddSC_halls_of_stone();
     AddSC_instance_halls_of_stone();
-    AddSC_instance_ulduar();                                //ulduar
+    AddSC_boss_algalon();                                   //Ulduar
+    AddSC_boss_auriaya();
+    AddSC_boss_freya();
+    AddSC_boss_hodir();
+    AddSC_boss_ignis();
+    AddSC_boss_iron_council();
+    AddSC_boss_kologarn();
+    AddSC_boss_leviathan();
+    AddSC_boss_mimiron();
+    AddSC_boss_razorscale();
+    AddSC_boss_thorim();
+    AddSC_boss_vezax();
+    AddSC_boss_xt002();
+    AddSC_boss_yogg_saron();
+    AddSC_instance_ulduar();                                
+    AddSC_ulduar();
     AddSC_boss_ingvar();                                    //utgarde_keep
     AddSC_boss_keleseth();
     AddSC_boss_skarvald_and_dalronn();
